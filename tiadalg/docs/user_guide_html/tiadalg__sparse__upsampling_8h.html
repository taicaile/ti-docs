<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>TI Autonomous Driving Algorithms (TIADALG) Library User Guide: tiadalg_sparse_upsampling.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ti_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TI Autonomous Driving Algorithms (TIADALG) Library User Guide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tiadalg__sparse__upsampling_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">tiadalg_sparse_upsampling.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This file defines the interface for sparse up-sampling and convolution operation.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
</div>
<p><a href="tiadalg__sparse__upsampling_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a856a2d1cb07e71806b17f89e54a1b860"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tiadalg__sparse__upsampling_8h.html#a856a2d1cb07e71806b17f89e54a1b860">tiadalg_sparse_upsampling_cn</a> (int8_t *desc_plane, uint32_t desc_line_pitch, uint32_t desc_plane_pitch, uint16_t num_desc_planes, int8_t *filter_coeff, int16_t *bias, int32_t *key_point_list, uint16_t num_key_points, int16_t *scratch_buffer, uint8_t is_scratch_filled, int32_t desc_scale, int32_t filter_scale, int32_t bias_scale, int32_t out_scale, void *out_desc, int32_t in_desc_data_type, int32_t out_desc_data_type)</td></tr>
<tr class="memdesc:a856a2d1cb07e71806b17f89e54a1b860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the keypoint locations list at higher image resolution and descriptors at lower image resolution, higher resolution descriptor is derived by nearest neighbour upsampling scheme and spatial 7x7 filtering centered at keypoint location. Only 4x4 upsampling is supported by this API. And 7x7 intra descriptor plane filtering post upsampling is applied. The process is equivalent of upsampling the descriptor plane by factor 4 in both direction, and selecting the values specific to key point locations.  <a href="#a856a2d1cb07e71806b17f89e54a1b860">More...</a><br /></td></tr>
<tr class="separator:a856a2d1cb07e71806b17f89e54a1b860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeacb55143df154394e28b604b4a70c4"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tiadalg__sparse__upsampling_8h.html#abeacb55143df154394e28b604b4a70c4">tiadalg_sparse_upsampling_c66</a> (int8_t *desc_plane, uint32_t desc_line_pitch, uint32_t desc_plane_pitch, uint16_t num_desc_planes, int8_t *filter_coeff, int16_t *bias, int32_t *key_point_list, uint16_t num_key_points, int16_t *scratch_buffer, uint8_t is_scratch_filled, int32_t desc_scale, int32_t filter_scale, int32_t bias_scale, int32_t out_scale, void *out_desc, int32_t in_desc_data_type, int32_t out_desc_data_type)</td></tr>
<tr class="memdesc:abeacb55143df154394e28b604b4a70c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the keypoint locations list at higher image resolution and descriptors at lower image resolution, higher resolution descriptor is derived by nearest neighbour upsampling scheme and spatial 7x7 filtering centered at keypoint location. Only 4x4 upsampling is supported by this API. And 7x7 intra descriptor plane filtering post upsampling is applied. The process is equivalent of upsampling the descriptor plane by factor 4 in both direction, and selecting the values specific to key point locations.  <a href="#abeacb55143df154394e28b604b4a70c4">More...</a><br /></td></tr>
<tr class="separator:abeacb55143df154394e28b604b4a70c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file defines the interface for sparse up-sampling and convolution operation. </p>
<dl class="section version"><dt>Version</dt><dd>0.1 Sep 2019 : Initial Code </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a856a2d1cb07e71806b17f89e54a1b860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a856a2d1cb07e71806b17f89e54a1b860">&#9670;&nbsp;</a></span>tiadalg_sparse_upsampling_cn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t tiadalg_sparse_upsampling_cn </td>
          <td>(</td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>desc_plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>desc_line_pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>desc_plane_pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_desc_planes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>filter_coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>bias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>key_point_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_key_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>scratch_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>is_scratch_filled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>desc_scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>filter_scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>bias_scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>out_scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>out_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>in_desc_data_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>out_desc_data_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the keypoint locations list at higher image resolution and descriptors at lower image resolution, higher resolution descriptor is derived by nearest neighbour upsampling scheme and spatial 7x7 filtering centered at keypoint location. Only 4x4 upsampling is supported by this API. And 7x7 intra descriptor plane filtering post upsampling is applied. The process is equivalent of upsampling the descriptor plane by factor 4 in both direction, and selecting the values specific to key point locations. </p>
<p>tiadalg_sparse_upsampling_cn</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc_plane</td><td>[in] : Input descriptor data buffer at lower resolution e.g. (w/4)x(h/4) </td></tr>
    <tr><td class="paramname">desc_line_pitch</td><td>[in] : One line pitch in each descriptor plane of resolution (w/4)x(h/4) </td></tr>
    <tr><td class="paramname">desc_plane_pitch</td><td>[in] : Plane pitch for each descriptor plane </td></tr>
    <tr><td class="paramname">num_desc_planes</td><td>[in] : Number of descriptor planes </td></tr>
    <tr><td class="paramname">filter_coeff</td><td>[in] : Filter coefficient (7x7) for each descriptor plane, to be applied after 4x4 upsampling the desc_plane </td></tr>
    <tr><td class="paramname">bias</td><td>[in] : 16 bit bias to be applied after 7x7 up-sampling filter for each descriptor plane </td></tr>
    <tr><td class="paramname">key_point_list</td><td>[in] : Key point locations in higher image resolution domain e.g. (wxh) </td></tr>
    <tr><td class="paramname">num_key_points</td><td>[in] : Number of key points </td></tr>
    <tr><td class="paramname">scratch_buffer</td><td>[in] : Scartch buffer required. Not used in _cn API </td></tr>
    <tr><td class="paramname">is_scratch_filled</td><td>[in] : If scratch buffer was filled by previous call of the API, then it should be passed as '1' otherwise '0' </td></tr>
    <tr><td class="paramname">desc_scale</td><td>[in] : Scale of descriptor in power of 2 </td></tr>
    <tr><td class="paramname">filter_scale</td><td>[in] : Filter scale in power of 2 </td></tr>
    <tr><td class="paramname">bias_scale</td><td>[in] : Bias scale in power of 2 </td></tr>
    <tr><td class="paramname">out_scale</td><td>[in] : Output scale required in power of 2 </td></tr>
    <tr><td class="paramname">out_desc</td><td>[out] : Output upsampled descriptor at higher resolution </td></tr>
    <tr><td class="paramname">in_desc_data_type</td><td>[in] : input descriptor data type. </td></tr>
    <tr><td class="paramname">out_desc_data_type</td><td>[in] : output descriptor data type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>Size of the buffer desc_plane is equal to desc_line_pitch * desc_plane_height * num_desc_planes</li>
<li>Size of the filter_coeff is 7 * 7 * num_desc_planes</li>
<li>x and y location for each key point has to be provided in the buffer key_point_list</li>
<li>Size of the buffer key_point_list is 2 * num_key_points.</li>
<li>Size of the out_desc is num_desc_planes * num_key_points</li>
<li>Input descriptor data desc_plane is expected in signed 8 bit</li>
<li>out_desc can be unsgined 8 bit or unsigned 16 bit depending on out_desc_data_type </li>
</ul>
</dd></dl>

</div>
</div>
<a id="abeacb55143df154394e28b604b4a70c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeacb55143df154394e28b604b4a70c4">&#9670;&nbsp;</a></span>tiadalg_sparse_upsampling_c66()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t tiadalg_sparse_upsampling_c66 </td>
          <td>(</td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>desc_plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>desc_line_pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>desc_plane_pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_desc_planes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>filter_coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>bias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>key_point_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_key_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>scratch_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>is_scratch_filled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>desc_scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>filter_scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>bias_scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>out_scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>out_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>in_desc_data_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>out_desc_data_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the keypoint locations list at higher image resolution and descriptors at lower image resolution, higher resolution descriptor is derived by nearest neighbour upsampling scheme and spatial 7x7 filtering centered at keypoint location. Only 4x4 upsampling is supported by this API. And 7x7 intra descriptor plane filtering post upsampling is applied. The process is equivalent of upsampling the descriptor plane by factor 4 in both direction, and selecting the values specific to key point locations. </p>
<p>tiadalg_sparse_upsampling_c66</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc_plane</td><td>[in] : Input descriptor data buffer at lower resolution e.g. (w/4)x(h/4) </td></tr>
    <tr><td class="paramname">desc_line_pitch</td><td>[in] : One line pitch in each descriptor plane of resolution (w/4)x(h/4) </td></tr>
    <tr><td class="paramname">desc_plane_pitch</td><td>[in] : Plane pitch for each descriptor plane </td></tr>
    <tr><td class="paramname">num_desc_planes</td><td>[in] : Number of descriptor planes </td></tr>
    <tr><td class="paramname">filter_coeff</td><td>[in] : Filter coefficient (7x7) for each descriptor plane, to be applied after 4x4 upsampling the desc_plane </td></tr>
    <tr><td class="paramname">bias</td><td>[in] : 16 bit bias to be applied after 7x7 up-sampling filter for each descriptor plane </td></tr>
    <tr><td class="paramname">key_point_list</td><td>[in] : Key point locations in higher image resolution domain e.g. (wxh) </td></tr>
    <tr><td class="paramname">num_key_points</td><td>[in] : Number of key points </td></tr>
    <tr><td class="paramname">scratch_buffer</td><td>[in] : Scartch buffer required. Not used in _cn API </td></tr>
    <tr><td class="paramname">is_scratch_filled</td><td>[in] : If scratch buffer was filled by previous call of the API, then it should be passed as '1' otherwise '0' </td></tr>
    <tr><td class="paramname">desc_scale</td><td>[in] : Scale of descriptor in power of 2 </td></tr>
    <tr><td class="paramname">filter_scale</td><td>[in] : Filter scale in power of 2 </td></tr>
    <tr><td class="paramname">bias_scale</td><td>[in] : Bias scale in power of 2 </td></tr>
    <tr><td class="paramname">out_scale</td><td>[in] : Output scale required in power of 2 </td></tr>
    <tr><td class="paramname">out_desc</td><td>[out] : Output upsampled descriptor at higher resolution </td></tr>
    <tr><td class="paramname">in_desc_data_type</td><td>[in] : input descriptor data type. </td></tr>
    <tr><td class="paramname">out_desc_data_type</td><td>[in] : output descriptor data type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>Size of the buffer desc_plane is equal to desc_line_pitch * desc_plane_height * num_desc_planes</li>
<li>Size of the filter_coeff is 7 * 7 * num_desc_planes</li>
<li>x and y location for each key point has to be provided in the buffer key_point_list</li>
<li>Size of the buffer key_point_list is 2 * num_key_points.</li>
<li>Size of the out_desc is num_desc_planes * num_key_points</li>
<li>Input descriptor data desc_plane is expected in signed 8 bit</li>
<li>out_desc can be unsgined 8 bit or unsigned 16 bit depending on out_desc_data_type </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->

<html>
<table bordercolor="#FFFFFF" bgcolor="#FFFFFF" width="100%">
<tr bgcolor="#CCCCCC">
      <td bgcolor="#FFFFFF">
        <hr align="left" noshade size="1">
      </td>
</tr>
<tr bgcolor="#CCCCCC">
      <td bgcolor="#FFFFFF"><font face="Verdana, Arial, Helvetica, sans-serif" size="1" color="#000000"><b><i>
        &copy Copyright 2018 Texas Instruments Incorporated. All rights reserved. </i></b></font></td>
</tr>
<tr bgcolor="#CCCCCC">
      <td bgcolor="#FFFFFF"><font face="Verdana, Arial, Helvetica, sans-serif" size="1" color="#000000">
        Document generated by <b><i> doxygen </i></b> 1.8.6
  </font></td>
</tr>
</table>
