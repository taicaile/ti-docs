<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<title>PDK API Guide for J721S2: UART Driver API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ti_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PDK API Guide for J721S2
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__DRV__UART__API__MODULE.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Sub Modules</a> &#124;
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#define-members">Macros</a>  </div>
  <div class="headertitle">
<div class="title">UART Driver API<div class="ingroups"><a class="el" href="group__DRV__UART__MODULE.html">UART Driver</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Introduction</h2>
<p>UART driver interface </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Sub Modules</h2></td></tr>
<tr class="memitem:group__UART__DRIVER__ERROR__CODE"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART__DRIVER__ERROR__CODE.html">UART Driver Error code</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:UART_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UART_8h.html">UART.h</a></td></tr>
<tr class="memdesc:UART_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART driver interface. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUART__Transaction.html">UART_Transaction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="structUART__Transaction.html" title="A UART_Transaction data structure is used with UART_read2(), UART_write2() and UART_Callback2()">UART_Transaction</a> data structure is used with <a class="el" href="group__DRV__UART__API__MODULE.html#ga59997fcf8ebb14c34797717d9dde8d6e" title="Extended function that read data from a UART.">UART_read2()</a>, <a class="el" href="group__DRV__UART__API__MODULE.html#ga6fc38efd825942b5a43e937411aab890" title="Extended function that writes data to a UART.">UART_write2()</a> and <a class="el" href="group__DRV__UART__API__MODULE.html#ga873e53d7c98e831152ca7186b7209cd7" title="The definition of a callback2 function used by the UART driver when used in UART_MODE_CALLBACK.">UART_Callback2()</a>  <a href="structUART__Transaction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUART__Params.html">UART_Params</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic UART Parameters.  <a href="structUART__Params.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUART__FxnTable.html">UART_FxnTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition of a UART function table that contains the required set of functions to control a specific UART driver implementation.  <a href="structUART__FxnTable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUART__Config.html">UART_Config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART Global configuration.  <a href="structUART__Config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga74da6620ba02549caeffff1ba1a12878"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__UART__API__MODULE.html#ga74da6620ba02549caeffff1ba1a12878">UART_close</a> (<a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> uartHnd)</td></tr>
<tr class="memdesc:ga74da6620ba02549caeffff1ba1a12878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to closes a given UART peripheral specified by the UART handle.  <a href="#ga74da6620ba02549caeffff1ba1a12878">More...</a><br /></td></tr>
<tr class="separator:ga74da6620ba02549caeffff1ba1a12878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafff81a6e76deb098c5d3ebfcd758472b"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__UART__API__MODULE.html#gafff81a6e76deb098c5d3ebfcd758472b">UART_control</a> (<a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> uartHnd, uint32_t <a class="el" href="gptpipc_8h.html#a2766e0be89a1a57a241e8557b71cf9e1">cmd</a>, void *arg)</td></tr>
<tr class="memdesc:gafff81a6e76deb098c5d3ebfcd758472b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function performs implementation specific features on a given UART_Handle.  <a href="#gafff81a6e76deb098c5d3ebfcd758472b">More...</a><br /></td></tr>
<tr class="separator:gafff81a6e76deb098c5d3ebfcd758472b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab60a36f7295d704926120d22f806dcd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__UART__API__MODULE.html#gab60a36f7295d704926120d22f806dcd1">UART_init</a> (void)</td></tr>
<tr class="memdesc:gab60a36f7295d704926120d22f806dcd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to initializes the UART module.  <a href="#gab60a36f7295d704926120d22f806dcd1">More...</a><br /></td></tr>
<tr class="separator:gab60a36f7295d704926120d22f806dcd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49e4b22cd81c9435577ea35ead0c6a38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__UART__API__MODULE.html#ga49e4b22cd81c9435577ea35ead0c6a38">UART_open</a> (uint32_t idx, <a class="el" href="structUART__Params.html">UART_Params</a> *uartParams)</td></tr>
<tr class="memdesc:ga49e4b22cd81c9435577ea35ead0c6a38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to initialize a given UART peripheral specified by the particular index value. The parameter specifies which mode the UART will operate.  <a href="#ga49e4b22cd81c9435577ea35ead0c6a38">More...</a><br /></td></tr>
<tr class="separator:ga49e4b22cd81c9435577ea35ead0c6a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga433972fdc2d8d45d2ecef607a61e4cff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__UART__API__MODULE.html#ga433972fdc2d8d45d2ecef607a61e4cff">UART_Params_init</a> (<a class="el" href="structUART__Params.html">UART_Params</a> *uartParams)</td></tr>
<tr class="memdesc:ga433972fdc2d8d45d2ecef607a61e4cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to initialize the <a class="el" href="structUART__Params.html" title="Basic UART Parameters.">UART_Params</a> struct to its defaults.  <a href="#ga433972fdc2d8d45d2ecef607a61e4cff">More...</a><br /></td></tr>
<tr class="separator:ga433972fdc2d8d45d2ecef607a61e4cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb9e485ab29323a7df04c922dfc4c5fe"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__UART__API__MODULE.html#gadb9e485ab29323a7df04c922dfc4c5fe">UART_write</a> (<a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> uartHnd, const void *buffer, size_t <a class="el" href="tisci__rm__ra_8h.html#ae5dc6ffcd9b7605c7787791e40cc6bb0">size</a>)</td></tr>
<tr class="memdesc:gadb9e485ab29323a7df04c922dfc4c5fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that writes data to a UART.  <a href="#gadb9e485ab29323a7df04c922dfc4c5fe">More...</a><br /></td></tr>
<tr class="separator:gadb9e485ab29323a7df04c922dfc4c5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea4c4bb14ae6ef5c66cbdac5a4f5c221"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__UART__API__MODULE.html#gaea4c4bb14ae6ef5c66cbdac5a4f5c221">UART_writePolling</a> (<a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> uartHnd, const void *buffer, size_t <a class="el" href="tisci__rm__ra_8h.html#ae5dc6ffcd9b7605c7787791e40cc6bb0">size</a>)</td></tr>
<tr class="memdesc:gaea4c4bb14ae6ef5c66cbdac5a4f5c221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that writes data to a UART.  <a href="#gaea4c4bb14ae6ef5c66cbdac5a4f5c221">More...</a><br /></td></tr>
<tr class="separator:gaea4c4bb14ae6ef5c66cbdac5a4f5c221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0482cd0ab9ee7e802c8e785a5754d16d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__UART__API__MODULE.html#ga0482cd0ab9ee7e802c8e785a5754d16d">UART_writeCancel</a> (<a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle)</td></tr>
<tr class="memdesc:ga0482cd0ab9ee7e802c8e785a5754d16d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that cancels a UART_write function call.  <a href="#ga0482cd0ab9ee7e802c8e785a5754d16d">More...</a><br /></td></tr>
<tr class="separator:ga0482cd0ab9ee7e802c8e785a5754d16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e5f16eaf4eff8add9e52911ab4b5df5"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__UART__API__MODULE.html#ga8e5f16eaf4eff8add9e52911ab4b5df5">UART_read</a> (<a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle, void *buffer, size_t <a class="el" href="tisci__rm__ra_8h.html#ae5dc6ffcd9b7605c7787791e40cc6bb0">size</a>)</td></tr>
<tr class="memdesc:ga8e5f16eaf4eff8add9e52911ab4b5df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that read data from a UART.  <a href="#ga8e5f16eaf4eff8add9e52911ab4b5df5">More...</a><br /></td></tr>
<tr class="separator:ga8e5f16eaf4eff8add9e52911ab4b5df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffab6273a151a89a8b4c3c2fc0846d0c"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__UART__API__MODULE.html#gaffab6273a151a89a8b4c3c2fc0846d0c">UART_readPolling</a> (<a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle, void *buffer, size_t <a class="el" href="tisci__rm__ra_8h.html#ae5dc6ffcd9b7605c7787791e40cc6bb0">size</a>)</td></tr>
<tr class="memdesc:gaffab6273a151a89a8b4c3c2fc0846d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that reads data from a UART.  <a href="#gaffab6273a151a89a8b4c3c2fc0846d0c">More...</a><br /></td></tr>
<tr class="separator:gaffab6273a151a89a8b4c3c2fc0846d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51ed7e94d5b409ca1fcb2d65c5a25c3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__UART__API__MODULE.html#ga51ed7e94d5b409ca1fcb2d65c5a25c3c">UART_readCancel</a> (<a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle)</td></tr>
<tr class="memdesc:ga51ed7e94d5b409ca1fcb2d65c5a25c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that cancels a UART_read function call.  <a href="#ga51ed7e94d5b409ca1fcb2d65c5a25c3c">More...</a><br /></td></tr>
<tr class="separator:ga51ed7e94d5b409ca1fcb2d65c5a25c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59997fcf8ebb14c34797717d9dde8d6e"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__UART__API__MODULE.html#ga59997fcf8ebb14c34797717d9dde8d6e">UART_read2</a> (<a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle, <a class="el" href="structUART__Transaction.html">UART_Transaction</a> *uartTrans)</td></tr>
<tr class="memdesc:ga59997fcf8ebb14c34797717d9dde8d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extended function that read data from a UART.  <a href="#ga59997fcf8ebb14c34797717d9dde8d6e">More...</a><br /></td></tr>
<tr class="separator:ga59997fcf8ebb14c34797717d9dde8d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fc38efd825942b5a43e937411aab890"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__UART__API__MODULE.html#ga6fc38efd825942b5a43e937411aab890">UART_write2</a> (<a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle, <a class="el" href="structUART__Transaction.html">UART_Transaction</a> *uartTrans)</td></tr>
<tr class="memdesc:ga6fc38efd825942b5a43e937411aab890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extended function that writes data to a UART.  <a href="#ga6fc38efd825942b5a43e937411aab890">More...</a><br /></td></tr>
<tr class="separator:ga6fc38efd825942b5a43e937411aab890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca30376be73cc071bfb8759a8a23e9b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__UART__API__MODULE.html#gaca30376be73cc071bfb8759a8a23e9b8">UART_transactionInit</a> (<a class="el" href="structUART__Transaction.html">UART_Transaction</a> *uartTrans)</td></tr>
<tr class="memdesc:gaca30376be73cc071bfb8759a8a23e9b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to initialize the <a class="el" href="structUART__Transaction.html" title="A UART_Transaction data structure is used with UART_read2(), UART_write2() and UART_Callback2()">UART_Transaction</a> struct to its defaults.  <a href="#gaca30376be73cc071bfb8759a8a23e9b8">More...</a><br /></td></tr>
<tr class="separator:gaca30376be73cc071bfb8759a8a23e9b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga9a2cb7a6a7cd3136a2299f155ebd0a36"><td class="memItemLeft" align="right" valign="top">typedef struct UART_Config_s *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a></td></tr>
<tr class="memdesc:ga9a2cb7a6a7cd3136a2299f155ebd0a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle that is returned from a <a class="el" href="group__DRV__UART__API__MODULE.html#ga49e4b22cd81c9435577ea35ead0c6a38" title="Function to initialize a given UART peripheral specified by the particular index value....">UART_open()</a> call.  <a href="#ga9a2cb7a6a7cd3136a2299f155ebd0a36">More...</a><br /></td></tr>
<tr class="separator:ga9a2cb7a6a7cd3136a2299f155ebd0a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d43bd8997e9153ce790bc81467ec935"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__UART__API__MODULE.html#ga5d43bd8997e9153ce790bc81467ec935">UART_Callback</a>) (<a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle, void *buf, size_t <a class="el" href="tisci__rm__ra_8h.html#a86988a65e0d3ece7990c032c159786d6">count</a>)</td></tr>
<tr class="memdesc:ga5d43bd8997e9153ce790bc81467ec935"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition of a callback function used by the UART driver when used in <a class="el" href="group__DRV__UART__API__MODULE.html#gga2507a620dba95cd20885c52494d19e90ae0dbd9b5195e56c3c2aed10163523754">UART_MODE_CALLBACK</a>.  <a href="#ga5d43bd8997e9153ce790bc81467ec935">More...</a><br /></td></tr>
<tr class="separator:ga5d43bd8997e9153ce790bc81467ec935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga873e53d7c98e831152ca7186b7209cd7"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__UART__API__MODULE.html#ga873e53d7c98e831152ca7186b7209cd7">UART_Callback2</a>) (<a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle, <a class="el" href="structUART__Transaction.html">UART_Transaction</a> *transaction)</td></tr>
<tr class="memdesc:ga873e53d7c98e831152ca7186b7209cd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition of a callback2 function used by the UART driver when used in <a class="el" href="group__DRV__UART__API__MODULE.html#gga2507a620dba95cd20885c52494d19e90ae0dbd9b5195e56c3c2aed10163523754">UART_MODE_CALLBACK</a>.  <a href="#ga873e53d7c98e831152ca7186b7209cd7">More...</a><br /></td></tr>
<tr class="separator:ga873e53d7c98e831152ca7186b7209cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae08ff15291bd6b21cb4e2eb1fce164a6"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__UART__API__MODULE.html#gae08ff15291bd6b21cb4e2eb1fce164a6">UART_CloseFxn</a>) (<a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle)</td></tr>
<tr class="memdesc:gae08ff15291bd6b21cb4e2eb1fce164a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="group__DRV__UART__API__MODULE.html#gae08ff15291bd6b21cb4e2eb1fce164a6" title="A function pointer to a driver specific implementation of UART_CloseFxn().">UART_CloseFxn()</a>.  <a href="#gae08ff15291bd6b21cb4e2eb1fce164a6">More...</a><br /></td></tr>
<tr class="separator:gae08ff15291bd6b21cb4e2eb1fce164a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef3a1deae1514eb9c268f34542fe27b2"><td class="memItemLeft" align="right" valign="top">typedef int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__UART__API__MODULE.html#gaef3a1deae1514eb9c268f34542fe27b2">UART_ControlFxn</a>) (<a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle, uint32_t <a class="el" href="gptpipc_8h.html#a2766e0be89a1a57a241e8557b71cf9e1">cmd</a>, void *arg)</td></tr>
<tr class="memdesc:gaef3a1deae1514eb9c268f34542fe27b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="group__DRV__UART__API__MODULE.html#gaef3a1deae1514eb9c268f34542fe27b2" title="A function pointer to a driver specific implementation of UART_ControlFxn().">UART_ControlFxn()</a>.  <a href="#gaef3a1deae1514eb9c268f34542fe27b2">More...</a><br /></td></tr>
<tr class="separator:gaef3a1deae1514eb9c268f34542fe27b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b3e89df3065fffb47e7354067c14d1b"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__UART__API__MODULE.html#ga2b3e89df3065fffb47e7354067c14d1b">UART_InitFxn</a>) (<a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle)</td></tr>
<tr class="memdesc:ga2b3e89df3065fffb47e7354067c14d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="group__DRV__UART__API__MODULE.html#ga2b3e89df3065fffb47e7354067c14d1b" title="A function pointer to a driver specific implementation of UART_InitFxn().">UART_InitFxn()</a>.  <a href="#ga2b3e89df3065fffb47e7354067c14d1b">More...</a><br /></td></tr>
<tr class="separator:ga2b3e89df3065fffb47e7354067c14d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga207bd25ca9f85df92b668fa39219c00d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__UART__API__MODULE.html#ga207bd25ca9f85df92b668fa39219c00d">UART_OpenFxn</a>) (<a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle, const <a class="el" href="structUART__Params.html">UART_Params</a> *params)</td></tr>
<tr class="memdesc:ga207bd25ca9f85df92b668fa39219c00d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="group__DRV__UART__API__MODULE.html#ga207bd25ca9f85df92b668fa39219c00d" title="A function pointer to a driver specific implementation of UART_OpenFxn().">UART_OpenFxn()</a>.  <a href="#ga207bd25ca9f85df92b668fa39219c00d">More...</a><br /></td></tr>
<tr class="separator:ga207bd25ca9f85df92b668fa39219c00d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa82a43e1e6984f793b63c2a55aacad6a"><td class="memItemLeft" align="right" valign="top">typedef int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__UART__API__MODULE.html#gaa82a43e1e6984f793b63c2a55aacad6a">UART_ReadFxn</a>) (<a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle, void *buffer, size_t <a class="el" href="tisci__rm__ra_8h.html#ae5dc6ffcd9b7605c7787791e40cc6bb0">size</a>)</td></tr>
<tr class="memdesc:gaa82a43e1e6984f793b63c2a55aacad6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="group__DRV__UART__API__MODULE.html#gaa82a43e1e6984f793b63c2a55aacad6a" title="A function pointer to a driver specific implementation of UART_ReadFxn().">UART_ReadFxn()</a>.  <a href="#gaa82a43e1e6984f793b63c2a55aacad6a">More...</a><br /></td></tr>
<tr class="separator:gaa82a43e1e6984f793b63c2a55aacad6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5efe63f4037573a63df6ba811821296e"><td class="memItemLeft" align="right" valign="top">typedef int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__UART__API__MODULE.html#ga5efe63f4037573a63df6ba811821296e">UART_ReadPollingFxn</a>) (<a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle, void *buffer, size_t <a class="el" href="tisci__rm__ra_8h.html#ae5dc6ffcd9b7605c7787791e40cc6bb0">size</a>)</td></tr>
<tr class="memdesc:ga5efe63f4037573a63df6ba811821296e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="group__DRV__UART__API__MODULE.html#ga5efe63f4037573a63df6ba811821296e" title="A function pointer to a driver specific implementation of UART_ReadPollingFxn().">UART_ReadPollingFxn()</a>.  <a href="#ga5efe63f4037573a63df6ba811821296e">More...</a><br /></td></tr>
<tr class="separator:ga5efe63f4037573a63df6ba811821296e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa46296acc2c197a775d44458e1eca197"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__UART__API__MODULE.html#gaa46296acc2c197a775d44458e1eca197">UART_ReadCancelFxn</a>) (<a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle)</td></tr>
<tr class="memdesc:gaa46296acc2c197a775d44458e1eca197"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="group__DRV__UART__API__MODULE.html#gaa46296acc2c197a775d44458e1eca197" title="A function pointer to a driver specific implementation of UART_ReadCancelFxn().">UART_ReadCancelFxn()</a>.  <a href="#gaa46296acc2c197a775d44458e1eca197">More...</a><br /></td></tr>
<tr class="separator:gaa46296acc2c197a775d44458e1eca197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbc9b86a586eedd8eafecff9b46d5413"><td class="memItemLeft" align="right" valign="top">typedef int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__UART__API__MODULE.html#gabbc9b86a586eedd8eafecff9b46d5413">UART_WriteFxn</a>) (<a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle, const void *buffer, size_t <a class="el" href="tisci__rm__ra_8h.html#ae5dc6ffcd9b7605c7787791e40cc6bb0">size</a>)</td></tr>
<tr class="memdesc:gabbc9b86a586eedd8eafecff9b46d5413"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="group__DRV__UART__API__MODULE.html#gae08ff15291bd6b21cb4e2eb1fce164a6" title="A function pointer to a driver specific implementation of UART_CloseFxn().">UART_CloseFxn()</a>.  <a href="#gabbc9b86a586eedd8eafecff9b46d5413">More...</a><br /></td></tr>
<tr class="separator:gabbc9b86a586eedd8eafecff9b46d5413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6eb05c87515b7c7ccc71a1298dcfb93"><td class="memItemLeft" align="right" valign="top">typedef int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__UART__API__MODULE.html#gad6eb05c87515b7c7ccc71a1298dcfb93">UART_WritePollingFxn</a>) (<a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle, const void *buffer, size_t <a class="el" href="tisci__rm__ra_8h.html#ae5dc6ffcd9b7605c7787791e40cc6bb0">size</a>)</td></tr>
<tr class="memdesc:gad6eb05c87515b7c7ccc71a1298dcfb93"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="group__DRV__UART__API__MODULE.html#gad6eb05c87515b7c7ccc71a1298dcfb93" title="A function pointer to a driver specific implementation of UART_WritePollingFxn().">UART_WritePollingFxn()</a>.  <a href="#gad6eb05c87515b7c7ccc71a1298dcfb93">More...</a><br /></td></tr>
<tr class="separator:gad6eb05c87515b7c7ccc71a1298dcfb93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5a3d974279a2d161746dfbc8ca91774"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__UART__API__MODULE.html#gac5a3d974279a2d161746dfbc8ca91774">UART_WriteCancelFxn</a>) (<a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle)</td></tr>
<tr class="memdesc:gac5a3d974279a2d161746dfbc8ca91774"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="group__DRV__UART__API__MODULE.html#gac5a3d974279a2d161746dfbc8ca91774" title="A function pointer to a driver specific implementation of UART_WriteCancelFxn().">UART_WriteCancelFxn()</a>.  <a href="#gac5a3d974279a2d161746dfbc8ca91774">More...</a><br /></td></tr>
<tr class="separator:gac5a3d974279a2d161746dfbc8ca91774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49cacf984a8b1ce5144154561445b9ab"><td class="memItemLeft" align="right" valign="top">typedef int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__UART__API__MODULE.html#ga49cacf984a8b1ce5144154561445b9ab">UART_ReadFxn2</a>) (<a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle, <a class="el" href="structUART__Transaction.html">UART_Transaction</a> *transaction)</td></tr>
<tr class="memdesc:ga49cacf984a8b1ce5144154561445b9ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="group__DRV__UART__API__MODULE.html#ga49cacf984a8b1ce5144154561445b9ab" title="A function pointer to a driver specific implementation of UART_ReadFxn2().">UART_ReadFxn2()</a>.  <a href="#ga49cacf984a8b1ce5144154561445b9ab">More...</a><br /></td></tr>
<tr class="separator:ga49cacf984a8b1ce5144154561445b9ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad30c486bfc0594d4f2d20c414ea772b7"><td class="memItemLeft" align="right" valign="top">typedef int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__UART__API__MODULE.html#gad30c486bfc0594d4f2d20c414ea772b7">UART_WriteFxn2</a>) (<a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle, <a class="el" href="structUART__Transaction.html">UART_Transaction</a> *transaction)</td></tr>
<tr class="memdesc:gad30c486bfc0594d4f2d20c414ea772b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="group__DRV__UART__API__MODULE.html#gad30c486bfc0594d4f2d20c414ea772b7" title="A function pointer to a driver specific implementation of UART_WriteFxn2().">UART_WriteFxn2()</a>.  <a href="#gad30c486bfc0594d4f2d20c414ea772b7">More...</a><br /></td></tr>
<tr class="separator:gad30c486bfc0594d4f2d20c414ea772b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05a705cd472992be24068ac0867c5191"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structUART__Config.html">UART_Config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__UART__API__MODULE.html#ga05a705cd472992be24068ac0867c5191">UART_config_list</a>[<a class="el" href="group__DRV__UART__API__MODULE.html#gad97d3b4f681c4b85c45a6790a478c741">UART_MAX_CONFIG_CNT</a>]</td></tr>
<tr class="separator:ga05a705cd472992be24068ac0867c5191"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gad60e2918bf81b1fdbd92501450cafd3f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__UART__API__MODULE.html#gad60e2918bf81b1fdbd92501450cafd3f">UART_TransferApiVer</a> { <a class="el" href="group__DRV__UART__API__MODULE.html#ggad60e2918bf81b1fdbd92501450cafd3fa94de5243b571859adff2c3609cab8158">UART_TRANSFER_API_VER_1</a> = 1, 
<a class="el" href="group__DRV__UART__API__MODULE.html#ggad60e2918bf81b1fdbd92501450cafd3fa2c7e71f798ccc85eccc6fef1b5a1818e">UART_TRANSFER_API_VER_2</a> = 2
 }</td></tr>
<tr class="memdesc:gad60e2918bf81b1fdbd92501450cafd3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer API version.  <a href="group__DRV__UART__API__MODULE.html#gad60e2918bf81b1fdbd92501450cafd3f">More...</a><br /></td></tr>
<tr class="separator:gad60e2918bf81b1fdbd92501450cafd3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga062eb5ad2b4db32fc72ef567fbe8fa1f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__UART__API__MODULE.html#ga062eb5ad2b4db32fc72ef567fbe8fa1f">UART_TransferStatus</a> { <br />
&#160;&#160;<a class="el" href="group__DRV__UART__API__MODULE.html#gga062eb5ad2b4db32fc72ef567fbe8fa1fa28750fe366372c6b058358bb84e2a693">UART_TRANSFER_STATUS_SUCCESS</a> = 0, 
<a class="el" href="group__DRV__UART__API__MODULE.html#gga062eb5ad2b4db32fc72ef567fbe8fa1fa51bde3f52cc635e82cce54e82fd1dfe4">UART_TRANSFER_STATUS_TIMEOUT</a>, 
<a class="el" href="group__DRV__UART__API__MODULE.html#gga062eb5ad2b4db32fc72ef567fbe8fa1fa7f431a58bcbf3434a6573506a9f6fe1c">UART_TRANSFER_STATUS_ERROR_BI</a>, 
<a class="el" href="group__DRV__UART__API__MODULE.html#gga062eb5ad2b4db32fc72ef567fbe8fa1fa912ac66c4f685240b24a2497ea209cb2">UART_TRANSFER_STATUS_ERROR_FE</a>, 
<br />
&#160;&#160;<a class="el" href="group__DRV__UART__API__MODULE.html#gga062eb5ad2b4db32fc72ef567fbe8fa1fafbd6b81b685533389893a0bf310d2f08">UART_TRANSFER_STATUS_ERROR_PE</a>, 
<a class="el" href="group__DRV__UART__API__MODULE.html#gga062eb5ad2b4db32fc72ef567fbe8fa1fabb82c3eef70a1c125154f316f04c0b72">UART_TRANSFER_STATUS_ERROR_OE</a>, 
<a class="el" href="group__DRV__UART__API__MODULE.html#gga062eb5ad2b4db32fc72ef567fbe8fa1fa37cd46eb9d4cc6ff7d3011317b643563">UART_TRANSFER_STATUS_ERROR_OTH</a>
<br />
 }</td></tr>
<tr class="memdesc:ga062eb5ad2b4db32fc72ef567fbe8fa1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer status codes that are set by the UART driver.  <a href="group__DRV__UART__API__MODULE.html#ga062eb5ad2b4db32fc72ef567fbe8fa1f">More...</a><br /></td></tr>
<tr class="separator:ga062eb5ad2b4db32fc72ef567fbe8fa1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2507a620dba95cd20885c52494d19e90"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__UART__API__MODULE.html#ga2507a620dba95cd20885c52494d19e90">UART_Mode</a> { <a class="el" href="group__DRV__UART__API__MODULE.html#gga2507a620dba95cd20885c52494d19e90ae6b6bd5d2d5df859ad6724e89e605ebf">UART_MODE_BLOCKING</a>, 
<a class="el" href="group__DRV__UART__API__MODULE.html#gga2507a620dba95cd20885c52494d19e90ae0dbd9b5195e56c3c2aed10163523754">UART_MODE_CALLBACK</a>
 }</td></tr>
<tr class="memdesc:ga2507a620dba95cd20885c52494d19e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART mode settings.  <a href="group__DRV__UART__API__MODULE.html#ga2507a620dba95cd20885c52494d19e90">More...</a><br /></td></tr>
<tr class="separator:ga2507a620dba95cd20885c52494d19e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb5a82843435a1b5d51b6c27028d914f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__UART__API__MODULE.html#gacb5a82843435a1b5d51b6c27028d914f">UART_ReturnMode</a> { <a class="el" href="group__DRV__UART__API__MODULE.html#ggacb5a82843435a1b5d51b6c27028d914fa50c07cbaf7518a0acd14137e801687e5">UART_RETURN_FULL</a>, 
<a class="el" href="group__DRV__UART__API__MODULE.html#ggacb5a82843435a1b5d51b6c27028d914fa3b8e419e0e12abf80b25f72d17745f76">UART_RETURN_NEWLINE</a>
 }</td></tr>
<tr class="memdesc:gacb5a82843435a1b5d51b6c27028d914f"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART return mode settings.  <a href="group__DRV__UART__API__MODULE.html#gacb5a82843435a1b5d51b6c27028d914f">More...</a><br /></td></tr>
<tr class="separator:gacb5a82843435a1b5d51b6c27028d914f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga694090fdb166f94ac30b809f9cba87b8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__UART__API__MODULE.html#ga694090fdb166f94ac30b809f9cba87b8">UART_DataMode</a> { <a class="el" href="group__DRV__UART__API__MODULE.html#gga694090fdb166f94ac30b809f9cba87b8aaa8edcbf6c236b0d86491ea1e7c9e4d8">UART_DATA_BINARY</a>, 
<a class="el" href="group__DRV__UART__API__MODULE.html#gga694090fdb166f94ac30b809f9cba87b8a87fdfb7ca981eab7f56c51380fd7094e">UART_DATA_TEXT</a>
 }</td></tr>
<tr class="memdesc:ga694090fdb166f94ac30b809f9cba87b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART data mode settings.  <a href="group__DRV__UART__API__MODULE.html#ga694090fdb166f94ac30b809f9cba87b8">More...</a><br /></td></tr>
<tr class="separator:ga694090fdb166f94ac30b809f9cba87b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac6a03c2e1d76f53e1d9d923dcdc24f2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__UART__API__MODULE.html#gaac6a03c2e1d76f53e1d9d923dcdc24f2">UART_Echo</a> { <a class="el" href="group__DRV__UART__API__MODULE.html#ggaac6a03c2e1d76f53e1d9d923dcdc24f2a2b286f182793d4a71bdf99409b9600dd">UART_ECHO_OFF</a> = 0, 
<a class="el" href="group__DRV__UART__API__MODULE.html#ggaac6a03c2e1d76f53e1d9d923dcdc24f2a6c4d8a2d4e30c22cf9fa45cd1bf79306">UART_ECHO_ON</a> = 1
 }</td></tr>
<tr class="memdesc:gaac6a03c2e1d76f53e1d9d923dcdc24f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART echo settings.  <a href="group__DRV__UART__API__MODULE.html#gaac6a03c2e1d76f53e1d9d923dcdc24f2">More...</a><br /></td></tr>
<tr class="separator:gaac6a03c2e1d76f53e1d9d923dcdc24f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf245d5f10db0abcbd8ad62a0d80c694"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__UART__API__MODULE.html#gadf245d5f10db0abcbd8ad62a0d80c694">UART_LEN</a> { <a class="el" href="group__DRV__UART__API__MODULE.html#ggadf245d5f10db0abcbd8ad62a0d80c694a27d04dd1fa818f764eb9b8e849feb7ff">UART_LEN_5</a> = 0, 
<a class="el" href="group__DRV__UART__API__MODULE.html#ggadf245d5f10db0abcbd8ad62a0d80c694a5bfd5507335d394d826e560930ce2a12">UART_LEN_6</a> = 1, 
<a class="el" href="group__DRV__UART__API__MODULE.html#ggadf245d5f10db0abcbd8ad62a0d80c694a2ac8467047f55cc1954388bf94c72e35">UART_LEN_7</a> = 2, 
<a class="el" href="group__DRV__UART__API__MODULE.html#ggadf245d5f10db0abcbd8ad62a0d80c694a31abbaaeaa38a5c66fbe13bfc8ece221">UART_LEN_8</a> = 3
 }</td></tr>
<tr class="memdesc:gadf245d5f10db0abcbd8ad62a0d80c694"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART data length settings.  <a href="group__DRV__UART__API__MODULE.html#gadf245d5f10db0abcbd8ad62a0d80c694">More...</a><br /></td></tr>
<tr class="separator:gadf245d5f10db0abcbd8ad62a0d80c694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga176b71ca19bc13d7534fa30fc18c2243"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__UART__API__MODULE.html#ga176b71ca19bc13d7534fa30fc18c2243">UART_STOP</a> { <a class="el" href="group__DRV__UART__API__MODULE.html#gga176b71ca19bc13d7534fa30fc18c2243a9bfa599e95c5da9cfe5f964dab8a9c6c">UART_STOP_ONE</a> = 0, 
<a class="el" href="group__DRV__UART__API__MODULE.html#gga176b71ca19bc13d7534fa30fc18c2243a3f41137f3775e7d33fdb250471c0248e">UART_STOP_TWO</a> = 1
 }</td></tr>
<tr class="memdesc:ga176b71ca19bc13d7534fa30fc18c2243"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART stop bit settings.  <a href="group__DRV__UART__API__MODULE.html#ga176b71ca19bc13d7534fa30fc18c2243">More...</a><br /></td></tr>
<tr class="separator:ga176b71ca19bc13d7534fa30fc18c2243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac70b5aa75500b8c45a51ec560deccfc4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__UART__API__MODULE.html#gac70b5aa75500b8c45a51ec560deccfc4">UART_PAR</a> { <br />
&#160;&#160;<a class="el" href="group__DRV__UART__API__MODULE.html#ggac70b5aa75500b8c45a51ec560deccfc4a469955a283c95f261990ad07043d5d2d">UART_PAR_NONE</a> = 0, 
<a class="el" href="group__DRV__UART__API__MODULE.html#ggac70b5aa75500b8c45a51ec560deccfc4a5405c8d842bffa2f76999eef9cee32c3">UART_PAR_EVEN</a> = 1, 
<a class="el" href="group__DRV__UART__API__MODULE.html#ggac70b5aa75500b8c45a51ec560deccfc4a498f72ae68542763da3072d3e3af6603">UART_PAR_ODD</a> = 2, 
<a class="el" href="group__DRV__UART__API__MODULE.html#ggac70b5aa75500b8c45a51ec560deccfc4adfb9d17fa33753ea5550e757b323bd46">UART_PAR_ZERO</a> = 3, 
<br />
&#160;&#160;<a class="el" href="group__DRV__UART__API__MODULE.html#ggac70b5aa75500b8c45a51ec560deccfc4a7ab50a9a14f4c614e875fbab74911afa">UART_PAR_ONE</a> = 4
<br />
 }</td></tr>
<tr class="memdesc:gac70b5aa75500b8c45a51ec560deccfc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART parity type settings.  <a href="group__DRV__UART__API__MODULE.html#gac70b5aa75500b8c45a51ec560deccfc4">More...</a><br /></td></tr>
<tr class="separator:gac70b5aa75500b8c45a51ec560deccfc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f9ece6c74cd7dd5b7569c54d5093794"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__UART__API__MODULE.html#ga6f9ece6c74cd7dd5b7569c54d5093794">UART_FC_TYPE</a> { <a class="el" href="group__DRV__UART__API__MODULE.html#gga6f9ece6c74cd7dd5b7569c54d5093794a527864f0ec595151e7db5ef909fcf9f0">UART_FC_NONE</a> = 0, 
<a class="el" href="group__DRV__UART__API__MODULE.html#gga6f9ece6c74cd7dd5b7569c54d5093794a98438b1cb72a9c48037258fa2f2d54f8">UART_FC_HW</a> = 1
 }</td></tr>
<tr class="memdesc:ga6f9ece6c74cd7dd5b7569c54d5093794"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART flow control settings.  <a href="group__DRV__UART__API__MODULE.html#ga6f9ece6c74cd7dd5b7569c54d5093794">More...</a><br /></td></tr>
<tr class="separator:ga6f9ece6c74cd7dd5b7569c54d5093794"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gae3b2b74054db9e708d6c4cb3300ec2b5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__UART__API__MODULE.html#gae3b2b74054db9e708d6c4cb3300ec2b5">UART_SUCCESS</a>&#160;&#160;&#160;((int32_t)(0))</td></tr>
<tr class="separator:gae3b2b74054db9e708d6c4cb3300ec2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e3562e7931cf51b41a32d8109072251"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__UART__API__MODULE.html#ga7e3562e7931cf51b41a32d8109072251">UART_ERROR</a>&#160;&#160;&#160;(-((int32_t)1))</td></tr>
<tr class="separator:ga7e3562e7931cf51b41a32d8109072251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d332e86b841e3aed39cdcee35d9508e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__UART__API__MODULE.html#ga7d332e86b841e3aed39cdcee35d9508e">UART_NO_WAIT</a>&#160;&#160;&#160;((uint32_t)0U)</td></tr>
<tr class="memdesc:ga7d332e86b841e3aed39cdcee35d9508e"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART transaction timeout define.  <a href="#ga7d332e86b841e3aed39cdcee35d9508e">More...</a><br /></td></tr>
<tr class="separator:ga7d332e86b841e3aed39cdcee35d9508e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada620b673241eb6335a71e75da291716"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__UART__API__MODULE.html#gada620b673241eb6335a71e75da291716">UART_WAIT_FOREVER</a>&#160;&#160;&#160;(~((uint32_t)0U))</td></tr>
<tr class="separator:gada620b673241eb6335a71e75da291716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad97d3b4f681c4b85c45a6790a478c741"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__UART__API__MODULE.html#gad97d3b4f681c4b85c45a6790a478c741">UART_MAX_CONFIG_CNT</a>&#160;&#160;&#160;(14U)</td></tr>
<tr class="separator:gad97d3b4f681c4b85c45a6790a478c741"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gae3b2b74054db9e708d6c4cb3300ec2b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3b2b74054db9e708d6c4cb3300ec2b5">&#9670;&nbsp;</a></span>UART_SUCCESS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART_SUCCESS&#160;&#160;&#160;((int32_t)(0))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga7e3562e7931cf51b41a32d8109072251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e3562e7931cf51b41a32d8109072251">&#9670;&nbsp;</a></span>UART_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART_ERROR&#160;&#160;&#160;(-((int32_t)1))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga7d332e86b841e3aed39cdcee35d9508e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d332e86b841e3aed39cdcee35d9508e">&#9670;&nbsp;</a></span>UART_NO_WAIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART_NO_WAIT&#160;&#160;&#160;((uint32_t)0U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART transaction timeout define. </p>

</div>
</div>
<a id="gada620b673241eb6335a71e75da291716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada620b673241eb6335a71e75da291716">&#9670;&nbsp;</a></span>UART_WAIT_FOREVER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART_WAIT_FOREVER&#160;&#160;&#160;(~((uint32_t)0U))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gad97d3b4f681c4b85c45a6790a478c741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad97d3b4f681c4b85c45a6790a478c741">&#9670;&nbsp;</a></span>UART_MAX_CONFIG_CNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART_MAX_CONFIG_CNT&#160;&#160;&#160;(14U)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga9a2cb7a6a7cd3136a2299f155ebd0a36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a2cb7a6a7cd3136a2299f155ebd0a36">&#9670;&nbsp;</a></span>UART_Handle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct UART_Config_s* <a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A handle that is returned from a <a class="el" href="group__DRV__UART__API__MODULE.html#ga49e4b22cd81c9435577ea35ead0c6a38" title="Function to initialize a given UART peripheral specified by the particular index value....">UART_open()</a> call. </p>

</div>
</div>
<a id="ga5d43bd8997e9153ce790bc81467ec935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d43bd8997e9153ce790bc81467ec935">&#9670;&nbsp;</a></span>UART_Callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* UART_Callback) (<a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle, void *buf, size_t <a class="el" href="tisci__rm__ra_8h.html#a86988a65e0d3ece7990c032c159786d6">count</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The definition of a callback function used by the UART driver when used in <a class="el" href="group__DRV__UART__API__MODULE.html#gga2507a620dba95cd20885c52494d19e90ae0dbd9b5195e56c3c2aed10163523754">UART_MODE_CALLBACK</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UART_Handle</td><td>UART_Handle</td></tr>
    <tr><td class="paramname">buf</td><td>Pointer to read/write buffer</td></tr>
    <tr><td class="paramname">count</td><td>Number of elements read/written </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga873e53d7c98e831152ca7186b7209cd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga873e53d7c98e831152ca7186b7209cd7">&#9670;&nbsp;</a></span>UART_Callback2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* UART_Callback2) (<a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle, <a class="el" href="structUART__Transaction.html">UART_Transaction</a> *transaction)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The definition of a callback2 function used by the UART driver when used in <a class="el" href="group__DRV__UART__API__MODULE.html#gga2507a620dba95cd20885c52494d19e90ae0dbd9b5195e56c3c2aed10163523754">UART_MODE_CALLBACK</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UART_Handle</td><td>UART_Handle</td></tr>
    <tr><td class="paramname">transaction</td><td>A pointer to a <a class="el" href="structUART__Transaction.html" title="A UART_Transaction data structure is used with UART_read2(), UART_write2() and UART_Callback2()">UART_Transaction</a>. All of the fields within transaction except <a class="el" href="structUART__Transaction.html#a32842a6d05bd3dc31d31a8502da5e190">UART_Transaction.count</a> and <a class="el" href="structUART__Transaction.html#a28a9bcc2fc5a31ca76306ef0a3547dff">UART_Transaction.status</a> are WO (write-only) unless otherwise noted in the driver implementations. If a transaction timeout or error has occured, <a class="el" href="structUART__Transaction.html#a32842a6d05bd3dc31d31a8502da5e190">UART_Transaction.count</a> will contain the number of bytes that were transferred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae08ff15291bd6b21cb4e2eb1fce164a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae08ff15291bd6b21cb4e2eb1fce164a6">&#9670;&nbsp;</a></span>UART_CloseFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* UART_CloseFxn) (<a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="group__DRV__UART__API__MODULE.html#gae08ff15291bd6b21cb4e2eb1fce164a6" title="A function pointer to a driver specific implementation of UART_CloseFxn().">UART_CloseFxn()</a>. </p>

</div>
</div>
<a id="gaef3a1deae1514eb9c268f34542fe27b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef3a1deae1514eb9c268f34542fe27b2">&#9670;&nbsp;</a></span>UART_ControlFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int32_t(* UART_ControlFxn) (<a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle, uint32_t <a class="el" href="gptpipc_8h.html#a2766e0be89a1a57a241e8557b71cf9e1">cmd</a>, void *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="group__DRV__UART__API__MODULE.html#gaef3a1deae1514eb9c268f34542fe27b2" title="A function pointer to a driver specific implementation of UART_ControlFxn().">UART_ControlFxn()</a>. </p>

</div>
</div>
<a id="ga2b3e89df3065fffb47e7354067c14d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b3e89df3065fffb47e7354067c14d1b">&#9670;&nbsp;</a></span>UART_InitFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* UART_InitFxn) (<a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="group__DRV__UART__API__MODULE.html#ga2b3e89df3065fffb47e7354067c14d1b" title="A function pointer to a driver specific implementation of UART_InitFxn().">UART_InitFxn()</a>. </p>

</div>
</div>
<a id="ga207bd25ca9f85df92b668fa39219c00d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga207bd25ca9f85df92b668fa39219c00d">&#9670;&nbsp;</a></span>UART_OpenFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a>(* UART_OpenFxn) (<a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle, const <a class="el" href="structUART__Params.html">UART_Params</a> *params)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="group__DRV__UART__API__MODULE.html#ga207bd25ca9f85df92b668fa39219c00d" title="A function pointer to a driver specific implementation of UART_OpenFxn().">UART_OpenFxn()</a>. </p>

</div>
</div>
<a id="gaa82a43e1e6984f793b63c2a55aacad6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa82a43e1e6984f793b63c2a55aacad6a">&#9670;&nbsp;</a></span>UART_ReadFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int32_t(* UART_ReadFxn) (<a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle, void *buffer, size_t <a class="el" href="tisci__rm__ra_8h.html#ae5dc6ffcd9b7605c7787791e40cc6bb0">size</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="group__DRV__UART__API__MODULE.html#gaa82a43e1e6984f793b63c2a55aacad6a" title="A function pointer to a driver specific implementation of UART_ReadFxn().">UART_ReadFxn()</a>. </p>

</div>
</div>
<a id="ga5efe63f4037573a63df6ba811821296e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5efe63f4037573a63df6ba811821296e">&#9670;&nbsp;</a></span>UART_ReadPollingFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int32_t(* UART_ReadPollingFxn) (<a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle, void *buffer, size_t <a class="el" href="tisci__rm__ra_8h.html#ae5dc6ffcd9b7605c7787791e40cc6bb0">size</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="group__DRV__UART__API__MODULE.html#ga5efe63f4037573a63df6ba811821296e" title="A function pointer to a driver specific implementation of UART_ReadPollingFxn().">UART_ReadPollingFxn()</a>. </p>

</div>
</div>
<a id="gaa46296acc2c197a775d44458e1eca197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa46296acc2c197a775d44458e1eca197">&#9670;&nbsp;</a></span>UART_ReadCancelFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* UART_ReadCancelFxn) (<a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="group__DRV__UART__API__MODULE.html#gaa46296acc2c197a775d44458e1eca197" title="A function pointer to a driver specific implementation of UART_ReadCancelFxn().">UART_ReadCancelFxn()</a>. </p>

</div>
</div>
<a id="gabbc9b86a586eedd8eafecff9b46d5413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbc9b86a586eedd8eafecff9b46d5413">&#9670;&nbsp;</a></span>UART_WriteFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int32_t(* UART_WriteFxn) (<a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle, const void *buffer, size_t <a class="el" href="tisci__rm__ra_8h.html#ae5dc6ffcd9b7605c7787791e40cc6bb0">size</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="group__DRV__UART__API__MODULE.html#gae08ff15291bd6b21cb4e2eb1fce164a6" title="A function pointer to a driver specific implementation of UART_CloseFxn().">UART_CloseFxn()</a>. </p>

</div>
</div>
<a id="gad6eb05c87515b7c7ccc71a1298dcfb93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6eb05c87515b7c7ccc71a1298dcfb93">&#9670;&nbsp;</a></span>UART_WritePollingFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int32_t(* UART_WritePollingFxn) (<a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle, const void *buffer, size_t <a class="el" href="tisci__rm__ra_8h.html#ae5dc6ffcd9b7605c7787791e40cc6bb0">size</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="group__DRV__UART__API__MODULE.html#gad6eb05c87515b7c7ccc71a1298dcfb93" title="A function pointer to a driver specific implementation of UART_WritePollingFxn().">UART_WritePollingFxn()</a>. </p>

</div>
</div>
<a id="gac5a3d974279a2d161746dfbc8ca91774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5a3d974279a2d161746dfbc8ca91774">&#9670;&nbsp;</a></span>UART_WriteCancelFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* UART_WriteCancelFxn) (<a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="group__DRV__UART__API__MODULE.html#gac5a3d974279a2d161746dfbc8ca91774" title="A function pointer to a driver specific implementation of UART_WriteCancelFxn().">UART_WriteCancelFxn()</a>. </p>

</div>
</div>
<a id="ga49cacf984a8b1ce5144154561445b9ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49cacf984a8b1ce5144154561445b9ab">&#9670;&nbsp;</a></span>UART_ReadFxn2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int32_t(* UART_ReadFxn2) (<a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle, <a class="el" href="structUART__Transaction.html">UART_Transaction</a> *transaction)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="group__DRV__UART__API__MODULE.html#ga49cacf984a8b1ce5144154561445b9ab" title="A function pointer to a driver specific implementation of UART_ReadFxn2().">UART_ReadFxn2()</a>. </p>

</div>
</div>
<a id="gad30c486bfc0594d4f2d20c414ea772b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad30c486bfc0594d4f2d20c414ea772b7">&#9670;&nbsp;</a></span>UART_WriteFxn2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int32_t(* UART_WriteFxn2) (<a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle, <a class="el" href="structUART__Transaction.html">UART_Transaction</a> *transaction)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="group__DRV__UART__API__MODULE.html#gad30c486bfc0594d4f2d20c414ea772b7" title="A function pointer to a driver specific implementation of UART_WriteFxn2().">UART_WriteFxn2()</a>. </p>

</div>
</div>
<a id="ga05a705cd472992be24068ac0867c5191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05a705cd472992be24068ac0867c5191">&#9670;&nbsp;</a></span>UART_config_list</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structUART__Config.html">UART_Config</a> UART_config_list[<a class="el" href="group__DRV__UART__API__MODULE.html#gad97d3b4f681c4b85c45a6790a478c741">UART_MAX_CONFIG_CNT</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gad60e2918bf81b1fdbd92501450cafd3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad60e2918bf81b1fdbd92501450cafd3f">&#9670;&nbsp;</a></span>UART_TransferApiVer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__DRV__UART__API__MODULE.html#gad60e2918bf81b1fdbd92501450cafd3f">UART_TransferApiVer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfer API version. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggad60e2918bf81b1fdbd92501450cafd3fa94de5243b571859adff2c3609cab8158"></a>UART_TRANSFER_API_VER_1&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggad60e2918bf81b1fdbd92501450cafd3fa2c7e71f798ccc85eccc6fef1b5a1818e"></a>UART_TRANSFER_API_VER_2&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ga062eb5ad2b4db32fc72ef567fbe8fa1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga062eb5ad2b4db32fc72ef567fbe8fa1f">&#9670;&nbsp;</a></span>UART_TransferStatus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__DRV__UART__API__MODULE.html#ga062eb5ad2b4db32fc72ef567fbe8fa1f">UART_TransferStatus</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfer status codes that are set by the UART driver. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga062eb5ad2b4db32fc72ef567fbe8fa1fa28750fe366372c6b058358bb84e2a693"></a>UART_TRANSFER_STATUS_SUCCESS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga062eb5ad2b4db32fc72ef567fbe8fa1fa51bde3f52cc635e82cce54e82fd1dfe4"></a>UART_TRANSFER_STATUS_TIMEOUT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga062eb5ad2b4db32fc72ef567fbe8fa1fa7f431a58bcbf3434a6573506a9f6fe1c"></a>UART_TRANSFER_STATUS_ERROR_BI&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga062eb5ad2b4db32fc72ef567fbe8fa1fa912ac66c4f685240b24a2497ea209cb2"></a>UART_TRANSFER_STATUS_ERROR_FE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga062eb5ad2b4db32fc72ef567fbe8fa1fafbd6b81b685533389893a0bf310d2f08"></a>UART_TRANSFER_STATUS_ERROR_PE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga062eb5ad2b4db32fc72ef567fbe8fa1fabb82c3eef70a1c125154f316f04c0b72"></a>UART_TRANSFER_STATUS_ERROR_OE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga062eb5ad2b4db32fc72ef567fbe8fa1fa37cd46eb9d4cc6ff7d3011317b643563"></a>UART_TRANSFER_STATUS_ERROR_OTH&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ga2507a620dba95cd20885c52494d19e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2507a620dba95cd20885c52494d19e90">&#9670;&nbsp;</a></span>UART_Mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__DRV__UART__API__MODULE.html#ga2507a620dba95cd20885c52494d19e90">UART_Mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART mode settings. </p>
<p>This enum defines the read and write modes for the configured UART. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga2507a620dba95cd20885c52494d19e90ae6b6bd5d2d5df859ad6724e89e605ebf"></a>UART_MODE_BLOCKING&#160;</td><td class="fielddoc"><p>Uses a semaphore to block while data is being sent. Context of the call must be a Task. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2507a620dba95cd20885c52494d19e90ae0dbd9b5195e56c3c2aed10163523754"></a>UART_MODE_CALLBACK&#160;</td><td class="fielddoc"><p>Non-blocking and will return immediately. When the transfer by the Hwi is finished the configured callback function is called. </p>
</td></tr>
</table>

</div>
</div>
<a id="gacb5a82843435a1b5d51b6c27028d914f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb5a82843435a1b5d51b6c27028d914f">&#9670;&nbsp;</a></span>UART_ReturnMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__DRV__UART__API__MODULE.html#gacb5a82843435a1b5d51b6c27028d914f">UART_ReturnMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART return mode settings. </p>
<p>This enumeration defines the return modes for UART_read and UART_readPolling. UART_RETURN_FULL unblocks or performs a callback when the read buffer has been filled. UART_RETURN_NEWLINE unblocks or performs a callback whenever a newline character has been received. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggacb5a82843435a1b5d51b6c27028d914fa50c07cbaf7518a0acd14137e801687e5"></a>UART_RETURN_FULL&#160;</td><td class="fielddoc"><p>Unblock/callback when buffer is full. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacb5a82843435a1b5d51b6c27028d914fa3b8e419e0e12abf80b25f72d17745f76"></a>UART_RETURN_NEWLINE&#160;</td><td class="fielddoc"><p>Unblock/callback when newline character is received. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga694090fdb166f94ac30b809f9cba87b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga694090fdb166f94ac30b809f9cba87b8">&#9670;&nbsp;</a></span>UART_DataMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__DRV__UART__API__MODULE.html#ga694090fdb166f94ac30b809f9cba87b8">UART_DataMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART data mode settings. </p>
<p>This enumeration defines the data mode for read and write. If the DataMode is text for write, write will add a return before a newline character. If the DataMode is text for a read, read will replace a return with a newline. This effectively treats all device line endings as LF and all host PC line endings as CRLF. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga694090fdb166f94ac30b809f9cba87b8aaa8edcbf6c236b0d86491ea1e7c9e4d8"></a>UART_DATA_BINARY&#160;</td><td class="fielddoc"><p>Data is not processed </p>
</td></tr>
<tr><td class="fieldname"><a id="gga694090fdb166f94ac30b809f9cba87b8a87fdfb7ca981eab7f56c51380fd7094e"></a>UART_DATA_TEXT&#160;</td><td class="fielddoc"><p>Data is processed according to above </p>
</td></tr>
</table>

</div>
</div>
<a id="gaac6a03c2e1d76f53e1d9d923dcdc24f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac6a03c2e1d76f53e1d9d923dcdc24f2">&#9670;&nbsp;</a></span>UART_Echo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__DRV__UART__API__MODULE.html#gaac6a03c2e1d76f53e1d9d923dcdc24f2">UART_Echo</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART echo settings. </p>
<p>This enumeration defines if the driver will echo data when uses in UART_DATA_TEXT mode. This only applies to data received by the UART.</p>
<p>UART_ECHO_ON will echo back characters it received while in UART_DATA_TEXT mode. UART_ECHO_OFF will not echo back characters it received in UART_DATA_TEXT mode.</p>
<dl class="section pre"><dt>Precondition</dt><dd>UART driver must be used in UART_DATA_TEXT mode. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaac6a03c2e1d76f53e1d9d923dcdc24f2a2b286f182793d4a71bdf99409b9600dd"></a>UART_ECHO_OFF&#160;</td><td class="fielddoc"><p>Data is not echoed </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaac6a03c2e1d76f53e1d9d923dcdc24f2a6c4d8a2d4e30c22cf9fa45cd1bf79306"></a>UART_ECHO_ON&#160;</td><td class="fielddoc"><p>Data is echoed </p>
</td></tr>
</table>

</div>
</div>
<a id="gadf245d5f10db0abcbd8ad62a0d80c694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf245d5f10db0abcbd8ad62a0d80c694">&#9670;&nbsp;</a></span>UART_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__DRV__UART__API__MODULE.html#gadf245d5f10db0abcbd8ad62a0d80c694">UART_LEN</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART data length settings. </p>
<p>This enumeration defines the UART data lengths. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggadf245d5f10db0abcbd8ad62a0d80c694a27d04dd1fa818f764eb9b8e849feb7ff"></a>UART_LEN_5&#160;</td><td class="fielddoc"><p>Data length is 5 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadf245d5f10db0abcbd8ad62a0d80c694a5bfd5507335d394d826e560930ce2a12"></a>UART_LEN_6&#160;</td><td class="fielddoc"><p>Data length is 6 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadf245d5f10db0abcbd8ad62a0d80c694a2ac8467047f55cc1954388bf94c72e35"></a>UART_LEN_7&#160;</td><td class="fielddoc"><p>Data length is 7 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadf245d5f10db0abcbd8ad62a0d80c694a31abbaaeaa38a5c66fbe13bfc8ece221"></a>UART_LEN_8&#160;</td><td class="fielddoc"><p>Data length is 8 </p>
</td></tr>
</table>

</div>
</div>
<a id="ga176b71ca19bc13d7534fa30fc18c2243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga176b71ca19bc13d7534fa30fc18c2243">&#9670;&nbsp;</a></span>UART_STOP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__DRV__UART__API__MODULE.html#ga176b71ca19bc13d7534fa30fc18c2243">UART_STOP</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART stop bit settings. </p>
<p>This enumeration defines the UART stop bits. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga176b71ca19bc13d7534fa30fc18c2243a9bfa599e95c5da9cfe5f964dab8a9c6c"></a>UART_STOP_ONE&#160;</td><td class="fielddoc"><p>One stop bit </p>
</td></tr>
<tr><td class="fieldname"><a id="gga176b71ca19bc13d7534fa30fc18c2243a3f41137f3775e7d33fdb250471c0248e"></a>UART_STOP_TWO&#160;</td><td class="fielddoc"><p>Two stop bits </p>
</td></tr>
</table>

</div>
</div>
<a id="gac70b5aa75500b8c45a51ec560deccfc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac70b5aa75500b8c45a51ec560deccfc4">&#9670;&nbsp;</a></span>UART_PAR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__DRV__UART__API__MODULE.html#gac70b5aa75500b8c45a51ec560deccfc4">UART_PAR</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART parity type settings. </p>
<p>This enumeration defines the UART parity types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggac70b5aa75500b8c45a51ec560deccfc4a469955a283c95f261990ad07043d5d2d"></a>UART_PAR_NONE&#160;</td><td class="fielddoc"><p>No parity </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac70b5aa75500b8c45a51ec560deccfc4a5405c8d842bffa2f76999eef9cee32c3"></a>UART_PAR_EVEN&#160;</td><td class="fielddoc"><p>Parity bit is even </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac70b5aa75500b8c45a51ec560deccfc4a498f72ae68542763da3072d3e3af6603"></a>UART_PAR_ODD&#160;</td><td class="fielddoc"><p>Parity bit is odd </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac70b5aa75500b8c45a51ec560deccfc4adfb9d17fa33753ea5550e757b323bd46"></a>UART_PAR_ZERO&#160;</td><td class="fielddoc"><p>Parity bit is always zero </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac70b5aa75500b8c45a51ec560deccfc4a7ab50a9a14f4c614e875fbab74911afa"></a>UART_PAR_ONE&#160;</td><td class="fielddoc"><p>Parity bit is always one </p>
</td></tr>
</table>

</div>
</div>
<a id="ga6f9ece6c74cd7dd5b7569c54d5093794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f9ece6c74cd7dd5b7569c54d5093794">&#9670;&nbsp;</a></span>UART_FC_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__DRV__UART__API__MODULE.html#ga6f9ece6c74cd7dd5b7569c54d5093794">UART_FC_TYPE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART flow control settings. </p>
<p>This enumeration defines the UART parity types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga6f9ece6c74cd7dd5b7569c54d5093794a527864f0ec595151e7db5ef909fcf9f0"></a>UART_FC_NONE&#160;</td><td class="fielddoc"><p>No flow control </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6f9ece6c74cd7dd5b7569c54d5093794a98438b1cb72a9c48037258fa2f2d54f8"></a>UART_FC_HW&#160;</td><td class="fielddoc"><p>Hardware flow control </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga74da6620ba02549caeffff1ba1a12878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74da6620ba02549caeffff1ba1a12878">&#9670;&nbsp;</a></span>UART_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>uartHnd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to closes a given UART peripheral specified by the UART handle. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="group__DRV__UART__API__MODULE.html#ga49e4b22cd81c9435577ea35ead0c6a38" title="Function to initialize a given UART peripheral specified by the particular index value....">UART_open()</a> had to be called first.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uartHnd</td><td>A UART_Handle returned from UART_open</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__DRV__UART__API__MODULE.html#ga49e4b22cd81c9435577ea35ead0c6a38" title="Function to initialize a given UART peripheral specified by the particular index value....">UART_open</a> </dd></dl>

</div>
</div>
<a id="gafff81a6e76deb098c5d3ebfcd758472b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafff81a6e76deb098c5d3ebfcd758472b">&#9670;&nbsp;</a></span>UART_control()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t UART_control </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>uartHnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function performs implementation specific features on a given UART_Handle. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="group__DRV__UART__API__MODULE.html#ga49e4b22cd81c9435577ea35ead0c6a38" title="Function to initialize a given UART peripheral specified by the particular index value....">UART_open()</a> has to be called first.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uartHnd</td><td>A UART handle returned from <a class="el" href="group__DRV__UART__API__MODULE.html#ga49e4b22cd81c9435577ea35ead0c6a38" title="Function to initialize a given UART peripheral specified by the particular index value....">UART_open()</a></td></tr>
    <tr><td class="paramname">cmd</td><td>A command value defined by the driver specific implementation</td></tr>
    <tr><td class="paramname">arg</td><td>An optional argument that is accompanied with cmd</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Implementation specific return codes. Negative values indicate unsuccessful operations.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__DRV__UART__API__MODULE.html#ga49e4b22cd81c9435577ea35ead0c6a38" title="Function to initialize a given UART peripheral specified by the particular index value....">UART_open()</a> </dd></dl>

</div>
</div>
<a id="gab60a36f7295d704926120d22f806dcd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab60a36f7295d704926120d22f806dcd1">&#9670;&nbsp;</a></span>UART_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to initializes the UART module. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The UART controller needs to be powered up and clocked. The UART_config structure must exist and be persistent before this function can be called. This function must also be called before any other UART driver APIs. </dd></dl>

</div>
</div>
<a id="ga49e4b22cd81c9435577ea35ead0c6a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49e4b22cd81c9435577ea35ead0c6a38">&#9670;&nbsp;</a></span>UART_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> UART_open </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structUART__Params.html">UART_Params</a> *&#160;</td>
          <td class="paramname"><em>uartParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to initialize a given UART peripheral specified by the particular index value. The parameter specifies which mode the UART will operate. </p>
<dl class="section pre"><dt>Precondition</dt><dd>UART controller has been initialized</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>Logical peripheral number indexed into the HWAttrs table</td></tr>
    <tr><td class="paramname">uartParams</td><td>Pointer to an parameter block, if NULL it will use default values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A UART_Handle on success or a NULL on an error or if it has been already opened</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__DRV__UART__API__MODULE.html#ga74da6620ba02549caeffff1ba1a12878" title="Function to closes a given UART peripheral specified by the UART handle.">UART_close</a> </dd></dl>

</div>
</div>
<a id="ga433972fdc2d8d45d2ecef607a61e4cff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga433972fdc2d8d45d2ecef607a61e4cff">&#9670;&nbsp;</a></span>UART_Params_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART_Params_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUART__Params.html">UART_Params</a> *&#160;</td>
          <td class="paramname"><em>uartParams</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to initialize the <a class="el" href="structUART__Params.html" title="Basic UART Parameters.">UART_Params</a> struct to its defaults. </p>
<p>Defaults values are: readMode = UART_MODE_BLOCKING; writeMode = UART_MODE_BLOCKING; readTimeout = BIOS_WAIT_FOREVER; writeTimeout = BIOS_WAIT_FOREVER; readCallback = NULL; writeCallback = NULL; readReturnMode = UART_RETURN_NEWLINE; writeDataMode = UART_DATA_TEXT; readDataMode = UART_DATA_TEXT; readEcho = UART_ECHO_ON; baudRate = 115200; stopBits = UART_STOP_ONE; parityType = UART_PAR_NONE;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uartParams</td><td>Parameter structure to initialize </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadb9e485ab29323a7df04c922dfc4c5fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb9e485ab29323a7df04c922dfc4c5fe">&#9670;&nbsp;</a></span>UART_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t UART_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>uartHnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that writes data to a UART. </p>
<p>This function initiates an operation to write data to a UART controller.</p>
<p>In UART_MODE_BLOCKING, UART_write will block task execution until all the data in buffer has been written.</p>
<p>In UART_MODE_CALLBACK, UART_write does not block task execution an calls a callback function specified by writeCallback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uartHnd</td><td>A UART_Handle</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to buffer containing data to be written</td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes in buffer that should be written onto the UART.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes that have been written to the UART, UART_ERROR on an error. </dd></dl>

</div>
</div>
<a id="gaea4c4bb14ae6ef5c66cbdac5a4f5c221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea4c4bb14ae6ef5c66cbdac5a4f5c221">&#9670;&nbsp;</a></span>UART_writePolling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t UART_writePolling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>uartHnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that writes data to a UART. </p>
<p>This function initiates an operation to write data to a UART controller.</p>
<p>UART_write will not return until all the data was written to the UART.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uartHnd</td><td>A UART_Handle</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to buffer containing data to be written</td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes in buffer that should be written onto the UART.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes that have been written to the UART, UART_ERROR on an error. </dd></dl>

</div>
</div>
<a id="ga0482cd0ab9ee7e802c8e785a5754d16d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0482cd0ab9ee7e802c8e785a5754d16d">&#9670;&nbsp;</a></span>UART_writeCancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART_writeCancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that cancels a UART_write function call. </p>
<p>This function cancels an operation to write data to a UART controller when in UART_MODE_CALLBACK.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A UART_Handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8e5f16eaf4eff8add9e52911ab4b5df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e5f16eaf4eff8add9e52911ab4b5df5">&#9670;&nbsp;</a></span>UART_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t UART_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that read data from a UART. </p>
<p>This function initiates an operation to read data from a UART controller.</p>
<p>In UART_MODE_BLOCKING, UART_read will block task execution until all the data in buffer has been read.</p>
<p>In UART_MODE_CALLBACK, UART_read does not block task execution an calls a callback function specified by readCallback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A UART_Handle</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to an empty buffer in which data should be written to</td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes to be written into buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes that have been read from the UART, UART_ERROR on an error. </dd></dl>

</div>
</div>
<a id="gaffab6273a151a89a8b4c3c2fc0846d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffab6273a151a89a8b4c3c2fc0846d0c">&#9670;&nbsp;</a></span>UART_readPolling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t UART_readPolling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that reads data from a UART. </p>
<p>This function initiates an operation to read data from a UART controller.</p>
<p>UART_readPolling will not return until size data was read to the UART.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A UART_Handle</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to an empty buffer in which data should be written to</td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes to be written into buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes that have been read from the UART, UART_ERROR on an error. </dd></dl>

</div>
</div>
<a id="ga51ed7e94d5b409ca1fcb2d65c5a25c3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51ed7e94d5b409ca1fcb2d65c5a25c3c">&#9670;&nbsp;</a></span>UART_readCancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART_readCancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that cancels a UART_read function call. </p>
<p>This function cancels an operation to read data from a UART controller when in UART_MODE_CALLBACK.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A UART_Handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga59997fcf8ebb14c34797717d9dde8d6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59997fcf8ebb14c34797717d9dde8d6e">&#9670;&nbsp;</a></span>UART_read2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t UART_read2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structUART__Transaction.html">UART_Transaction</a> *&#160;</td>
          <td class="paramname"><em>uartTrans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extended function that read data from a UART. </p>
<p>This function initiates an operation to read data from a UART controller.</p>
<p>In UART_MODE_BLOCKING, UART_read2 will block task execution until all the data in buffer has been read.</p>
<p>In UART_MODE_CALLBACK, UART_read2 does not block task execution an calls a callback function specified by readCallback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A UART_Handle</td></tr>
    <tr><td class="paramname">uartTrans</td><td>A pointer to a <a class="el" href="structUART__Transaction.html" title="A UART_Transaction data structure is used with UART_read2(), UART_write2() and UART_Callback2()">UART_Transaction</a>. All of the fields within transaction except <a class="el" href="structUART__Transaction.html#a32842a6d05bd3dc31d31a8502da5e190">UART_Transaction.count</a> and <a class="el" href="structUART__Transaction.html#a28a9bcc2fc5a31ca76306ef0a3547dff">UART_Transaction.status</a> are WO (write-only) unless otherwise noted in the driver implementations. If a transaction timeout or error has occured, <a class="el" href="structUART__Transaction.html#a32842a6d05bd3dc31d31a8502da5e190">UART_Transaction.count</a> will contain the number of bytes that were transferred. In the callback mode, the application allocates transaction memory and UART driver owns the pointer unitil it is returned to the application via the callback function, thus the memory should not be allocated on the stack, and dynamic free must occur in the callback (not immediately after calling read2/write2)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns UART_SUCCESS or UART_ERROR on an error. </dd></dl>

</div>
</div>
<a id="ga6fc38efd825942b5a43e937411aab890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fc38efd825942b5a43e937411aab890">&#9670;&nbsp;</a></span>UART_write2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t UART_write2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DRV__UART__API__MODULE.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structUART__Transaction.html">UART_Transaction</a> *&#160;</td>
          <td class="paramname"><em>uartTrans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extended function that writes data to a UART. </p>
<p>This function initiates an operation to write data to a UART controller.</p>
<p>In UART_MODE_BLOCKING, UART_write will block task execution until all the data in buffer has been written.</p>
<p>In UART_MODE_CALLBACK, UART_write does not block task execution an calls a callback function specified by writeCallback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A UART_Handle</td></tr>
    <tr><td class="paramname">uartTrans</td><td>A pointer to a <a class="el" href="structUART__Transaction.html" title="A UART_Transaction data structure is used with UART_read2(), UART_write2() and UART_Callback2()">UART_Transaction</a>. All of the fields within transaction except <a class="el" href="structUART__Transaction.html#a32842a6d05bd3dc31d31a8502da5e190">UART_Transaction.count</a> and <a class="el" href="structUART__Transaction.html#a28a9bcc2fc5a31ca76306ef0a3547dff">UART_Transaction.status</a> are WO (write-only) unless otherwise noted in the driver implementations. If a transaction timeout or error has occured, <a class="el" href="structUART__Transaction.html#a32842a6d05bd3dc31d31a8502da5e190">UART_Transaction.count</a> will contain the number of bytes that were transferred. In the callback mode, the application allocates transaction memory and UART driver owns the pointer unitil it is returned to the application via the callback function, thus the memory should not be allocated on the stack, and dynamic free must occur in the callback (not immediately after calling read2/write2)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns UART_SUCCESS or UART_ERROR on an error. </dd></dl>

</div>
</div>
<a id="gaca30376be73cc071bfb8759a8a23e9b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca30376be73cc071bfb8759a8a23e9b8">&#9670;&nbsp;</a></span>UART_transactionInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART_transactionInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUART__Transaction.html">UART_Transaction</a> *&#160;</td>
          <td class="paramname"><em>uartTrans</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to initialize the <a class="el" href="structUART__Transaction.html" title="A UART_Transaction data structure is used with UART_read2(), UART_write2() and UART_Callback2()">UART_Transaction</a> struct to its defaults. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uartTrans</td><td>A pointer to a <a class="el" href="structUART__Transaction.html" title="A UART_Transaction data structure is used with UART_read2(), UART_write2() and UART_Callback2()">UART_Transaction</a> to be initialized.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uartTrans initialized with default values such as: uartTrans-&gt;buf = NULL; uartTrans-&gt;timeout = UART_WAIT_FOREVER; uartTrans-&gt;count = 0; uartTrans-&gt;status = UART_TRANSFER_STATUS_SUCCESS; </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
