<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<title>PDK API Guide for J721S2: CPGMAC_SL Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ti_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PDK API Guide for J721S2
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__CSL__CPGMAC__SL__FUNCTION.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">CPGMAC_SL Functions<div class="ingroups"><a class="el" href="group__CSL__IP__MODULE.html">CSL-FL</a> &raquo; <a class="el" href="group__CSL__CPSWITCH.html">CPSW CSL-FL</a> &raquo; <a class="el" href="group__CSL__CPGMAC__SL__API.html">GMAC Sliver submodule (CPGMAC_SL)</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Introduction</h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8ea49daa25388e28c0598107bb95b102"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga8ea49daa25388e28c0598107bb95b102">CSL_CPGMAC_SL_isFullDuplexEnabled</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga8ea49daa25388e28c0598107bb95b102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab31bf8d4116de555e2e4b3190bcd386a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#gab31bf8d4116de555e2e4b3190bcd386a">CSL_CPGMAC_SL_enableFullDuplex</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:gab31bf8d4116de555e2e4b3190bcd386a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85ecaedf141401f9168d7fdd39eda1bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga85ecaedf141401f9168d7fdd39eda1bb">CSL_CPGMAC_SL_disableFullDuplex</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga85ecaedf141401f9168d7fdd39eda1bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafae0f414e0f5ae6093c7290d11e56565"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#gafae0f414e0f5ae6093c7290d11e56565">CSL_CPGMAC_SL_isLoopbackModeEnabled</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:gafae0f414e0f5ae6093c7290d11e56565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53efff6cc4b7a998b57f87a7c3297831"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga53efff6cc4b7a998b57f87a7c3297831">CSL_CPGMAC_SL_enableLoopback</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga53efff6cc4b7a998b57f87a7c3297831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a785d0554a6cbe8377b0f41c497df46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga2a785d0554a6cbe8377b0f41c497df46">CSL_CPGMAC_SL_disableLoopback</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga2a785d0554a6cbe8377b0f41c497df46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga365d6450e74d706308eb13bb7e79f68f"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga365d6450e74d706308eb13bb7e79f68f">CSL_CPGMAC_SL_isRxFlowControlEnabled</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga365d6450e74d706308eb13bb7e79f68f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92b32354bdeacda45dd0b36ec840184b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga92b32354bdeacda45dd0b36ec840184b">CSL_CPGMAC_SL_enableRxFlowControl</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga92b32354bdeacda45dd0b36ec840184b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8743d6bfe1f411955f7c257d13bb763e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga8743d6bfe1f411955f7c257d13bb763e">CSL_CPGMAC_SL_disableRxFlowControl</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga8743d6bfe1f411955f7c257d13bb763e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga427ad754436b9e77f8753ce35ebefa4a"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga427ad754436b9e77f8753ce35ebefa4a">CSL_CPGMAC_SL_isTxFlowControlEnabled</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga427ad754436b9e77f8753ce35ebefa4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95b3d5b96c506d615d9e096bc88eb19c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga95b3d5b96c506d615d9e096bc88eb19c">CSL_CPGMAC_SL_enableTxFlowControl</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga95b3d5b96c506d615d9e096bc88eb19c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5b46849a4f36fadafdbfeaeb6aef70f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#gac5b46849a4f36fadafdbfeaeb6aef70f">CSL_CPGMAC_SL_disableTxFlowControl</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:gac5b46849a4f36fadafdbfeaeb6aef70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49765b974d7010958019608afaae1366"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga49765b974d7010958019608afaae1366">CSL_CPGMAC_SL_isGMIIEnabled</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga49765b974d7010958019608afaae1366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8481e0917e019d0aef65c2e07bf3f055"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga8481e0917e019d0aef65c2e07bf3f055">CSL_CPGMAC_SL_enableGMII</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga8481e0917e019d0aef65c2e07bf3f055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35492bbd35ae89205059614ad4558ca7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga35492bbd35ae89205059614ad4558ca7">CSL_CPGMAC_SL_disableGMII</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga35492bbd35ae89205059614ad4558ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27c1440368e08f1af5800555808ba1e3"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga27c1440368e08f1af5800555808ba1e3">CSL_CPGMAC_SL_isTxPaceEnabled</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga27c1440368e08f1af5800555808ba1e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5aad9dbd94a9ba5df37186a65dd90817"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga5aad9dbd94a9ba5df37186a65dd90817">CSL_CPGMAC_SL_enableTxPace</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga5aad9dbd94a9ba5df37186a65dd90817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga603fe20a587793dff783a5fac342f895"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga603fe20a587793dff783a5fac342f895">CSL_CPGMAC_SL_disableTxPace</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga603fe20a587793dff783a5fac342f895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf05899926eb669dbdd0c555a0b461aa6"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#gaf05899926eb669dbdd0c555a0b461aa6">CSL_CPGMAC_SL_isGigabitEnabled</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:gaf05899926eb669dbdd0c555a0b461aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b1754fa021a7d716ae86402581be518"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga6b1754fa021a7d716ae86402581be518">CSL_CPGMAC_SL_enableGigabit</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga6b1754fa021a7d716ae86402581be518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac878070f61de3251e7cc2ade3767ae0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#gac878070f61de3251e7cc2ade3767ae0e">CSL_CPGMAC_SL_disableGigabit</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:gac878070f61de3251e7cc2ade3767ae0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ba1c1609e9beca7c50ffd918cb4bc5c"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga7ba1c1609e9beca7c50ffd918cb4bc5c">CSL_CPGMAC_SL_isTxShortGapEnabled</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga7ba1c1609e9beca7c50ffd918cb4bc5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad469a8441c07e2a6a55543c2da320f5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#gad469a8441c07e2a6a55543c2da320f5b">CSL_CPGMAC_SL_enableTxShortGap</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:gad469a8441c07e2a6a55543c2da320f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93b9b2549d54e913bec629fc8ff60c0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga93b9b2549d54e913bec629fc8ff60c0a">CSL_CPGMAC_SL_disableTxShortGap</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga93b9b2549d54e913bec629fc8ff60c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga692e4ce6272b14d967a8c9785f1c5e7e"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga692e4ce6272b14d967a8c9785f1c5e7e">CSL_CPGMAC_SL_isIdleModeEnabled</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga692e4ce6272b14d967a8c9785f1c5e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga953665afe2675373921437e53b1ada38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga953665afe2675373921437e53b1ada38">CSL_CPGMAC_SL_enableIdleMode</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga953665afe2675373921437e53b1ada38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ab6f2b3814003fc69257314c5a6cff5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga1ab6f2b3814003fc69257314c5a6cff5">CSL_CPGMAC_SL_disableIdleMode</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga1ab6f2b3814003fc69257314c5a6cff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga705fb825bb761953b6aa402304837171"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga705fb825bb761953b6aa402304837171">CSL_CPGMAC_SL_isCastagnoliCRCEnabled</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga705fb825bb761953b6aa402304837171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f330d0b4ba55a45f80da8217f77cc19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga5f330d0b4ba55a45f80da8217f77cc19">CSL_CPGMAC_SL_enableCastagnoliCRC</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga5f330d0b4ba55a45f80da8217f77cc19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab55b8230f5adfe6d2d4faa4711362d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#gaab55b8230f5adfe6d2d4faa4711362d0">CSL_CPGMAC_SL_disableCastagnoliCRC</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:gaab55b8230f5adfe6d2d4faa4711362d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad137e89206f7619b4a09696a6a89016c"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#gad137e89206f7619b4a09696a6a89016c">CSL_CPGMAC_SL_isIFCTLAEnabled</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:gad137e89206f7619b4a09696a6a89016c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf69dddba8973402a8f9c8dc5d41bf7d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#gaf69dddba8973402a8f9c8dc5d41bf7d8">CSL_CPGMAC_SL_enableIFCTLA</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:gaf69dddba8973402a8f9c8dc5d41bf7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6bbd08f896a2cfb021eedef6bda4406"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#gad6bbd08f896a2cfb021eedef6bda4406">CSL_CPGMAC_SL_disableIFCTLA</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:gad6bbd08f896a2cfb021eedef6bda4406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fb58ea84bed50a702e6e9532a8531ec"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga1fb58ea84bed50a702e6e9532a8531ec">CSL_CPGMAC_SL_isIFCTLBEnabled</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga1fb58ea84bed50a702e6e9532a8531ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga915cf80458934d9cb4ef4b5dc8ac39ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga915cf80458934d9cb4ef4b5dc8ac39ee">CSL_CPGMAC_SL_enableIFCTLB</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga915cf80458934d9cb4ef4b5dc8ac39ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04856f7efa944ccabb0ac3d41e768792"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga04856f7efa944ccabb0ac3d41e768792">CSL_CPGMAC_SL_disableIFCTLB</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga04856f7efa944ccabb0ac3d41e768792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e045d4440ee7cd471aba5264bc3b973"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga6e045d4440ee7cd471aba5264bc3b973">CSL_CPGMAC_SL_isGigForceModeEnabled</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga6e045d4440ee7cd471aba5264bc3b973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92ef6199cf2eb7692af5a820ab120690"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga92ef6199cf2eb7692af5a820ab120690">CSL_CPGMAC_SL_enableGigForceMode</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga92ef6199cf2eb7692af5a820ab120690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae77d4fa36501f3043697d236591df173"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#gae77d4fa36501f3043697d236591df173">CSL_CPGMAC_SL_disableGigForceMode</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:gae77d4fa36501f3043697d236591df173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga131c8e8b601ca850c05c830db77ebae9"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga131c8e8b601ca850c05c830db77ebae9">CSL_CPGMAC_SL_isExtControlEnabled</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga131c8e8b601ca850c05c830db77ebae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d1f10949e3fb034db3806b2212eab86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga6d1f10949e3fb034db3806b2212eab86">CSL_CPGMAC_SL_enableExtControl</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga6d1f10949e3fb034db3806b2212eab86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2253308a3a91804ea9013c356630d5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#gaa2253308a3a91804ea9013c356630d5b">CSL_CPGMAC_SL_disableExtControl</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:gaa2253308a3a91804ea9013c356630d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7eaaabe6b99b2b350f0b926579e0dac7"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga7eaaabe6b99b2b350f0b926579e0dac7">CSL_CPGMAC_SL_isExtRxFlowEnabled</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga7eaaabe6b99b2b350f0b926579e0dac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5557bcd4b505c520a550fb0b43dae6d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga5557bcd4b505c520a550fb0b43dae6d6">CSL_CPGMAC_SL_enableExtRxFlow</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga5557bcd4b505c520a550fb0b43dae6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b1d5331da80cb09a73b4e72ce1afc70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga6b1d5331da80cb09a73b4e72ce1afc70">CSL_CPGMAC_SL_disableExtRxFlow</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga6b1d5331da80cb09a73b4e72ce1afc70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c358d5783c05cecbd5b67a36d4790e0"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga9c358d5783c05cecbd5b67a36d4790e0">CSL_CPGMAC_SL_isExtTxFlowEnabled</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga9c358d5783c05cecbd5b67a36d4790e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c1f3b6383c7416fe8cbbd8486885a8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga4c1f3b6383c7416fe8cbbd8486885a8b">CSL_CPGMAC_SL_enableExtTxFlow</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga4c1f3b6383c7416fe8cbbd8486885a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2ed5c52ce43b3d80d3b48a9aa994d69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#gaf2ed5c52ce43b3d80d3b48a9aa994d69">CSL_CPGMAC_SL_disableExtTxFlow</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:gaf2ed5c52ce43b3d80d3b48a9aa994d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4daeb9593fe094537be68c2949412a23"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga4daeb9593fe094537be68c2949412a23">CSL_CPGMAC_SL_isRxCEFEnabled</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga4daeb9593fe094537be68c2949412a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a26a65291c4912b90b820292b06a921"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga8a26a65291c4912b90b820292b06a921">CSL_CPGMAC_SL_enableRxCEF</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga8a26a65291c4912b90b820292b06a921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22a6ba863a14a50e98dc05ae5e2ce547"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga22a6ba863a14a50e98dc05ae5e2ce547">CSL_CPGMAC_SL_disableRxCEF</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga22a6ba863a14a50e98dc05ae5e2ce547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c97646ceef4fe2f8946f6f8b620763f"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga3c97646ceef4fe2f8946f6f8b620763f">CSL_CPGMAC_SL_isRxCSFEnabled</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga3c97646ceef4fe2f8946f6f8b620763f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53b724c510599d16384a98c2c35a3012"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga53b724c510599d16384a98c2c35a3012">CSL_CPGMAC_SL_enableRxCSF</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga53b724c510599d16384a98c2c35a3012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1980b747cf5582fa1f60d0b9106c481e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga1980b747cf5582fa1f60d0b9106c481e">CSL_CPGMAC_SL_disableRxCSF</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga1980b747cf5582fa1f60d0b9106c481e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb9485d726fa836ee0591265a102877d"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#gacb9485d726fa836ee0591265a102877d">CSL_CPGMAC_SL_isRxCMFEnabled</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:gacb9485d726fa836ee0591265a102877d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ab0f3c4ea98aa6007ae64531dd96697"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga8ab0f3c4ea98aa6007ae64531dd96697">CSL_CPGMAC_SL_enableRxCMF</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga8ab0f3c4ea98aa6007ae64531dd96697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58d348404659fd41442449cf638092b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga58d348404659fd41442449cf638092b2">CSL_CPGMAC_SL_disableRxCMF</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga58d348404659fd41442449cf638092b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03b778c33b07c635a15e380102af2d3b"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga03b778c33b07c635a15e380102af2d3b">CSL_CPGMAC_SL_getMacControlReg</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga03b778c33b07c635a15e380102af2d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga913232a8dadc8c4536f0fc356624c514"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga913232a8dadc8c4536f0fc356624c514">CSL_CPGMAC_SL_setMacControlReg</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum, Uint32 macControlRegVal)</td></tr>
<tr class="separator:ga913232a8dadc8c4536f0fc356624c514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dae0c863cb55937272dbd2e6bc0acf3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga3dae0c863cb55937272dbd2e6bc0acf3">CSL_CPGMAC_SL_getMacStatusReg</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum, <a class="el" href="structCSL__CPGMAC__SL__MACSTATUS.html">CSL_CPGMAC_SL_MACSTATUS</a> *pMacStatus)</td></tr>
<tr class="separator:ga3dae0c863cb55937272dbd2e6bc0acf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97904ba5021c044523b2d5016f89bf6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga97904ba5021c044523b2d5016f89bf6a">CSL_CPGMAC_SL_resetMac</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga97904ba5021c044523b2d5016f89bf6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga719fb81543246f395292ba28fa6af766"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga719fb81543246f395292ba28fa6af766">CSL_CPGMAC_SL_isMACResetDone</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga719fb81543246f395292ba28fa6af766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga778c15ec8773b66b2391e290607db771"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga778c15ec8773b66b2391e290607db771">CSL_CPGMAC_SL_getRxMaxLen</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga778c15ec8773b66b2391e290607db771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe907be65c88dafc27bda3326449e1a2"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#gafe907be65c88dafc27bda3326449e1a2">CSL_CPGMAC_SL_setRxMaxLen</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum, Uint32 rxMaxLen)</td></tr>
<tr class="separator:gafe907be65c88dafc27bda3326449e1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad282d147867d681de380db243fc5dcc1"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#gad282d147867d681de380db243fc5dcc1">CSL_CPGMAC_SL_getTxGap</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:gad282d147867d681de380db243fc5dcc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07cf1375e2ed7f65e830aadaf3c131f0"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga07cf1375e2ed7f65e830aadaf3c131f0">CSL_CPGMAC_SL_setTxGap</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum, Uint32 txGap)</td></tr>
<tr class="separator:ga07cf1375e2ed7f65e830aadaf3c131f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e053774d0c642bcc7cb471223f3525b"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga0e053774d0c642bcc7cb471223f3525b">CSL_CPGMAC_SL_getRxPauseTimerReg</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga0e053774d0c642bcc7cb471223f3525b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2dbbd3a3d50808d4555e2711b5ce0be"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#gae2dbbd3a3d50808d4555e2711b5ce0be">CSL_CPGMAC_SL_setRxPauseTimerReg</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum, Uint32 rxPauseTimer)</td></tr>
<tr class="separator:gae2dbbd3a3d50808d4555e2711b5ce0be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81147b37660c31cb014fd53b259c712b"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga81147b37660c31cb014fd53b259c712b">CSL_CPGMAC_SL_getTxPauseTimerReg</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga81147b37660c31cb014fd53b259c712b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabee0f08c9f9f29223e80ca4144350af4"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#gabee0f08c9f9f29223e80ca4144350af4">CSL_CPGMAC_SL_setTxPauseTimerReg</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum, Uint32 txPauseTimer)</td></tr>
<tr class="separator:gabee0f08c9f9f29223e80ca4144350af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b5504a47381b2b1298505ce9a02f4bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga6b5504a47381b2b1298505ce9a02f4bd">CSL_CPGMAC_SL_getEmulControlReg</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum, Uint32 *pEmulFreeBit, Uint32 *pEmulSoftBit)</td></tr>
<tr class="separator:ga6b5504a47381b2b1298505ce9a02f4bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4741ae8b9e77739d24e289bc7feba552"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga4741ae8b9e77739d24e289bc7feba552">CSL_CPGMAC_SL_setEmulControlReg</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum, Uint32 emulFreeBit, Uint32 emulSoftBit)</td></tr>
<tr class="separator:ga4741ae8b9e77739d24e289bc7feba552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdbc366abcdda3f1af28906306460a7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#gabdbc366abcdda3f1af28906306460a7c">CSL_CPGMAC_SL_getMacRxPriMapReg</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum, Uint32 *pMacRxPriMap)</td></tr>
<tr class="separator:gabdbc366abcdda3f1af28906306460a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74088fdca82faa25c5d9b8a7120167b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga74088fdca82faa25c5d9b8a7120167b4">CSL_CPGMAC_SL_setMacRxPriMapReg</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum, Uint32 *pMacRxPriMap)</td></tr>
<tr class="separator:ga74088fdca82faa25c5d9b8a7120167b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga058d3597c74a511c0878d33a3991d38f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga058d3597c74a511c0878d33a3991d38f">CSL_CPGMAC_SL_clearMacStatusTorf</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga058d3597c74a511c0878d33a3991d38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0aea842c50365007d7de73402d4aee25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga0aea842c50365007d7de73402d4aee25">CSL_CPGMAC_SL_clearMacStatusTorfPri</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga0aea842c50365007d7de73402d4aee25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga210266957e45312e68db830eadab8330"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga210266957e45312e68db830eadab8330">CSL_CPGMAC_SL_getInterVLANCfg</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum, Uint32 routeIndex, <a class="el" href="structCSL__CPSW__INTERVLANCFG.html">CSL_CPSW_INTERVLANCFG</a> *pInterVLANCfg)</td></tr>
<tr class="separator:ga210266957e45312e68db830eadab8330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab961138093deeb4e46e703e96c8dd18f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#gab961138093deeb4e46e703e96c8dd18f">CSL_CPGMAC_SL_setInterVLANCfg</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum, Uint32 routeIndex, <a class="el" href="structCSL__CPSW__INTERVLANCFG.html">CSL_CPSW_INTERVLANCFG</a> *pInterVLANCfg)</td></tr>
<tr class="separator:gab961138093deeb4e46e703e96c8dd18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85900972abad2459b4c21ec6c5aef986"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga85900972abad2459b4c21ec6c5aef986">CSL_CPGMAC_SL_getFifoStatus</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum, <a class="el" href="structCSL__CPGMAC__SL__FIFOSTATUS.html">CSL_CPGMAC_SL_FIFOSTATUS</a> *pFifoStatus)</td></tr>
<tr class="separator:ga85900972abad2459b4c21ec6c5aef986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f67490688fb03d3a07a2ec25db353b6"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga3f67490688fb03d3a07a2ec25db353b6">CSL_CPGMAC_SL_isTxShortGapLimitEnabled</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga3f67490688fb03d3a07a2ec25db353b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6abc7d40ae3950162281fa51f149b868"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga6abc7d40ae3950162281fa51f149b868">CSL_CPGMAC_SL_enableTxShortGapLimit</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga6abc7d40ae3950162281fa51f149b868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10a58ea6855f79c8e7a411b41d23ad3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPGMAC__SL__FUNCTION.html#ga10a58ea6855f79c8e7a411b41d23ad3b">CSL_CPGMAC_SL_disableTxShortGapLimit</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga10a58ea6855f79c8e7a411b41d23ad3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga8ea49daa25388e28c0598107bb95b102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ea49daa25388e28c0598107bb95b102">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_isFullDuplexEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPGMAC_SL_isFullDuplexEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_isFullDuplexEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if Full duplex mode is enabled in the MAC control register for the MAC port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the API must retrieve the
                               settings.
*    </pre><p><b> Return Value </b> <br />
 TRUE Full duplex mode enabled <br />
 FALSE Half duplex mode enabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_FULLDUPLEX</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32 portNum;

       portNum =   1;
       if (CSL_CPGMAC_SL_isFullDuplexEnabled (portNum) == TRUE)
       {
           // full duplex mode enabled
       }
       else
       {
           // full duplex mode disabled
       }</pre> <hr/>
 
</div>
</div>
<a id="gab31bf8d4116de555e2e4b3190bcd386a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab31bf8d4116de555e2e4b3190bcd386a">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_enableFullDuplex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_enableFullDuplex </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_enableFullDuplex</b> </p>
<p><b>Description</b> <br />
 This function configures the MAC control register to enable full duplex mode for the MAC port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which settings must be configured.
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_FULLDUPLEX=1</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      portNum =   1;

       CSL_CPGMAC_SL_enableFullDuplex (portNum);</pre> <hr/>
 
</div>
</div>
<a id="ga85ecaedf141401f9168d7fdd39eda1bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85ecaedf141401f9168d7fdd39eda1bb">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_disableFullDuplex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_disableFullDuplex </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_disableFullDuplex</b> </p>
<p><b>Description</b> <br />
 This function configures the MAC control register to disable full duplex mode for the MAC port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which settings must be configured.
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_FULLDUPLEX=0</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32  portNum = 1;

       CSL_CPGMAC_SL_disableFullDuplex (portNum);</pre> <hr/>
 
</div>
</div>
<a id="gafae0f414e0f5ae6093c7290d11e56565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafae0f414e0f5ae6093c7290d11e56565">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_isLoopbackModeEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPGMAC_SL_isLoopbackModeEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_isLoopbackModeEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if loopback mode is enabled in the MAC control register for the MAC port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the API must
                               retrieve the settings.
*    </pre><p><b> Return Value </b> <br />
 TRUE Internal full duplex lopoback mode enabled <br />
 FALSE Loopback mode disabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_LOOPBACK</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32  portNum = 1;

       if (CSL_CPGMAC_SL_isLoopbackModeEnabled (portNum) == TRUE)
       {
           // loopback mode enabled
       }
       else
       {
           // loopback mode disabled
       }</pre> <hr/>
 
</div>
</div>
<a id="ga53efff6cc4b7a998b57f87a7c3297831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53efff6cc4b7a998b57f87a7c3297831">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_enableLoopback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_enableLoopback </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_enableLoopback</b> </p>
<p><b>Description</b> <br />
 This function configures the MAC control register to enable lopback mode for the MAC port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which settings must be configured.
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_LOOPBACK=1</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32  portNum = 1;

       CSL_CPGMAC_SL_enableLoopback (portNum);</pre> <hr/>
 
</div>
</div>
<a id="ga2a785d0554a6cbe8377b0f41c497df46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a785d0554a6cbe8377b0f41c497df46">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_disableLoopback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_disableLoopback </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_disableLoopback</b> </p>
<p><b>Description</b> <br />
 This function configures the MAC control register to disable loopback mode for the MAC port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which settings must be configured.
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_LOOPBACK=0</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32  portNum =   1;

       CSL_CPGMAC_SL_disableLoopback (portNum);</pre> <hr/>
 
</div>
</div>
<a id="ga365d6450e74d706308eb13bb7e79f68f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga365d6450e74d706308eb13bb7e79f68f">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_isRxFlowControlEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPGMAC_SL_isRxFlowControlEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_isRxFlowControlEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if receive flow control is enabled in the MAC control register for the MAC port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the API must
                               retrieve the settings.
*    </pre><p><b> Return Value </b> <br />
 TRUE Receive flow control enabled <br />
 FALSE Receive flow control disabled</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_RX_FLOW_EN</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32  portNum = 1;

       if (CSL_CPGMAC_SL_isRxFlowControlEnabled (portNum) == TRUE)
       {
           // rx flow control enabled
       }
       else
       {
           // rx flow control disabled
       }</pre> <hr/>
 
</div>
</div>
<a id="ga92b32354bdeacda45dd0b36ec840184b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92b32354bdeacda45dd0b36ec840184b">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_enableRxFlowControl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_enableRxFlowControl </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_enableRxFlowControl</b> </p>
<p><b>Description</b> <br />
 This function configures the MAC control register to enable receive flow control for the MAC port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which settings must be configured.
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_RX_FLOW_EN=1</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32  portNum =   1;

       CSL_CPGMAC_SL_enableRxFlowControl (portNum);</pre> <hr/>
 
</div>
</div>
<a id="ga8743d6bfe1f411955f7c257d13bb763e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8743d6bfe1f411955f7c257d13bb763e">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_disableRxFlowControl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_disableRxFlowControl </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_disableRxFlowControl</b> </p>
<p><b>Description</b> <br />
 This function configures the MAC control register to disable Receive flow control mode for the MAC port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which settings must be configured.
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_RX_FLOW_EN=0</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32  portNum =   1;

       CSL_CPGMAC_SL_disableRxFlowControl (portNum);</pre> <hr/>
 
</div>
</div>
<a id="ga427ad754436b9e77f8753ce35ebefa4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga427ad754436b9e77f8753ce35ebefa4a">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_isTxFlowControlEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPGMAC_SL_isTxFlowControlEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_isTxFlowControlEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if transmit flow control is enabled in the MAC control register for the MAC port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the API must
                               retrieve the settings.
*    </pre><p><b> Return Value </b> <br />
 TRUE Transmit flow control enabled <br />
 FALSE Transmit flow control disabled</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_TX_FLOW_EN</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32  portNum =   1;

       if (CSL_CPGMAC_SL_isTxFlowControlEnabled (portNum) == TRUE)
       {
           // tx flow control enabled
       }
       else
       {
           // tx flow control disabled
       }</pre> <hr/>
 
</div>
</div>
<a id="ga95b3d5b96c506d615d9e096bc88eb19c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95b3d5b96c506d615d9e096bc88eb19c">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_enableTxFlowControl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_enableTxFlowControl </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_enableTxFlowControl</b> </p>
<p><b>Description</b> <br />
 This function configures the MAC control register to enable transmit flow control for the MAC port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which settings must be configured.
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_TX_FLOW_EN=1</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32  portNum =   1;

       CSL_CPGMAC_SL_enableTxFlowControl (portNum);</pre> <hr/>
 
</div>
</div>
<a id="gac5b46849a4f36fadafdbfeaeb6aef70f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5b46849a4f36fadafdbfeaeb6aef70f">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_disableTxFlowControl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_disableTxFlowControl </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_disableTxFlowControl</b> </p>
<p><b>Description</b> <br />
 This function configures the MAC control register to disable Transmit flow control for the MAC port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which settings must be configured.
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_TX_FLOW_EN=0</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32  portNum =   1;

       CSL_CPGMAC_SL_disableTxFlowControl (portNum);</pre> <hr/>
 
</div>
</div>
<a id="ga49765b974d7010958019608afaae1366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49765b974d7010958019608afaae1366">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_isGMIIEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPGMAC_SL_isGMIIEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_isGMIIEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if GMII is enabled in the MAC control register for the MAC port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the API must
                               retrieve the settings.
*    </pre><p><b> Return Value </b> <br />
 TRUE GMII enabled <br />
 FALSE GMII disabled</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_GMII_EN</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32  portNum =   1;

       if (CSL_CPGMAC_SL_isGMIIEnabled (portNum) == TRUE)
       {
           // gmii enabled
       }
       else
       {
           // gmii disabled
       }</pre> <hr/>
 
</div>
</div>
<a id="ga8481e0917e019d0aef65c2e07bf3f055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8481e0917e019d0aef65c2e07bf3f055">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_enableGMII()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_enableGMII </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_enableGMII</b> </p>
<p><b>Description</b> <br />
 This function configures the MAC control register to enable GMII for the MAC port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which settings must be configured.
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_GMII_EN=1</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32  portNum =   1;

       CSL_CPGMAC_SL_enableGMII (portNum);</pre> <hr/>
 
</div>
</div>
<a id="ga35492bbd35ae89205059614ad4558ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35492bbd35ae89205059614ad4558ca7">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_disableGMII()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_disableGMII </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_disableGMII</b> </p>
<p><b>Description</b> <br />
 This function configures the MAC control register to disable GMII for the MAC port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which settings must be configured.
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_GMII_EN=0</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32  portNum =   1;

       CSL_CPGMAC_SL_disableGMII (portNum);</pre> <hr/>
 
</div>
</div>
<a id="ga27c1440368e08f1af5800555808ba1e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27c1440368e08f1af5800555808ba1e3">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_isTxPaceEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPGMAC_SL_isTxPaceEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_isTxPaceEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if transmit pacing is enabled in the MAC control register for the MAC port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the API must
                               retrieve the settings.
*    </pre><p><b> Return Value </b> <br />
 TRUE Transmit pacing enabled <br />
 FALSE Transmit pacing disabled</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_TX_PACE</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32  portNum =   1;

       if (CSL_CPGMAC_SL_isTxPaceEnabled (portNum) == TRUE)
       {
           // tx pacing enabled
       }
       else
       {
           // tx pacing disabled
       }</pre> <hr/>
 
</div>
</div>
<a id="ga5aad9dbd94a9ba5df37186a65dd90817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5aad9dbd94a9ba5df37186a65dd90817">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_enableTxPace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_enableTxPace </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_enableTxPace</b> </p>
<p><b>Description</b> <br />
 This function configures the MAC control register to enable transmit pacing for the MAC port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which settings must be configured.
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_TX_PACE=1</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32  portNum = 1;

       CSL_CPGMAC_SL_enableTxPace (portNum);</pre> <hr/>
 
</div>
</div>
<a id="ga603fe20a587793dff783a5fac342f895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga603fe20a587793dff783a5fac342f895">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_disableTxPace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_disableTxPace </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_disableTxPace</b> </p>
<p><b>Description</b> <br />
 This function configures the MAC control register to disable transmit pacing for the MAC port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which settings must be configured.
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_TX_PACE=0</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32  portNum = 1;

       CSL_CPGMAC_SL_disableTxPace (portNum);</pre> <hr/>
 
</div>
</div>
<a id="gaf05899926eb669dbdd0c555a0b461aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf05899926eb669dbdd0c555a0b461aa6">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_isGigabitEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPGMAC_SL_isGigabitEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_isGigabitEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if Gigabit mode is enabled in the MAC control register for the MAC port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the API must
                               retrieve the settings.
*    </pre><p><b> Return Value </b> <br />
 TRUE Gigabit mode enabled <br />
 FALSE Gigabit disabled. 10/100 mode enabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_GIG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32  portNum = 1;

       if (CSL_CPGMAC_SL_isGigabitEnabled (portNum) == TRUE)
       {
           // gig enabled
       }
       else
       {
           // gig disabled
       }</pre> <hr/>
 
</div>
</div>
<a id="ga6b1754fa021a7d716ae86402581be518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b1754fa021a7d716ae86402581be518">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_enableGigabit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_enableGigabit </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_enableGigabit</b> </p>
<p><b>Description</b> <br />
 This function configures the MAC control register to enable Gigabit mode (full duplex only) for the MAC port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which settings must be configured.
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_GIG=1</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32 portNum = 1;

       CSL_CPGMAC_SL_enableGigabit (portNum);</pre> <hr/>
 
</div>
</div>
<a id="gac878070f61de3251e7cc2ade3767ae0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac878070f61de3251e7cc2ade3767ae0e">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_disableGigabit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_disableGigabit </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_disableGigabit</b> </p>
<p><b>Description</b> <br />
 This function configures the MAC control register to disable Gigabit mode for MAC port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which settings must be configured.
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_GIG=0</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32 portNum = 1;

       CSL_CPGMAC_SL_disableGigabit (portNum);</pre> <hr/>
 
</div>
</div>
<a id="ga7ba1c1609e9beca7c50ffd918cb4bc5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ba1c1609e9beca7c50ffd918cb4bc5c">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_isTxShortGapEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPGMAC_SL_isTxShortGapEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_isTxShortGapEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if Transmit short gap is enabled in the MAC control register for the MAC port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the API must
                               retrieve the settings.
*    </pre><p><b> Return Value </b> <br />
 TRUE Transmit short gap with a short IPG enabled <br />
 FALSE Transmit short gap disabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_TX_SHORT_GAP_ENABLE</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32 portNum  =   1;

       if (CSL_CPGMAC_SL_isTxShortGapEnabled (portNum) == TRUE)
       {
           // Tx short gap enabled
       }
       else
       {
           // Tx short gap disabled
       }</pre> <hr/>
 
</div>
</div>
<a id="gad469a8441c07e2a6a55543c2da320f5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad469a8441c07e2a6a55543c2da320f5b">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_enableTxShortGap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_enableTxShortGap </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_enableTxShortGap</b> </p>
<p><b>Description</b> <br />
 This function configures the MAC control register to enable transmit short gap for MAC port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which settings must be configured.
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_TX_SHORT_GAP_ENABLE=1</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32 portNum  =   1;

       CSL_CPGMAC_SL_enableTxShortGap (portNum);</pre> <hr/>
 
</div>
</div>
<a id="ga93b9b2549d54e913bec629fc8ff60c0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93b9b2549d54e913bec629fc8ff60c0a">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_disableTxShortGap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_disableTxShortGap </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_disableTxShortGap</b> </p>
<p><b>Description</b> <br />
 This function configures the MAC control register to disable transmit short gap for the MAC port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which settings must be configured.
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_TX_SHORT_GAP_ENABLE=0</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32 portNum  =   1;

       CSL_CPGMAC_SL_disableTxShortGap (portNum);</pre> <hr/>
 
</div>
</div>
<a id="ga692e4ce6272b14d967a8c9785f1c5e7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga692e4ce6272b14d967a8c9785f1c5e7e">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_isIdleModeEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPGMAC_SL_isIdleModeEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_isIdleModeEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if Idle mode is enabled in the MAC control register for MAC port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the API must
                               retrieve the settings.
*    </pre><p><b> Return Value </b> <br />
 TRUE Idle mode enabled <br />
 FALSE Idle mode disabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_CMD_IDLE</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32  portNum = 1;

       if (CSL_CPGMAC_SL_isTxShortGapEnabled (portNum) == TRUE)
       {
           // idle mode enabled
       }
       else
       {
           // idle mode disabled
       }</pre> <hr/>
 
</div>
</div>
<a id="ga953665afe2675373921437e53b1ada38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga953665afe2675373921437e53b1ada38">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_enableIdleMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_enableIdleMode </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_enableIdleMode</b> </p>
<p><b>Description</b> <br />
 This function configures the MAC control register to enable Idle mode for MAC port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which settings must be configured.
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_CMD_IDLE=1</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32 portNum  =   1;

       CSL_CPGMAC_SL_enableIdleMode (portNum);</pre> <hr/>
 
</div>
</div>
<a id="ga1ab6f2b3814003fc69257314c5a6cff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ab6f2b3814003fc69257314c5a6cff5">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_disableIdleMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_disableIdleMode </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_disableIdleMode</b> </p>
<p><b>Description</b> <br />
 This function configures the MAC control register to disable Idle mode for MAC port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which settings must be configured.
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_CMD_IDLE=0</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32 portNum = 1;

       CSL_CPGMAC_SL_disableIdleMode (portNum);</pre> <hr/>
 
</div>
</div>
<a id="ga705fb825bb761953b6aa402304837171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga705fb825bb761953b6aa402304837171">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_isCastagnoliCRCEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPGMAC_SL_isCastagnoliCRCEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_isCastagnoliCRCEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if Castagnoli CRC is enabled in the MAC control register for MAC port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the API must
                               retrieve the settings.
*    </pre><p><b> Return Value </b> <br />
 TRUE Castagnoli CRC enabled <br />
 FALSE Castagnoli CRC disabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_CRC_TYPE</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32  portNum = 1;

       if (CSL_CPGMAC_SL_isTxShortGapEnabled (portNum) == TRUE)
       {
           // idle mode enabled
       }
       else
       {
           // idle mode disabled
       }</pre> <hr/>
 
</div>
</div>
<a id="ga5f330d0b4ba55a45f80da8217f77cc19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f330d0b4ba55a45f80da8217f77cc19">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_enableCastagnoliCRC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_enableCastagnoliCRC </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_enableCastagnoliCRC</b> </p>
<p><b>Description</b> <br />
 This function configures the MAC control register to enable Castagnoli CRC for MAC port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which settings must be configured.
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_CRC_TYPE=1</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32 portNum  =   1;

       CSL_CPGMAC_SL_enableCastagnoliCRC (portNum);</pre> <hr/>
 
</div>
</div>
<a id="gaab55b8230f5adfe6d2d4faa4711362d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab55b8230f5adfe6d2d4faa4711362d0">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_disableCastagnoliCRC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_disableCastagnoliCRC </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_disableCastagnoliCRC</b> </p>
<p><b>Description</b> <br />
 This function configures the MAC control register to disable Castagnoli CRC for MAC port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which settings must be configured.
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_CRC_TYPE=0</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32 portNum = 1;

       CSL_CPGMAC_SL_disableCastagnoliCRC (portNum);</pre> <hr/>
 
</div>
</div>
<a id="gad137e89206f7619b4a09696a6a89016c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad137e89206f7619b4a09696a6a89016c">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_isIFCTLAEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPGMAC_SL_isIFCTLAEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_isIFCTLAEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if IFCTL_A bit is set in the MAC control register for MAC port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the API must
                               retrieve the settings.
*    </pre><p><b> Return Value </b> <br />
 TRUE IFCTL_A bit in MAC control register is set to 1. <br />
 FALSE IFCTL_A bit in MAC control register reads 0.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_IFCTL_A</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32 portNum  =   1;

       if (CSL_CPGMAC_SL_isIFCTLAEnabled (portNum) == TRUE)
       {
           // IFCTL_A bit set
       }
       else
       {
           // IFCTL_A bit cleared
       }</pre> <hr/>
 
</div>
</div>
<a id="gaf69dddba8973402a8f9c8dc5d41bf7d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf69dddba8973402a8f9c8dc5d41bf7d8">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_enableIFCTLA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_enableIFCTLA </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_enableIFCTLA</b> </p>
<p><b>Description</b> <br />
 This function enables the IFCTL_A bit in the MAC control register for MAC port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which settings must be configured.
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_IFCTL_A=1</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32 portNum  =   1;

       CSL_CPGMAC_SL_enableIFCTLA (portNum);</pre> <hr/>
 
</div>
</div>
<a id="gad6bbd08f896a2cfb021eedef6bda4406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6bbd08f896a2cfb021eedef6bda4406">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_disableIFCTLA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_disableIFCTLA </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_disableIFCTLA</b> </p>
<p><b>Description</b> <br />
 This function configures the MAC control register to clear the IFCTL_A bit for MAC port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which settings must be configured.
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_IFCTL_A=0</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32  portNum =   1;

       CSL_CPGMAC_SL_disableIFCTLA (portNum);</pre> <hr/>
 
</div>
</div>
<a id="ga1fb58ea84bed50a702e6e9532a8531ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fb58ea84bed50a702e6e9532a8531ec">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_isIFCTLBEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPGMAC_SL_isIFCTLBEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_isIFCTLBEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if IFCTL_B bit is set in the MAC control register for the MAC port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the API must
                               retrieve the settings.
*    </pre><p><b> Return Value </b> <br />
 TRUE IFCTL_B bit in MAC control register is set to 1. <br />
 FALSE IFCTL_B bit in MAC control register reads 0.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_IFCTL_B</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32  portNum =   1;

       if (CSL_CPGMAC_SL_isIFCTLBEnabled (portNum) == TRUE)
       {
           // IFCTL_B bit set
       }
       else
       {
           // IFCTL_B bit cleared
       }</pre> <hr/>
 
</div>
</div>
<a id="ga915cf80458934d9cb4ef4b5dc8ac39ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga915cf80458934d9cb4ef4b5dc8ac39ee">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_enableIFCTLB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_enableIFCTLB </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_enableIFCTLB</b> </p>
<p><b>Description</b> <br />
 This function enables the IFCTL_B bit in the MAC control register for the MAC port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which settings must be configured.
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_IFCTL_B=1</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32  portNum =   1;

       CSL_CPGMAC_SL_enableIFCTLB (portNum);</pre> <hr/>
 
</div>
</div>
<a id="ga04856f7efa944ccabb0ac3d41e768792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04856f7efa944ccabb0ac3d41e768792">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_disableIFCTLB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_disableIFCTLB </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_disableIFCTLB</b> </p>
<p><b>Description</b> <br />
 This function configures the MAC control register to clear the IFCTL_B bit for the MAC port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which settings must be configured.
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_IFCTL_B=0</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32 portNum = 1;

       CSL_CPGMAC_SL_disableIFCTLB (portNum);</pre> <hr/>
 
</div>
</div>
<a id="ga6e045d4440ee7cd471aba5264bc3b973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e045d4440ee7cd471aba5264bc3b973">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_isGigForceModeEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPGMAC_SL_isGigForceModeEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_isGigForceModeEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if Gigabit mode force bit is enabled in the MAC control register for the MAC port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the API must
                               retrieve the settings.
*    </pre><p><b> Return Value </b> <br />
 TRUE Gigabit mode force enabled. <br />
 FALSE Gigabit mode force disabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_GIG_FORCE</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32  portNum =   1;

       if (CSL_CPGMAC_SL_isGigForceModeEnabled (portNum) == TRUE)
       {
           // gig mode force enabled
       }
       else
       {
           // gig mode force disabled
       }</pre> <hr/>
 
</div>
</div>
<a id="ga92ef6199cf2eb7692af5a820ab120690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92ef6199cf2eb7692af5a820ab120690">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_enableGigForceMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_enableGigForceMode </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_enableGigForceMode</b> </p>
<p><b>Description</b> <br />
 This function configures the MAC control register to enable Gigabit force mode for the MAC port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which settings must be configured.
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_GIG_FORCE=1</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32  portNum =   1;

       CSL_CPGMAC_SL_enableGigForceMode (portNum);</pre> <hr/>
 
</div>
</div>
<a id="gae77d4fa36501f3043697d236591df173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae77d4fa36501f3043697d236591df173">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_disableGigForceMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_disableGigForceMode </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_disableGigForceMode</b> </p>
<p><b>Description</b> <br />
 This function configures the MAC control register to disable Gigabit force mode for the MAC port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which settings must be configured.
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_GIG_FORCE=0</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32  portNum =   1;

       CSL_CPGMAC_SL_disableGigForceMode (portNum);</pre> <hr/>
 
</div>
</div>
<a id="ga131c8e8b601ca850c05c830db77ebae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga131c8e8b601ca850c05c830db77ebae9">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_isExtControlEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPGMAC_SL_isExtControlEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_isExtControlEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if EXT_EN bit is enabled in the MAC control register for the MAC port specified. When this bit is set to 1, the Gigabit and Full duplex mode input is taken from an external source and not from the settings configured in this register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the API must
                               retrieve the settings.
*    </pre><p><b> Return Value </b> <br />
 TRUE External control mode enabled. <br />
 FALSE External control mode disabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_EXT_EN</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32  portNum =   1;

       if (CSL_CPGMAC_SL_isExtControlEnabled (portNum) == TRUE)
       {
           // external control mode enabled
       }
       else
       {
           // external control mode disabled
       }</pre> <hr/>
 
</div>
</div>
<a id="ga6d1f10949e3fb034db3806b2212eab86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d1f10949e3fb034db3806b2212eab86">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_enableExtControl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_enableExtControl </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_enableExtControl</b> </p>
<p><b>Description</b> <br />
 This function configures the MAC control register to enable external control of the Gigabit and full duplex mode settings.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which settings must be configured.
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_EXT_EN=1</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32 portNum  =   1;

       CSL_CPGMAC_SL_enableExtControl (portNum);</pre> <hr/>
 
</div>
</div>
<a id="gaa2253308a3a91804ea9013c356630d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2253308a3a91804ea9013c356630d5b">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_disableExtControl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_disableExtControl </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_disableExtControl</b> </p>
<p><b>Description</b> <br />
 This function configures the MAC control register to disable external control of the Gigabit and full duplex settings.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which settings must be configured.
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_EXT_EN=0</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32 portNum  =   1;

       CSL_CPGMAC_SL_disableExtControl (portNum);</pre> <hr/>
 
</div>
</div>
<a id="ga7eaaabe6b99b2b350f0b926579e0dac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7eaaabe6b99b2b350f0b926579e0dac7">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_isExtRxFlowEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPGMAC_SL_isExtRxFlowEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_isExtRxFlowEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if EXT_RX_FLOW_EN bit is enabled in the MAC control register for the MAC port specified. When this bit is set to 1, the Rx Flow control enable input is taken from an external source and not from the rx_flow_en setting configured in this register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the API must
                               retrieve the settings.
*    </pre><p><b> Return Value </b> <br />
 TRUE External Receive Flow control mode enabled. <br />
 FALSE External Receive Flow control mode disabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_EXT_RX_FLOW_EN</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32  portNum =   0;

       if (CSL_CPGMAC_SL_isExtRxFlowEnabled (portNum) == TRUE)
       {
           // external control mode enabled
       }
       else
       {
           // external control mode disabled
       }</pre> <hr/>
 
</div>
</div>
<a id="ga5557bcd4b505c520a550fb0b43dae6d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5557bcd4b505c520a550fb0b43dae6d6">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_enableExtRxFlow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_enableExtRxFlow </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_enableExtRxFlow</b> </p>
<p><b>Description</b> <br />
 This function configures the MAC control register to enable external control of the Receive Flow Control settings.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which settings must be configured.
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_EXT_RX_FLOW_EN=1</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32 portNum  =   1;

       CSL_CPGMAC_SL_enableExtRxFlow (portNum);</pre> <hr/>
 
</div>
</div>
<a id="ga6b1d5331da80cb09a73b4e72ce1afc70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b1d5331da80cb09a73b4e72ce1afc70">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_disableExtRxFlow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_disableExtRxFlow </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_disableExtRxFlow</b> </p>
<p><b>Description</b> <br />
 This function configures the MAC control register to disable external control of the Receive Flow Control settings.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which settings must be configured.
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_EXT_RX_FLOW_EN=0</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32 portNum  =   0;

       CSL_CPGMAC_SL_disableExtRxFlow (portNum);</pre> <hr/>
 
</div>
</div>
<a id="ga9c358d5783c05cecbd5b67a36d4790e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c358d5783c05cecbd5b67a36d4790e0">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_isExtTxFlowEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPGMAC_SL_isExtTxFlowEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_isExtTxFlowEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if EXT_TX_FLOW_EN bit is enabled in the MAC control register for the MAC port specified. When this bit is set to 1, the Tx Flow control enable input is taken from an external source and not from the rx_flow_en setting configured in this register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the API must
                               retrieve the settings.
*    </pre><p><b> Return Value </b> <br />
 TRUE External Transmit Flow control mode enabled. <br />
 FALSE External Transmit Flow control mode disabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_EXT_TX_FLOW_EN</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32  portNum =   0;

       if (CSL_CPGMAC_SL_isExtTxFlowEnabled (portNum) == TRUE)
       {
           // external control mode enabled
       }
       else
       {
           // external control mode disabled
       }</pre> <hr/>
 
</div>
</div>
<a id="ga4c1f3b6383c7416fe8cbbd8486885a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c1f3b6383c7416fe8cbbd8486885a8b">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_enableExtTxFlow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_enableExtTxFlow </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_enableExtTxFlow</b> </p>
<p><b>Description</b> <br />
 This function configures the MAC control register to enable external control of the Transmit Flow Control settings.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which settings must be configured.
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_EXT_TX_FLOW_EN=1</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32 portNum  =   1;

       CSL_CPGMAC_SL_enableExtTxFlow (portNum);</pre> <hr/>
 
</div>
</div>
<a id="gaf2ed5c52ce43b3d80d3b48a9aa994d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2ed5c52ce43b3d80d3b48a9aa994d69">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_disableExtTxFlow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_disableExtTxFlow </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_disableExtTxFlow</b> </p>
<p><b>Description</b> <br />
 This function configures the MAC control register to disable external control of the Transmit Flow Control settings.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which settings must be configured.
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_EXT_TX_FLOW_EN=0</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32 portNum  =   0;

       CSL_CPGMAC_SL_disableExtTxFlow (portNum);</pre> <hr/>
 
</div>
</div>
<a id="ga4daeb9593fe094537be68c2949412a23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4daeb9593fe094537be68c2949412a23">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_isRxCEFEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPGMAC_SL_isRxCEFEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_isRxCEFEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if MAC control register is programmed to copy frames containing errors to its memory.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the API must
                               retrieve the settings.
*    </pre><p><b> Return Value </b> <br />
 TRUE Copy Error frames mode enabled. Error frames will be transferred to memory. <br />
 FALSE Copy Error frames mode disabled. Error frames will be filtered.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_RX_CEF_EN</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32  portNum =   1;

       if (CSL_CPGMAC_SL_isRxCEFEnabled (portNum) == TRUE)
       {
           // Rx CEF enabled
       }
       else
       {
           // Rx CEF disabled
       }</pre> <hr/>
 
</div>
</div>
<a id="ga8a26a65291c4912b90b820292b06a921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a26a65291c4912b90b820292b06a921">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_enableRxCEF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_enableRxCEF </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_enableRxCEF</b> </p>
<p><b>Description</b> <br />
 This function configures the MAC control register to enable transfer of frames containing errors.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which settings must be configured.
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_RX_CEF_EN=1</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32 portNum = 1;

       CSL_CPGMAC_SL_enableRxCEF (portNum);</pre> <hr/>
 
</div>
</div>
<a id="ga22a6ba863a14a50e98dc05ae5e2ce547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22a6ba863a14a50e98dc05ae5e2ce547">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_disableRxCEF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_disableRxCEF </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_disableRxCEF</b> </p>
<p><b>Description</b> <br />
 This function configures the MAC control register to disable any error frames being transferred to the memory.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which settings must be configured.
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_RX_CEF_EN=0</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32 portNum = 1;

       CSL_CPGMAC_SL_disableRxCEF (portNum);</pre> <hr/>
 
</div>
</div>
<a id="ga3c97646ceef4fe2f8946f6f8b620763f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c97646ceef4fe2f8946f6f8b620763f">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_isRxCSFEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPGMAC_SL_isRxCSFEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_isRxCSFEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if MAC control register is programmed to copy short frames (frames shorter than 64 bytes) to its memory.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the API must
                               retrieve the settings.
*    </pre><p><b> Return Value </b> <br />
 TRUE Copy Short frames mode enabled. Short frames will be transferred to memory. <br />
 FALSE Copy Short frames mode disabled. Short frames will be filtered.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_RX_CSF_EN</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32 portNum = 1;

       if (CSL_CPGMAC_SL_isRxCSFEnabled (portNum) == TRUE)
       {
           // Rx CSF enabled
       }
       else
       {
           // Rx CSF disabled
       }</pre> <hr/>
 
</div>
</div>
<a id="ga53b724c510599d16384a98c2c35a3012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53b724c510599d16384a98c2c35a3012">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_enableRxCSF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_enableRxCSF </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_enableRxCSF</b> </p>
<p><b>Description</b> <br />
 This function configures the MAC control register to enable transfer of frames that are shorter than 64 bytes.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which settings must be configured.
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_RX_CSF_EN=1</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32 portNum = 1;

       CSL_CPGMAC_SL_enableRxCSF (portNum);</pre> <hr/>
 
</div>
</div>
<a id="ga1980b747cf5582fa1f60d0b9106c481e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1980b747cf5582fa1f60d0b9106c481e">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_disableRxCSF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_disableRxCSF </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_disableRxCSF</b> </p>
<p><b>Description</b> <br />
 This function configures the MAC control register to disable any short frames being transferred to the memory.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which settings must be configured.
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_RX_CSF_EN=0</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32 portNum = 1;

       CSL_CPGMAC_SL_disableRxCSF (portNum);</pre> <hr/>
 
</div>
</div>
<a id="gacb9485d726fa836ee0591265a102877d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb9485d726fa836ee0591265a102877d">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_isRxCMFEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPGMAC_SL_isRxCMFEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_isRxCMFEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if MAC control register is programmed to copy MAC Control Frames to its memory.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the API must
                               retrieve the settings.
*    </pre><p><b> Return Value </b> <br />
 TRUE Copy MAC control frames mode enabled. MAC control frames will be transferred to memory. <br />
 FALSE Copy MAC control frames mode disabled. MAC control frames will be filtered.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_RX_CMF_EN</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32 portNum = 1;

       if (CSL_CPGMAC_SL_isRxCMFEnabled (portNum) == TRUE)
       {
           // Rx CMF enabled
       }
       else
       {
           // Rx CMF disabled
       }</pre> <hr/>
 
</div>
</div>
<a id="ga8ab0f3c4ea98aa6007ae64531dd96697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ab0f3c4ea98aa6007ae64531dd96697">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_enableRxCMF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_enableRxCMF </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_enableRxCMF</b> </p>
<p><b>Description</b> <br />
 This function configures the MAC control register to enable transfer of MAC control frames.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which settings must be configured.
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_RX_CMF_EN=1</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32 portNum = 1;

       CSL_CPGMAC_SL_enableRxCMF (portNum);</pre> <hr/>
 
</div>
</div>
<a id="ga58d348404659fd41442449cf638092b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58d348404659fd41442449cf638092b2">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_disableRxCMF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_disableRxCMF </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_disableRxCMF</b> </p>
<p><b>Description</b> <br />
 This function configures the MAC control register to disable any MAC control frames being transferred to the memory.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which settings must be configured.
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_MAC_CONTROL_REG_RX_CMF_EN=0</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32  portNum =   1;

       CSL_CPGMAC_SL_disableRxCMF (portNum);</pre> <hr/>
 
</div>
</div>
<a id="ga03b778c33b07c635a15e380102af2d3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03b778c33b07c635a15e380102af2d3b">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_getMacControlReg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPGMAC_SL_getMacControlReg </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_getMacControlReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of MAC control register in entirety.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the API must
                               retrieve the settings.
*    </pre><p><b> Return Value </b> <br />
 &gt;=0 MAC control register contents.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPGMAC_SL_MACCONTROL_REG</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32          macControlVal, portNum = 1;

       macControlVal   =   CSL_CPGMAC_SL_getMacControlReg (portNum);</pre> <hr/>
 
</div>
</div>
<a id="ga913232a8dadc8c4536f0fc356624c514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga913232a8dadc8c4536f0fc356624c514">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_setMacControlReg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_setMacControlReg </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>macControlRegVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_setMacControlReg</b> </p>
<p><b>Description</b> <br />
 This function configures the contents of MAC control register in entirety.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum             MAC port number for which the reset must be performed.
       macControlRegVal    value to be configured to the MAC control register.
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPGMAC_SL_MACCONTROL_REG</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32          macControlVal, portNum = 1;

       macControlVal   =   CSL_CPGMAC_SL_getMacControlReg ();

       // Enable full duplex, giagbit mode too
       macControlVal   |=  CSL_CPGMAC_SL_MACCONTROL_FULLDUPLEX_EN |
                           CSL_CPGMAC_SL_MACCONTROL_GMII_EN;

       CSL_CPGMAC_SL_setMacControlReg (macControlVal, portNum);</pre> <hr/>
 
</div>
</div>
<a id="ga3dae0c863cb55937272dbd2e6bc0acf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3dae0c863cb55937272dbd2e6bc0acf3">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_getMacStatusReg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_getMacStatusReg </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCSL__CPGMAC__SL__MACSTATUS.html">CSL_CPGMAC_SL_MACSTATUS</a> *&#160;</td>
          <td class="paramname"><em>pMacStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_getMacStatusReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of MAC status register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the API must
                               retrieve the settings.
       pMacStatus              CSL_CPGMAC_SL_MACSTATUS structure to be populated with
                               the contents of MAC status register.
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_PN_MAC_STATUS_REG_TX_FLOW_ACT, XGE_CPSW_PN_MAC_STATUS_REG_RX_FLOW_ACT, XGE_CPSW_PN_MAC_STATUS_REG_EXT_FULLDUPLEX, XGE_CPSW_PN_MAC_STATUS_REG_EXT_GIG, XGE_CPSW_PN_MAC_STATUS_REG_EXT_TX_FLOW_EN, XGE_CPSW_PN_MAC_STATUS_REG_EXT_TX_FLOW_EN, XGE_CPSW_PN_MAC_STATUS_REG_IDLE</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_CPGMAC_SL_MACSTATUS      macStatus;
       Uint32                       portNum = 1;

       CSL_CPGMAC_SL_getMacStatusReg (portNum, &amp;macStatus);</pre> <hr/>
 
</div>
</div>
<a id="ga97904ba5021c044523b2d5016f89bf6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97904ba5021c044523b2d5016f89bf6a">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_resetMac()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_resetMac </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_resetMac</b> </p>
<p><b>Description</b> <br />
 This function issues a software reset to the MAC for the MAC port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum             MAC port number for which the reset must be performed.
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_MAC_SOFT_RESET_REG_SOFT_RESET=1</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32 portNum  =   1;

       CSL_CPGMAC_SL_resetMac (portNum);</pre> <hr/>
 
</div>
</div>
<a id="ga719fb81543246f395292ba28fa6af766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga719fb81543246f395292ba28fa6af766">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_isMACResetDone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPGMAC_SL_isMACResetDone </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_isMACResetDone</b> </p>
<p><b>Description</b> <br />
 This function reads the MAC Soft Reset register to check if the software reset operation has completed.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the API must
                               retrieve the settings.
*    </pre><p><b> Return Value </b> <br />
 TRUE MAC Soft reset done. <br />
 FALSE MAC Soft reset not yet completed.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_PN_MAC_SOFT_RESET_REG_SOFT_RESET</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32  portNum = 1;

       CSL_CPGMAC_SL_resetMac (portNum);

       // Wait until MAC software reset completes
       while (!CSL_CPGMAC_SL_isMACResetDone (portNum));</pre> <hr/>
 
</div>
</div>
<a id="ga778c15ec8773b66b2391e290607db771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga778c15ec8773b66b2391e290607db771">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_getRxMaxLen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPGMAC_SL_getRxMaxLen </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_getRxMaxLen</b> </p>
<p><b>Description</b> <br />
 This function retrieves the Receive maximum frame length configured in Receive Maximum length register for the MAC port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the API must
                               retrieve the settings.
*    </pre><p><b> Return Value </b> <br />
 &gt;=0 Receive maximum frame length read.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_PN_RX_MAXLEN_REG_RX_MAXLEN</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32          mtu, portNum = 1;

       mtu =   CSL_CPGMAC_SL_getRxMaxLen (portNum);</pre> <hr/>
 
</div>
</div>
<a id="gafe907be65c88dafc27bda3326449e1a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe907be65c88dafc27bda3326449e1a2">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_setRxMaxLen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPGMAC_SL_setRxMaxLen </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>rxMaxLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_setRxMaxLen</b> </p>
<p><b>Description</b> <br />
 This function sets up the Receive maximum frame length in Receive Maximum Length register for the MAC port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum             MAC port number for which the settings must be configured.
       rxMaxLen            the Receive maximum frame length to be configered into
                           the Receive Maximum Length register
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_RX_MAXLEN_REG_RX_MAXLEN</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32          mtu, portNum = 1;

       mtu =   1518;

       CSL_CPGMAC_SL_setRxMaxLen (portNum, mtu);</pre> <hr/>
 
</div>
</div>
<a id="gad282d147867d681de380db243fc5dcc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad282d147867d681de380db243fc5dcc1">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_getTxGap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPGMAC_SL_getTxGap </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_getTxGap</b> </p>
<p><b>Description</b> <br />
 This function retrieves the Transmit inter-packet gap configured in Transmit Gap register for the MAC port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the API must
                               retrieve the settings.
*    </pre><p><b> Return Value </b> <br />
 &gt;=0 Transmit inter-packet gap read.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_PN_MAC_TX_GAP_REG_TX_GAP</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32          txGap, portNum = 0;

       txGap =   CSL_CPGMAC_SL_getTxGap (portNum);</pre> <hr/>
 
</div>
</div>
<a id="ga07cf1375e2ed7f65e830aadaf3c131f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07cf1375e2ed7f65e830aadaf3c131f0">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_setTxGap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPGMAC_SL_setTxGap </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>txGap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_setTxGap</b> </p>
<p><b>Description</b> <br />
 This function sets up the Transmit inter-packet gap in Transmit Gap register for the MAC port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum             MAC port number for which the settings must be configured.
       txGap               Transmit inter-packet gap to be configured into the
                           Tx Gap register
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_MAC_TX_GAP_REG_TX_GAP</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32          txGap, portNum = 1;

       txGap =   100;

       CSL_CPGMAC_SL_setTxGap (portNum, txGap);</pre> <hr/>
 
</div>
</div>
<a id="ga0e053774d0c642bcc7cb471223f3525b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e053774d0c642bcc7cb471223f3525b">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_getRxPauseTimerReg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPGMAC_SL_getRxPauseTimerReg </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_getRxPauseTimerReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the Receive pause timer value configured in Receive pause timer register for the MAC port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the API must
                               retrieve the settings.
*    </pre><p><b> Return Value </b> <br />
 &gt;=0 Receive pause timer value read.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_PN_MAC_RX_PAUSETIMER_REG_RX_PAUSETIMER</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32          rxPauseTimer, portNum = 1;

       rxPauseTimer =   CSL_CPGMAC_SL_getRxPauseTimerReg (portNum);</pre> <hr/>
 
</div>
</div>
<a id="gae2dbbd3a3d50808d4555e2711b5ce0be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2dbbd3a3d50808d4555e2711b5ce0be">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_setRxPauseTimerReg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPGMAC_SL_setRxPauseTimerReg </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>rxPauseTimer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_setRxPauseTimerReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the Receive pause timer value in Receive pause timer register for the MAC port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum             MAC port number for which the settings must be configured.
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_MAC_RX_PAUSETIMER_REG_RX_PAUSETIMER</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32          rxPauseTimer = 2, portNum = 1;

       CSL_CPGMAC_SL_setRxPauseTimerReg (portNum, rxPauseTimer);</pre> <hr/>
 
</div>
</div>
<a id="ga81147b37660c31cb014fd53b259c712b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81147b37660c31cb014fd53b259c712b">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_getTxPauseTimerReg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPGMAC_SL_getTxPauseTimerReg </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_getTxPauseTimerReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the Transmit pause timer value configured in Transmit pause timer register for the MAC port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the API must
                               retrieve the settings.
*    </pre><p><b> Return Value </b> <br />
 &gt;=0 Transmit pause timer value read.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_PN_MAC_TX_PAUSETIMER_REG_TX_PAUSETIMER</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32          txPauseTimer, portNum = 1;

       txPauseTimer =   CSL_CPGMAC_SL_getTxPauseTimerReg (portNum);</pre> <hr/>
 
</div>
</div>
<a id="gabee0f08c9f9f29223e80ca4144350af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabee0f08c9f9f29223e80ca4144350af4">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_setTxPauseTimerReg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPGMAC_SL_setTxPauseTimerReg </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>txPauseTimer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_setTxPauseTimerReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the Transmit pause timer value in Transmit pause timer register for the MAC port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum             MAC port number for which the settings must be configured.
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_MAC_TX_PAUSETIMER_REG_TX_PAUSETIMER</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32          txPauseTimer = 2, portNum = 1;

       CSL_CPGMAC_SL_setTxPauseTimerReg (portNum, txPauseTimer);</pre> <hr/>
 
</div>
</div>
<a id="ga6b5504a47381b2b1298505ce9a02f4bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b5504a47381b2b1298505ce9a02f4bd">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_getEmulControlReg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_getEmulControlReg </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pEmulFreeBit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pEmulSoftBit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_getEmulControlReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of Emulation control register for the MAC port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum             MAC port number for which the API should retrieve
                           emulation settings for.
       pEmulFreeBit        Emulation free bit.
       pEmulSoftBit        Emulation soft bit.
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_PN_MAC_EMCONTROL_REG_FREE, XGE_CPSW_PN_MAC_EMCONTROL_REG_SOFT</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32          emulSoftBit, emulFreeBit, portNum = 1;

       CSL_CPGMAC_SL_getEmulControlReg (portNum, &amp;emulFreeBit, &amp;emulSoftBit);</pre> <hr/>
 
</div>
</div>
<a id="ga4741ae8b9e77739d24e289bc7feba552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4741ae8b9e77739d24e289bc7feba552">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_setEmulControlReg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_setEmulControlReg </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>emulFreeBit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>emulSoftBit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_setEmulControlReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of Emulation control register for the MAC port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum             MAC port for which the settings must be configured.
       emulFreeBit         Emulation free bit.
       emulSoftBit         Emulation soft bit.
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_PN_MAC_EMCONTROL_REG_FREE, XGE_CPSW_PN_MAC_EMCONTROL_REG_SOFT</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32          emulSoftBit, emulFreeBit, portNum = 1;

       emulFreeBit =   1;
       emulSoftBit =   0;

       CSL_CPGMAC_SL_setEmulControlReg (portNum, emulFreeBit, emulSoftBit);</pre> <hr/>
 
</div>
</div>
<a id="gabdbc366abcdda3f1af28906306460a7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdbc366abcdda3f1af28906306460a7c">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_getMacRxPriMapReg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_getMacRxPriMapReg </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pMacRxPriMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_getMacRxPriMapReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the MAC Receive Packet Priority to Header Priority Mapping Register for the MAC port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the API should retrieve
                               settings for.
       pMacRxPriMap            Array of MAC Rx packet priority map priority values
                               read from the register.
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 The input parameter 'pMacRxPriMap' must be large enough to hold all the 8 priority values read from the register.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_PN_RX_PRI_MAP_REG_PRI0, XGE_CPSW_PN_RX_PRI_MAP_REG_PRI1, XGE_CPSW_PN_RX_PRI_MAP_REG_PRI2, XGE_CPSW_PN_RX_PRI_MAP_REG_PRI3, XGE_CPSW_PN_RX_PRI_MAP_REG_PRI4, XGE_CPSW_PN_RX_PRI_MAP_REG_PRI5, XGE_CPSW_PN_RX_PRI_MAP_REG_PRI6, XGE_CPSW_PN_RX_PRI_MAP_REG_PRI7</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      pPortRxPriMap [8], portNum = 1;

       CSL_CPGMAC_SL_getMacRxPriMapReg (portNum, pPortRxPriMap);</pre> <hr/>
 
</div>
</div>
<a id="ga74088fdca82faa25c5d9b8a7120167b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74088fdca82faa25c5d9b8a7120167b4">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_setMacRxPriMapReg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_setMacRxPriMapReg </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pMacRxPriMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_setMacRxPriMapReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the MAC Receive Packet Priority to Header Priority Mapping Register for the MAC port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port for which the settings must be configured.
       pMacRxPriMap            Array of MAC Rx priority map priority values
                               that must be configured to the register.
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_RX_PRI_MAP_REG_PRI0, XGE_CPSW_PN_RX_PRI_MAP_REG_PRI1, XGE_CPSW_PN_RX_PRI_MAP_REG_PRI2, XGE_CPSW_PN_RX_PRI_MAP_REG_PRI3, XGE_CPSW_PN_RX_PRI_MAP_REG_PRI4, XGE_CPSW_PN_RX_PRI_MAP_REG_PRI5, XGE_CPSW_PN_RX_PRI_MAP_REG_PRI6, XGE_CPSW_PN_RX_PRI_MAP_REG_PRI7</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      i, pMacRxPriMap [8], portNum = 1;

       for (i = 0; i &lt; 8; i ++)
           pMacRxPriMap [i] = i;

       CSL_CPGMAC_SL_setMacRxPriMapReg (portNum, pMacRxPriMap);</pre> <hr/>
 
</div>
</div>
<a id="ga058d3597c74a511c0878d33a3991d38f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga058d3597c74a511c0878d33a3991d38f">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_clearMacStatusTorf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_clearMacStatusTorf </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_clearMacStatusTorf</b> </p>
<p><b>Description</b> <br />
 This function clears Top of receive FIFO flow control trigger bit in PN_MAC_STATUS register</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<hr/>
 
</div>
</div>
<a id="ga0aea842c50365007d7de73402d4aee25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0aea842c50365007d7de73402d4aee25">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_clearMacStatusTorfPri()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_clearMacStatusTorfPri </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_clearMacStatusTorf</b> </p>
<p><b>Description</b> <br />
 This function clears Top of receive FIFO flow control Priority field in PN_MAC_STATUS register</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number
*    </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<hr/>
 
</div>
</div>
<a id="ga210266957e45312e68db830eadab8330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga210266957e45312e68db830eadab8330">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_getInterVLANCfg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_getInterVLANCfg </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>routeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCSL__CPSW__INTERVLANCFG.html">CSL_CPSW_INTERVLANCFG</a> *&#160;</td>
          <td class="paramname"><em>pInterVLANCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_getInterVLANCfg</b> </p>
<p><b>Description</b> <br />
 This function gets the intervlan configuration for the given port and route index</p>
<p><b>Arguments</b> </p><pre class="fragment">*       portNum   Port number for which the intervlan configuration is queried
*       routeIndex Intervlan route index.Valid pointer locations are 1 to x
*                  (where x is the number of locations - pointer location zero
*                   is unused).
*       pInterVLANCfg Intervlan configuration structure to be populated
*   </pre><p><b> Return Value </b> <br />
 none</p>
<hr/>
 
</div>
</div>
<a id="gab961138093deeb4e46e703e96c8dd18f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab961138093deeb4e46e703e96c8dd18f">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_setInterVLANCfg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_setInterVLANCfg </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>routeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCSL__CPSW__INTERVLANCFG.html">CSL_CPSW_INTERVLANCFG</a> *&#160;</td>
          <td class="paramname"><em>pInterVLANCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_setInterVLANCfg</b> </p>
<p><b>Description</b> <br />
 This function sets the intervlan configuration for the given port and route index</p>
<p><b>Arguments</b> </p><pre class="fragment">*       portNum   Port number for which the intervlan configuration is queried
*       routeIndex Intervlan route index.Valid pointer locations are 1 to x
*                  (where x is the number of locations - pointer location zero
*                   is unused).
*       pInterVLANCfg Intervlan configuration structure to be set
*   </pre><p><b> Return Value </b> <br />
 none</p>
<hr/>
 
</div>
</div>
<a id="ga85900972abad2459b4c21ec6c5aef986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85900972abad2459b4c21ec6c5aef986">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_getFifoStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_getFifoStatus </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCSL__CPGMAC__SL__FIFOSTATUS.html">CSL_CPGMAC_SL_FIFOSTATUS</a> *&#160;</td>
          <td class="paramname"><em>pFifoStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_getFifoStatus</b> </p>
<p><b>Description</b> <br />
 This function gets the Enet_Pn_FIFO_Status register contents</p>
<p><b>Arguments</b> </p><pre class="fragment">*       portNum   Port number for which the intervlan configuration is queried
*       pFifoStatus Fifo status structure to be populated
*   </pre><p><b> Return Value </b> <br />
 none</p>
<hr/>
 
</div>
</div>
<a id="ga3f67490688fb03d3a07a2ec25db353b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f67490688fb03d3a07a2ec25db353b6">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_isTxShortGapLimitEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPGMAC_SL_isTxShortGapLimitEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_isTxShortGapLimitEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if Transmit short gap limit is enabled in the MAC control register for the MAC port specified. When set this bit limits the number of short gap packets transmitted to 100ppm. Each time a short gap packet is sent, a counter is loaded with 10,000 and decremented on each wireside clock. Another short gap packet will not be sent out until the counter decrements to zero. This mode is included to preclude the host from filling up the FIFO and sending every packet out with short gap which would violate the maximum number of packets per second allowed. This bit is used only with GMII (not XGMII).</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the API must
                               retrieve the settings.
*    </pre><p><b> Return Value </b> <br />
 TRUE Transmit short gap limit with a short IPG enabled <br />
 FALSE Transmit short gap limit disabled.</p>
<hr/>
 
</div>
</div>
<a id="ga6abc7d40ae3950162281fa51f149b868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6abc7d40ae3950162281fa51f149b868">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_enableTxShortGapLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_enableTxShortGapLimit </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_enableTxShortGap</b> </p>
<p><b>Description</b> <br />
 This function configures the MAC control register to enable transmit short gap limiting for MAC port specified. When set this bit limits the number of short gap packets transmitted to 100ppm. Each time a short gap packet is sent, a counter is loaded with 10,000 and decremented on each wireside clock. Another short gap packet will not be sent out until the counter decrements to zero. This mode is included to preclude the host from filling up the FIFO and sending every packet out with short gap which would violate the maximum number of packets per second allowed. This bit is used only with GMII (not XGMII).</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which settings must be configured.
*    </pre><p><b>Return</b> Value <br />
 None</p>
<hr/>
 
</div>
</div>
<a id="ga10a58ea6855f79c8e7a411b41d23ad3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10a58ea6855f79c8e7a411b41d23ad3b">&#9670;&nbsp;</a></span>CSL_CPGMAC_SL_disableTxShortGapLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPGMAC_SL_disableTxShortGapLimit </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPGMAC_SL_disableTxShortGapLimit</b> </p>
<p><b>Description</b> <br />
 This function configures the MAC control register to disable transmit short gap limit for the MAC port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which settings must be configured.
*    </pre><p><b> Return Value </b> <br />
 None</p>
<hr/>
 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
