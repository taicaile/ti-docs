<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<title>PDK API Guide for J721S2: ESM Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ti_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PDK API Guide for J721S2
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__CSL__ESM__FUNCTION.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ESM Functions<div class="ingroups"><a class="el" href="group__CSL__IP__MODULE.html">CSL-FL</a> &raquo; <a class="el" href="group__CSL__ESM.html">ESM CSL-FL</a><a class="el" href="group__CSL__IP__MODULE.html">CSL-FL</a> &raquo; <a class="el" href="group__CSL__ESM.html">ESM CSL-FL</a> &raquo;  &#124; <a class="el" href="group__CSL__ESM__API.html">ESM (ESM)</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Introduction</h2>
<p>=========================================================================== </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaaa9075167f8008a208609d3d158389bd"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__ESM__FUNCTION.html#gaaa9075167f8008a208609d3d158389bd">ESMSetMode</a> (uint32_t baseAddr, <a class="el" href="group__CSL__ESM__ENUM.html#ga67cfbd91988c4f6fb5e19db6699c8992">esmOperationMode_t</a> <a class="el" href="tisci__rm__ra_8h.html#a37e90f5e3bd99fac2021fb3a326607d4">mode</a>)</td></tr>
<tr class="memdesc:gaaa9075167f8008a208609d3d158389bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to configure operation mode of ESM module.  <a href="#gaaa9075167f8008a208609d3d158389bd">More...</a><br /></td></tr>
<tr class="separator:gaaa9075167f8008a208609d3d158389bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeac535b0fc602082185bf421e129d6c9"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__ESM__FUNCTION.html#gaeac535b0fc602082185bf421e129d6c9">ESMGetMode</a> (uint32_t baseAddr, <a class="el" href="group__CSL__ESM__ENUM.html#ga67cfbd91988c4f6fb5e19db6699c8992">esmOperationMode_t</a> *pMode)</td></tr>
<tr class="memdesc:gaeac535b0fc602082185bf421e129d6c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to read operation mode of ESM module.  <a href="#gaeac535b0fc602082185bf421e129d6c9">More...</a><br /></td></tr>
<tr class="separator:gaeac535b0fc602082185bf421e129d6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c32db4a4c340a3e2689024f29b93a1a"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__ESM__FUNCTION.html#ga5c32db4a4c340a3e2689024f29b93a1a">ESMSetInfluenceOnErrPin</a> (uint32_t baseAddr, uint32_t intrSrc, bool enable)</td></tr>
<tr class="memdesc:ga5c32db4a4c340a3e2689024f29b93a1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to set the influence of interrupt on nERROR pin.  <a href="#ga5c32db4a4c340a3e2689024f29b93a1a">More...</a><br /></td></tr>
<tr class="separator:ga5c32db4a4c340a3e2689024f29b93a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad91fabf448ce491c3954924b2e3798b5"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__ESM__FUNCTION.html#gad91fabf448ce491c3954924b2e3798b5">ESMGetInfluenceOnErrPin</a> (uint32_t baseAddr, uint32_t intrSrc, uint32_t *pInfluence)</td></tr>
<tr class="memdesc:gad91fabf448ce491c3954924b2e3798b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to get the influence of interrupt on nERROR pin.  <a href="#gad91fabf448ce491c3954924b2e3798b5">More...</a><br /></td></tr>
<tr class="separator:gad91fabf448ce491c3954924b2e3798b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d322bfef697555e59a4777eaf342175"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__ESM__FUNCTION.html#ga5d322bfef697555e59a4777eaf342175">ESMSetErrPinLowTimePreload</a> (uint32_t baseAddr, uint32_t lowTime)</td></tr>
<tr class="memdesc:ga5d322bfef697555e59a4777eaf342175"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to configure the low time counter pre-load value.  <a href="#ga5d322bfef697555e59a4777eaf342175">More...</a><br /></td></tr>
<tr class="separator:ga5d322bfef697555e59a4777eaf342175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0defdd750fc8c05846da1e4b56935dab"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__ESM__FUNCTION.html#ga0defdd750fc8c05846da1e4b56935dab">ESMGetErrPinLowTimePreload</a> (uint32_t baseAddr, uint32_t *pLowTime)</td></tr>
<tr class="memdesc:ga0defdd750fc8c05846da1e4b56935dab"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to read the low time counter pre-load value.  <a href="#ga0defdd750fc8c05846da1e4b56935dab">More...</a><br /></td></tr>
<tr class="separator:ga0defdd750fc8c05846da1e4b56935dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0f036f26cb65270ac0e4b62b029a9ba"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__ESM__FUNCTION.html#gab0f036f26cb65270ac0e4b62b029a9ba">ESMGetCurrErrPinLowTimeCnt</a> (uint32_t baseAddr, uint32_t *pPinCntrPre)</td></tr>
<tr class="memdesc:gab0f036f26cb65270ac0e4b62b029a9ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to get the current value of low time counter.  <a href="#gab0f036f26cb65270ac0e4b62b029a9ba">More...</a><br /></td></tr>
<tr class="separator:gab0f036f26cb65270ac0e4b62b029a9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab00fe641aed938e7d7ed8f903f16a503"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__ESM__FUNCTION.html#gab00fe641aed938e7d7ed8f903f16a503">ESMGetErrPinStatus</a> (uint32_t baseAddr, uint32_t *pStatus)</td></tr>
<tr class="memdesc:gab00fe641aed938e7d7ed8f903f16a503"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to get the current status of nERROR pin.  <a href="#gab00fe641aed938e7d7ed8f903f16a503">More...</a><br /></td></tr>
<tr class="separator:gab00fe641aed938e7d7ed8f903f16a503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaca71033c4f04171188ac44bee22d86e"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__ESM__FUNCTION.html#gaaca71033c4f04171188ac44bee22d86e">ESMResetErrPin</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:gaaca71033c4f04171188ac44bee22d86e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to reset the nERROR pin.  <a href="#gaaca71033c4f04171188ac44bee22d86e">More...</a><br /></td></tr>
<tr class="separator:gaaca71033c4f04171188ac44bee22d86e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7915fc345ceb6ad94efddc6e92a70d2b"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__ESM__FUNCTION.html#ga7915fc345ceb6ad94efddc6e92a70d2b">ESMIsEnableIntr</a> (uint32_t baseAddr, uint32_t intrSrc, uint32_t *pEnStatus)</td></tr>
<tr class="memdesc:ga7915fc345ceb6ad94efddc6e92a70d2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used check if interrupt is enabled/disabled.  <a href="#ga7915fc345ceb6ad94efddc6e92a70d2b">More...</a><br /></td></tr>
<tr class="separator:ga7915fc345ceb6ad94efddc6e92a70d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8626ff17a04e6290d208c0196b6e543"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__ESM__FUNCTION.html#gaa8626ff17a04e6290d208c0196b6e543">ESMEnableIntr</a> (uint32_t baseAddr, uint32_t intrNum)</td></tr>
<tr class="memdesc:gaa8626ff17a04e6290d208c0196b6e543"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to enable interrupt.  <a href="#gaa8626ff17a04e6290d208c0196b6e543">More...</a><br /></td></tr>
<tr class="separator:gaa8626ff17a04e6290d208c0196b6e543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ec4726b706f5cb1770271dd5f4023ca"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__ESM__FUNCTION.html#ga4ec4726b706f5cb1770271dd5f4023ca">ESMDisableIntr</a> (uint32_t baseAddr, uint32_t intrNum)</td></tr>
<tr class="memdesc:ga4ec4726b706f5cb1770271dd5f4023ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to disable interrupt.  <a href="#ga4ec4726b706f5cb1770271dd5f4023ca">More...</a><br /></td></tr>
<tr class="separator:ga4ec4726b706f5cb1770271dd5f4023ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacec6a537b28d41c84985e182665a29c6"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__ESM__FUNCTION.html#gacec6a537b28d41c84985e182665a29c6">ESMSetIntrPriorityLvl</a> (uint32_t baseAddr, uint32_t intrSrc, <a class="el" href="group__CSL__ESM__ENUM.html#ga06f41023eabd3866b6e7cff0476f84e8">esmIntrPriorityLvl_t</a> intrPriorityLvl)</td></tr>
<tr class="memdesc:gacec6a537b28d41c84985e182665a29c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to set interrupt level.  <a href="#gacec6a537b28d41c84985e182665a29c6">More...</a><br /></td></tr>
<tr class="separator:gacec6a537b28d41c84985e182665a29c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb4735c9c694628d5f47e55aaf115b3a"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__ESM__FUNCTION.html#gabb4735c9c694628d5f47e55aaf115b3a">ESMGetIntrPriorityLvl</a> (uint32_t baseAddr, uint32_t intrSrc, <a class="el" href="group__CSL__ESM__ENUM.html#ga06f41023eabd3866b6e7cff0476f84e8">esmIntrPriorityLvl_t</a> *pIntrPriorityLvl)</td></tr>
<tr class="memdesc:gabb4735c9c694628d5f47e55aaf115b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to get interrupt level.  <a href="#gabb4735c9c694628d5f47e55aaf115b3a">More...</a><br /></td></tr>
<tr class="separator:gabb4735c9c694628d5f47e55aaf115b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6bf58c63a0251b89e74f205d0564edd"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__ESM__FUNCTION.html#gab6bf58c63a0251b89e74f205d0564edd">ESMGetIntrStatus</a> (uint32_t baseAddr, uint32_t intrSrc, uint32_t *pStaus)</td></tr>
<tr class="memdesc:gab6bf58c63a0251b89e74f205d0564edd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to get the interrupt status.  <a href="#gab6bf58c63a0251b89e74f205d0564edd">More...</a><br /></td></tr>
<tr class="separator:gab6bf58c63a0251b89e74f205d0564edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64b5a23f1b0d65606a008c4d45677279"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__ESM__FUNCTION.html#ga64b5a23f1b0d65606a008c4d45677279">ESMSetIntrStatusRAW</a> (uint32_t baseAddr, uint32_t intrSrc)</td></tr>
<tr class="memdesc:ga64b5a23f1b0d65606a008c4d45677279"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to set the interrupt RAW status.  <a href="#ga64b5a23f1b0d65606a008c4d45677279">More...</a><br /></td></tr>
<tr class="separator:ga64b5a23f1b0d65606a008c4d45677279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7d0077164154c6e5bacba0f110726ae"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__ESM__FUNCTION.html#gaf7d0077164154c6e5bacba0f110726ae">ESMGetIntrStatusRAW</a> (uint32_t baseAddr, uint32_t intrSrc, uint32_t *pStatus)</td></tr>
<tr class="memdesc:gaf7d0077164154c6e5bacba0f110726ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to get the interrupt RAW status.  <a href="#gaf7d0077164154c6e5bacba0f110726ae">More...</a><br /></td></tr>
<tr class="separator:gaf7d0077164154c6e5bacba0f110726ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb94fff01ab87d17fdd375beebe94f14"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__ESM__FUNCTION.html#gabb94fff01ab87d17fdd375beebe94f14">ESMGetGroupIntrStatus</a> (uint32_t baseAddr, <a class="el" href="group__CSL__ESM__ENUM.html#ga06f41023eabd3866b6e7cff0476f84e8">esmIntrPriorityLvl_t</a> intrPrioType, <a class="el" href="structesmGroupIntrStatus__t.html">esmGroupIntrStatus_t</a> *pIntrstatus)</td></tr>
<tr class="memdesc:gabb94fff01ab87d17fdd375beebe94f14"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to get the interrupt/error status for a group. This will also return highest pending interrupt for pulse as well as for level interrupts.  <a href="#gabb94fff01ab87d17fdd375beebe94f14">More...</a><br /></td></tr>
<tr class="separator:gabb94fff01ab87d17fdd375beebe94f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a215eae668b1286e206f08332479ffb"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__ESM__FUNCTION.html#ga0a215eae668b1286e206f08332479ffb">ESMClearIntrStatus</a> (uint32_t baseAddr, uint32_t intrSrc)</td></tr>
<tr class="memdesc:ga0a215eae668b1286e206f08332479ffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to clear the interrupt status.  <a href="#ga0a215eae668b1286e206f08332479ffb">More...</a><br /></td></tr>
<tr class="separator:ga0a215eae668b1286e206f08332479ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7abf3be2629dd10637cbdb7f0fc8d831"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__ESM__FUNCTION.html#ga7abf3be2629dd10637cbdb7f0fc8d831">ESMWriteEOI</a> (uint32_t baseAddr, <a class="el" href="group__CSL__ESM__ENUM.html#gafb60e72332cf0a99eb2107688a0cae14">esmIntrType_t</a> intrType)</td></tr>
<tr class="memdesc:ga7abf3be2629dd10637cbdb7f0fc8d831"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to write EOI.  <a href="#ga7abf3be2629dd10637cbdb7f0fc8d831">More...</a><br /></td></tr>
<tr class="separator:ga7abf3be2629dd10637cbdb7f0fc8d831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ff7375db409a4297858502824c1153b"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__ESM__FUNCTION.html#ga9ff7375db409a4297858502824c1153b">ESMGetRevisionId</a> (uint32_t baseAddr, <a class="el" href="structesmRevisionId__t.html">esmRevisionId_t</a> *pRevId)</td></tr>
<tr class="memdesc:ga9ff7375db409a4297858502824c1153b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used get the ESM revision ID.  <a href="#ga9ff7375db409a4297858502824c1153b">More...</a><br /></td></tr>
<tr class="separator:ga9ff7375db409a4297858502824c1153b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0c5b45366ef756261a65fbcb873d353"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__ESM__FUNCTION.html#gab0c5b45366ef756261a65fbcb873d353">ESMGetInfo</a> (uint32_t baseAddr, <a class="el" href="structesmInfo__t.html">esmInfo_t</a> *pInfo)</td></tr>
<tr class="memdesc:gab0c5b45366ef756261a65fbcb873d353"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used read the ESM information register.  <a href="#gab0c5b45366ef756261a65fbcb873d353">More...</a><br /></td></tr>
<tr class="separator:gab0c5b45366ef756261a65fbcb873d353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac01a6cb321ed85ea66d50356b5298f3c"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__ESM__FUNCTION.html#gac01a6cb321ed85ea66d50356b5298f3c">ESMGetGlobalIntrEnabledStatus</a> (uint32_t baseAddr, uint32_t *pStatus)</td></tr>
<tr class="memdesc:gac01a6cb321ed85ea66d50356b5298f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used read the ESM information register.  <a href="#gac01a6cb321ed85ea66d50356b5298f3c">More...</a><br /></td></tr>
<tr class="separator:gac01a6cb321ed85ea66d50356b5298f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c78a748afcb5fc1ccb9d5c2695f33d8"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__ESM__FUNCTION.html#ga4c78a748afcb5fc1ccb9d5c2695f33d8">ESMEnableGlobalIntr</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:ga4c78a748afcb5fc1ccb9d5c2695f33d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to enable Global control of interrupt.  <a href="#ga4c78a748afcb5fc1ccb9d5c2695f33d8">More...</a><br /></td></tr>
<tr class="separator:ga4c78a748afcb5fc1ccb9d5c2695f33d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcec7663af7ea265599a24c518f91c94"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__ESM__FUNCTION.html#gabcec7663af7ea265599a24c518f91c94">ESMDisableGlobalIntr</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:gabcec7663af7ea265599a24c518f91c94"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to disable Global control of interrupt.  <a href="#gabcec7663af7ea265599a24c518f91c94">More...</a><br /></td></tr>
<tr class="separator:gabcec7663af7ea265599a24c518f91c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf43491d7de4d9f0eade112d2e743aa9e"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__ESM__FUNCTION.html#gaf43491d7de4d9f0eade112d2e743aa9e">ESMReset</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:gaf43491d7de4d9f0eade112d2e743aa9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to reset ESM module. Reset is used to reset all enables and raw status bits.  <a href="#gaf43491d7de4d9f0eade112d2e743aa9e">More...</a><br /></td></tr>
<tr class="separator:gaf43491d7de4d9f0eade112d2e743aa9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga665947c3075020ac844dc74750eecf52"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__ESM__FUNCTION.html#ga665947c3075020ac844dc74750eecf52">ESMReadStaticRegs</a> (uint32_t baseAddr, <a class="el" href="structCSL__esmStaticRegs.html">CSL_esmStaticRegs</a> *pStaticRegs)</td></tr>
<tr class="memdesc:ga665947c3075020ac844dc74750eecf52"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to read static registers of ESM module. This API needs to be called after the initial configuration is done and hence mutliple read between static registers do not change the values.  <a href="#ga665947c3075020ac844dc74750eecf52">More...</a><br /></td></tr>
<tr class="separator:ga665947c3075020ac844dc74750eecf52"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaaa9075167f8008a208609d3d158389bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa9075167f8008a208609d3d158389bd">&#9670;&nbsp;</a></span>ESMSetMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ESMSetMode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CSL__ESM__ENUM.html#ga67cfbd91988c4f6fb5e19db6699c8992">esmOperationMode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to configure operation mode of ESM module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the ESM Registers.</td></tr>
    <tr><td class="paramname">mode</td><td>Channel number for which reset is to be done. Refer enum <a class="el" href="group__CSL__ESM__ENUM.html#ga67cfbd91988c4f6fb5e19db6699c8992" title="ESM Operation Mode type.">esmOperationMode_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS - API success <br />
 CSL_EBADARGS - API fails due to bad input arguments</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><br />
 ESM module is reset and initialized for desired operation</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><br />
 None</dd></dl>
<p><b>Example</b> </p><pre class="fragment">    uint32_t            baseAddr = CSL_MCU_ESM0_CFG_BASE;
    esmOperationMode_t  mode     = ESM_OPERATION_MODE_ERROR_FORCE;
    int32_t             cslRet;

    cslRet = ESMSetMode (baseAddr, mode);</pre> 
</div>
</div>
<a id="gaeac535b0fc602082185bf421e129d6c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeac535b0fc602082185bf421e129d6c9">&#9670;&nbsp;</a></span>ESMGetMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ESMGetMode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CSL__ESM__ENUM.html#ga67cfbd91988c4f6fb5e19db6699c8992">esmOperationMode_t</a> *&#160;</td>
          <td class="paramname"><em>pMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to read operation mode of ESM module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the ESM Registers.</td></tr>
    <tr><td class="paramname">pMode</td><td>pointer to variable to hold ESM operation Mode. Refer enum <a class="el" href="group__CSL__ESM__ENUM.html#ga67cfbd91988c4f6fb5e19db6699c8992" title="ESM Operation Mode type.">esmOperationMode_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS - API success <br />
 CSL_EBADARGS - API fails due to bad input arguments</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><br />
 ESM module is reset and initialized for desired operation</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><br />
 None</dd></dl>
<p><b>Example</b> </p><pre class="fragment">    uint32_t            baseAddr = CSL_MCU_ESM0_CFG_BASE;
    esmOperationMode_t  mode;
    uint32_t            cslRet;

    cslRet = ESMGetMode (baseAddr, &amp;mode);</pre> 
</div>
</div>
<a id="ga5c32db4a4c340a3e2689024f29b93a1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c32db4a4c340a3e2689024f29b93a1a">&#9670;&nbsp;</a></span>ESMSetInfluenceOnErrPin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ESMSetInfluenceOnErrPin </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to set the influence of interrupt on nERROR pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the ESM Registers.</td></tr>
    <tr><td class="paramname">intrSrc</td><td>Interrupt source which will influence nERROR pin.</td></tr>
    <tr><td class="paramname">enable</td><td>true: Enables influence on nERROR pin if it is TRUE. false:Disables influence on nERROR pin if it is FALSE.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS - success <br />
 CSL_EBADARGS - API fails due to bad input arguments</dd></dl>
<p>Note: the intrSrc check is only at the IP level max and not done at instance level, so it is expected to be done at higher layer.</p>
<dl class="section pre"><dt>Precondition</dt><dd><br />
 ESM module is reset and initialized for desired operation</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><br />
 None</dd></dl>
<p><b>Example</b> </p><pre class="fragment">    uint32_t            baseAddr = CSL_MCU_ESM0_CFG_BASE;
    uint32_t            intrSrc  = CSL_ESM1_INTR_MCU0_CPU0_ECC_CORRECTED_LEVEL;
    int32_t             cslRet;
    cslRet =  ESMSetInfluenceOnErrPin (baseAddr, intrSrc, TRUE);</pre> 
</div>
</div>
<a id="gad91fabf448ce491c3954924b2e3798b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad91fabf448ce491c3954924b2e3798b5">&#9670;&nbsp;</a></span>ESMGetInfluenceOnErrPin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ESMGetInfluenceOnErrPin </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pInfluence</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to get the influence of interrupt on nERROR pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the ESM Registers.</td></tr>
    <tr><td class="paramname">intrSrc</td><td>Interrupt source which will influence nERROR pin.</td></tr>
    <tr><td class="paramname">pInfluence</td><td>pointer to read the influence value 1: enabled 0: disabled</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS - success <br />
 CSL_EBADARGS - API fails due to bad input arguments</dd></dl>
<p>Note: the intrSrc check is only at the IP level max and not done at instance level, so it is expected to be done at higher layer.</p>
<dl class="section pre"><dt>Precondition</dt><dd><br />
 ESM module is reset and initialized for desired operation</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><br />
 None</dd></dl>
<p><b>Example</b> </p><pre class="fragment">    uint32_t            baseAddr = CSL_MCU_ESM0_CFG_BASE;
    uint32_t            intrSrc  = CSL_ESM1_INTR_MCU0_CPU0_ECC_CORRECTED_LEVEL;
    uint32_t            influence;
    int32_t             cslRet;
    cslRet =  ESMGetInfluenceOnErrPin (baseAddr, intrSrc, &amp;influence);</pre> 
</div>
</div>
<a id="ga5d322bfef697555e59a4777eaf342175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d322bfef697555e59a4777eaf342175">&#9670;&nbsp;</a></span>ESMSetErrPinLowTimePreload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ESMSetErrPinLowTimePreload </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lowTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to configure the low time counter pre-load value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the ESM Registers.</td></tr>
    <tr><td class="paramname">lowTime</td><td>Time to be configured as LTCP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS - success <br />
 CSL_EBADARGS - API fails due to bad input arguments</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><br />
 ESM module is reset and initialized for desired operation</dd></dl>
<p>This is the value that will be pre-loaded in to the counter field of the ESM_PIN_CNTR register whenever the ESM enters the ESM_ERROR state from ESM_IDLE. The default value is determined based on the ESM clock frequency, so that there is a minimum low time of 100 micro seconds. This field is only reset by a Power-On-Reset (not warm reset). A global soft reset will set this field to 0h.</p>
<dl class="section post"><dt>Postcondition</dt><dd><br />
 None</dd></dl>
<p><b>Example</b> </p><pre class="fragment">    uint32_t            baseAddr = CSL_MCU_ESM0_CFG_BASE;
    uint32_t            pinCntrPre  = 100;
    int32_t             cslRet;
    cslRet = ESMSetErrPinLowTimePreload (baseAddr, pinCntrPre);</pre> 
</div>
</div>
<a id="ga0defdd750fc8c05846da1e4b56935dab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0defdd750fc8c05846da1e4b56935dab">&#9670;&nbsp;</a></span>ESMGetErrPinLowTimePreload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ESMGetErrPinLowTimePreload </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pLowTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to read the low time counter pre-load value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the ESM Registers.</td></tr>
    <tr><td class="paramname">pLowTime</td><td>pointer to Time to be read as LTCP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS - success <br />
 CSL_EBADARGS - API fails due to bad input arguments</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><br />
 ESM module is reset and initialized for desired operation</dd></dl>
<p>This is the value that will be pre-loaded in to the counter field of the ESM_PIN_CNTR register whenever the ESM enters the ESM_ERROR state from ESM_IDLE. The default value is determined based on the ESM clock frequency, so that there is a minimum low time of 100 micro seconds. This field is only reset by a Power-On-Reset (not warm reset). A global soft reset will set this field to 0h.</p>
<dl class="section post"><dt>Postcondition</dt><dd><br />
 None</dd></dl>
<p><b>Example</b> </p><pre class="fragment">    uint32_t            baseAddr = CSL_MCU_ESM0_CFG_BASE;
    uint32_t            inCntrPre;
    int32_t             cslRet;
    cslRet = ESMGetErrPinLowTimePreload (baseAddr, &amp;inCntrPre);</pre> 
</div>
</div>
<a id="gab0f036f26cb65270ac0e4b62b029a9ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0f036f26cb65270ac0e4b62b029a9ba">&#9670;&nbsp;</a></span>ESMGetCurrErrPinLowTimeCnt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ESMGetCurrErrPinLowTimeCnt </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pPinCntrPre</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to get the current value of low time counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the ESM Registers.</td></tr>
    <tr><td class="paramname">pPinCntrPre</td><td>pointer to Counter value Current low time count.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS - success <br />
 CSL_EBADARGS - API fails due to bad input arguments</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><br />
 ESM module is reset and initialized for desired operation</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><br />
 None</dd></dl>
<p><b>Example</b> </p><pre class="fragment">    uint32_t            baseAddr = CSL_MCU_ESM0_CFG_BASE;
    uint32_t            pinCntrPre;
    int32_t             cslRet;
    cslRet  = ESMGetCurrErrPinLowTimeCnt (baseAddr, &amp;pinCntrPre);</pre> 
</div>
</div>
<a id="gab00fe641aed938e7d7ed8f903f16a503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab00fe641aed938e7d7ed8f903f16a503">&#9670;&nbsp;</a></span>ESMGetErrPinStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ESMGetErrPinStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to get the current status of nERROR pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the ESM Registers.</td></tr>
    <tr><td class="paramname">pStatus</td><td>pointer to Current nERROR pin status.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS - success <br />
 CSL_EBADARGS - API fails due to bad input arguments</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><br />
 ESM module is reset and initialized for desired operation</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><br />
 None</dd></dl>
<p><b>Example</b> </p><pre class="fragment">    uint32_t            baseAddr = CSL_MCU_ESM0_CFG_BASE;
    uint32_t            status;
    uint32_t            cslRet;
    cslRet = ESMGetErrPinStatus (baseAddr, &amp;status);</pre> 
</div>
</div>
<a id="gaaca71033c4f04171188ac44bee22d86e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaca71033c4f04171188ac44bee22d86e">&#9670;&nbsp;</a></span>ESMResetErrPin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ESMResetErrPin </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to reset the nERROR pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the ESM Registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS - success <br />
 CSL_EBADARGS - API fails due to bad input arguments</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This will set the nERROR pin to high.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><br />
 ESM module is reset and initialized for desired operation</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><br />
 None</dd></dl>
<p><b>Example</b> </p><pre class="fragment">    uint32_t            baseAddr = CSL_MCU_ESM0_CFG_BASE;
    int32_t             cslRet;
    cslRet = ESMResetErrPin (baseAddr);</pre> 
</div>
</div>
<a id="ga7915fc345ceb6ad94efddc6e92a70d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7915fc345ceb6ad94efddc6e92a70d2b">&#9670;&nbsp;</a></span>ESMIsEnableIntr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ESMIsEnableIntr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pEnStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used check if interrupt is enabled/disabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the ESM Registers.</td></tr>
    <tr><td class="paramname">intrSrc</td><td>Interrupt to enable.</td></tr>
    <tr><td class="paramname">pEnStatus</td><td>Pointer to status of interrupt enable variable</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS - success <br />
 CSL_EBADARGS - API fails due to bad input arguments</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><br />
 ESM module is reset and initialized for desired operation</dd></dl>
<p>Note: the intrSrc check is only at the IP level max and not done at instance level, so it is expected to be done at higher layer.</p>
<dl class="section post"><dt>Postcondition</dt><dd><br />
 None</dd></dl>
<p><b>Example</b> </p><pre class="fragment">    uint32_t            baseAddr = CSL_MCU_ESM0_CFG_BASE;
    uint32_t            status, intrNum  = 0u;
    int32_t             cslRet;
    cslRet = ESMIsEnableIntr (baseAddr, intrNum, &amp;status);</pre> 
</div>
</div>
<a id="gaa8626ff17a04e6290d208c0196b6e543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8626ff17a04e6290d208c0196b6e543">&#9670;&nbsp;</a></span>ESMEnableIntr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ESMEnableIntr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to enable interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the ESM Registers.</td></tr>
    <tr><td class="paramname">intrNum</td><td>Interrupt to enable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS - success <br />
 CSL_EBADARGS - API fails due to bad input arguments</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><br />
 ESM module is reset and initialized for desired operation</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><br />
 None</dd></dl>
<p><b>Example</b> </p><pre class="fragment">    uint32_t            baseAddr = CSL_MCU_ESM0_CFG_BASE;
    uint32_t            intrNum  = 0u;
    int32_t             status;
    status = ESMEnableIntr (baseAddr, intrNum);</pre> 
</div>
</div>
<a id="ga4ec4726b706f5cb1770271dd5f4023ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ec4726b706f5cb1770271dd5f4023ca">&#9670;&nbsp;</a></span>ESMDisableIntr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ESMDisableIntr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to disable interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the ESM Registers.</td></tr>
    <tr><td class="paramname">intrNum</td><td>Interrupt to disable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS - success <br />
 CSL_EBADARGS - API fails due to bad input arguments</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><br />
 None</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><br />
 None</dd></dl>
<p><b>Example</b> </p><pre class="fragment">    uint32_t            baseAddr = CSL_MCU_ESM0_CFG_BASE;
    uint32_t            intrNum  = 0u;
    int32_t             cslRet;
    cslRet = ESMSetInfluenceOnErrPin (baseAddr, intrNum);</pre> 
</div>
</div>
<a id="gacec6a537b28d41c84985e182665a29c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacec6a537b28d41c84985e182665a29c6">&#9670;&nbsp;</a></span>ESMSetIntrPriorityLvl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ESMSetIntrPriorityLvl </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CSL__ESM__ENUM.html#ga06f41023eabd3866b6e7cff0476f84e8">esmIntrPriorityLvl_t</a>&#160;</td>
          <td class="paramname"><em>intrPriorityLvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to set interrupt level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the ESM Registers.</td></tr>
    <tr><td class="paramname">intrSrc</td><td>Interrupt to set the level.</td></tr>
    <tr><td class="paramname">intrPriorityLvl</td><td>Interrupt level to set. Refer enum <a class="el" href="group__CSL__ESM__ENUM.html#ga06f41023eabd3866b6e7cff0476f84e8" title="ESM Interrupt Priority Levels.">esmIntrPriorityLvl_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS - success <br />
 CSL_EBADARGS - API fails due to bad input arguments</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><br />
 ESM module is reset and initialized for desired operation</dd></dl>
<p>Note: the intrSrc check is only at the IP level max and not done at instance level, so it is expected to be done at higher layer.</p>
<dl class="section post"><dt>Postcondition</dt><dd><br />
 None</dd></dl>
<p><b>Example</b> </p><pre class="fragment">    uint32_t            baseAddr = CSL_MCU_ESM0_CFG_BASE;
    uint32_t            intrSrc  = CSL_ESM1_INTR_MCU0_CPU0_ECC_CORRECTED_LEVEL;
    esmIntrPriorityLvl_t pri     = ESM_INTR_PRIORITY_LEVEL_HIGH;
    int32_t             cslRet;
    cslRet = ESMSetIntrPriorityLvl (baseAddr, intrSrc, pri);</pre> 
</div>
</div>
<a id="gabb4735c9c694628d5f47e55aaf115b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb4735c9c694628d5f47e55aaf115b3a">&#9670;&nbsp;</a></span>ESMGetIntrPriorityLvl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ESMGetIntrPriorityLvl </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CSL__ESM__ENUM.html#ga06f41023eabd3866b6e7cff0476f84e8">esmIntrPriorityLvl_t</a> *&#160;</td>
          <td class="paramname"><em>pIntrPriorityLvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to get interrupt level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the ESM Registers.</td></tr>
    <tr><td class="paramname">intrSrc</td><td>Interrupt to set the level.</td></tr>
    <tr><td class="paramname">pIntrPriorityLvl</td><td>Pointer to Interrupt level to get. Refer enum <a class="el" href="group__CSL__ESM__ENUM.html#ga06f41023eabd3866b6e7cff0476f84e8" title="ESM Interrupt Priority Levels.">esmIntrPriorityLvl_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS - success <br />
 CSL_EBADARGS - API fails due to bad input arguments</dd></dl>
<p>Note: the intrSrc check is only at the IP level max and not done at instance level, so it is expected to be done at higher layer.</p>
<dl class="section pre"><dt>Precondition</dt><dd><br />
 ESM module is reset and initialized for desired operation</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><br />
 None</dd></dl>
<p><b>Example</b> </p><pre class="fragment">    uint32_t            baseAddr = CSL_MCU_ESM0_CFG_BASE;
    uint32_t            intrSrc  = CSL_ESM1_INTR_MCU0_CPU0_ECC_CORRECTED_LEVEL;
    esmIntrPriorityLvl_t            pri;
    int32_t             cslRet;
    cslRet = ESMGetIntrPriorityLvl (baseAddr, intrSrc, &amp;pri);</pre> 
</div>
</div>
<a id="gab6bf58c63a0251b89e74f205d0564edd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6bf58c63a0251b89e74f205d0564edd">&#9670;&nbsp;</a></span>ESMGetIntrStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ESMGetIntrStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pStaus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to get the interrupt status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the ESM Registers.</td></tr>
    <tr><td class="paramname">intrSrc</td><td>Interrupt for which status to return.</td></tr>
    <tr><td class="paramname">pStaus</td><td>pointer to interrupt status</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS - success <br />
 CSL_EBADARGS - API fails due to bad input arguments</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><br />
 ESM module is reset and initialized for desired operation</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><br />
 None</dd></dl>
<p>Note: the intrSrc check is only at the IP level max and not done at instance level, so it is expected to be done at higher layer.</p>
<p><b>Example</b> </p><pre class="fragment">    uint32_t            baseAddr = CSL_MCU_ESM0_CFG_BASE;
    uint32_t            status, intrSrc  = CSL_ESM1_INTR_MCU0_CPU0_ECC_CORRECTED_LEVEL;
    int32_t             cslRet;
    cslRet = ESMGetIntrStatus (baseAddr, intrSrc, &amp;status);</pre> 
</div>
</div>
<a id="ga64b5a23f1b0d65606a008c4d45677279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64b5a23f1b0d65606a008c4d45677279">&#9670;&nbsp;</a></span>ESMSetIntrStatusRAW()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ESMSetIntrStatusRAW </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to set the interrupt RAW status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the ESM Registers.</td></tr>
    <tr><td class="paramname">intrSrc</td><td>Interrupt for which status to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS - success <br />
 CSL_EBADARGS - API fails due to bad input arguments</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><br />
 ESM module is reset and initialized for desired operation</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><br />
 None</dd></dl>
<p>Note: the intrSrc check is only at the IP level max and not done at instance level, so it is expected to be done at higher layer.</p>
<p><b>Example</b> </p><pre class="fragment">    uint32_t            baseAddr = CSL_MCU_ESM0_CFG_BASE;
    uint32_t            intrSrc  = CSL_ESM1_INTR_MCU0_CPU0_ECC_CORRECTED_LEVEL;
    int32_t             cslRet;
    cslRet = ESMSetIntrStatusRAW (baseAddr, intrSrc);</pre> 
</div>
</div>
<a id="gaf7d0077164154c6e5bacba0f110726ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7d0077164154c6e5bacba0f110726ae">&#9670;&nbsp;</a></span>ESMGetIntrStatusRAW()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ESMGetIntrStatusRAW </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to get the interrupt RAW status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the ESM Registers.</td></tr>
    <tr><td class="paramname">intrSrc</td><td>Interrupt for which status to return.</td></tr>
    <tr><td class="paramname">pStatus</td><td>pointer to Interrupt status.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS - success <br />
 CSL_EBADARGS - API fails due to bad input arguments</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><br />
 ESM module is reset and initialized for desired operation</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><br />
 None</dd></dl>
<p>Note: the intrSrc check is only at the IP level max and not done at instance level, so it is expected to be done at higher layer.</p>
<p><b>Example</b> </p><pre class="fragment">    uint32_t            baseAddr = CSL_MCU_ESM0_CFG_BASE;
    uint32_t            intrSrc  = CSL_ESM1_INTR_MCU0_CPU0_ECC_CORRECTED_LEVEL;
    uitn32_t            status;
    int32_t             cslRet;
    cslRet = ESMGetIntrStatusRAW (baseAddr, intrSrc, &amp;status);</pre> 
</div>
</div>
<a id="gabb94fff01ab87d17fdd375beebe94f14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb94fff01ab87d17fdd375beebe94f14">&#9670;&nbsp;</a></span>ESMGetGroupIntrStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ESMGetGroupIntrStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CSL__ESM__ENUM.html#ga06f41023eabd3866b6e7cff0476f84e8">esmIntrPriorityLvl_t</a>&#160;</td>
          <td class="paramname"><em>intrPrioType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structesmGroupIntrStatus__t.html">esmGroupIntrStatus_t</a> *&#160;</td>
          <td class="paramname"><em>pIntrstatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to get the interrupt/error status for a group. This will also return highest pending interrupt for pulse as well as for level interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the ESM Registers.</td></tr>
    <tr><td class="paramname">intrPrioType</td><td>Group for which status to return. Refer enum <a class="el" href="group__CSL__ESM__ENUM.html#ga06f41023eabd3866b6e7cff0476f84e8" title="ESM Interrupt Priority Levels.">esmIntrPriorityLvl_t</a>.</td></tr>
    <tr><td class="paramname">pIntrstatus</td><td>pointer to Interrupt status. Refer struct <a class="el" href="structesmGroupIntrStatus__t.html" title="Structure to access the status of interrupts belonging to a High or Low priority interrupt.">esmGroupIntrStatus_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS - success <br />
 CSL_EBADARGS - API fails due to bad input arguments</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><br />
 ESM module is reset and initialized for desired operation</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><br />
 None</dd></dl>
<p><b>Example</b> </p><pre class="fragment">    uint32_t            baseAddr = CSL_MCU_ESM0_CFG_BASE;
    esmIntrPriorityLvl  priType  = ESM_INTR_PRIORITY_LEVEL_HIGH;
    esmGroupIntrStatus_t groupIntrStatus;
    int32_t             cslRet;

    cslRet = ESMGetGroupIntrStatus (baseAddr, priType, &amp;groupIntrStatus);</pre> 
</div>
</div>
<a id="ga0a215eae668b1286e206f08332479ffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a215eae668b1286e206f08332479ffb">&#9670;&nbsp;</a></span>ESMClearIntrStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ESMClearIntrStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to clear the interrupt status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the ESM Registers.</td></tr>
    <tr><td class="paramname">intrSrc</td><td>Interrupt to clear status.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS - success <br />
 CSL_EBADARGS - API fails due to bad input arguments</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><br />
 ESM module is reset and initialized for desired operation</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><br />
 None</dd></dl>
<p>Note: the intrSrc check is only at the IP level max and not done at instance level, so it is expected to be done at higher layer.</p>
<p><b>Example</b> </p><pre class="fragment">    uint32_t            baseAddr = CSL_MCU_ESM0_CFG_BASE;
    uint32_t            intrSrc  = CSL_ESM1_INTR_MCU0_CPU0_ECC_CORRECTED_LEVEL;
    int32_t             cslRet;
    cslRet = ESMClearIntrStatus (baseAddr, intrSrc);</pre> 
</div>
</div>
<a id="ga7abf3be2629dd10637cbdb7f0fc8d831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7abf3be2629dd10637cbdb7f0fc8d831">&#9670;&nbsp;</a></span>ESMWriteEOI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ESMWriteEOI </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CSL__ESM__ENUM.html#gafb60e72332cf0a99eb2107688a0cae14">esmIntrType_t</a>&#160;</td>
          <td class="paramname"><em>intrType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to write EOI. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the ESM Registers.</td></tr>
    <tr><td class="paramname">intrType</td><td>Type of interrupt for which to write EOI. Refer enum <a class="el" href="group__CSL__ESM__ENUM.html#gafb60e72332cf0a99eb2107688a0cae14" title="ESM Interrupt Type to select level for interrupt.">esmIntrType_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS - success <br />
 CSL_EBADARGS - API fails due to bad input arguments</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><br />
 ESM module is reset and initialized for desired operation</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><br />
 None</dd></dl>
<p><b>Example</b> </p><pre class="fragment">    uint32_t            baseAddr = CSL_MCU_ESM0_CFG_BASE;
    esmIntrType_t       intrType  = ESM_INTR_TYPE_HIGH_PRIO_ERROR;
    int32_t             cslRet;
    cslRet = ESMWriteEOI (baseAddr, intrType);</pre> 
</div>
</div>
<a id="ga9ff7375db409a4297858502824c1153b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ff7375db409a4297858502824c1153b">&#9670;&nbsp;</a></span>ESMGetRevisionId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ESMGetRevisionId </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structesmRevisionId__t.html">esmRevisionId_t</a> *&#160;</td>
          <td class="paramname"><em>pRevId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used get the ESM revision ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the ESM Registers.</td></tr>
    <tr><td class="paramname">pRevId</td><td>Pointer to Revision ID of ESM module.. Refer struct <a class="el" href="structesmRevisionId__t.html" title="Structure for accessing Revision ID of ESM module.">esmRevisionId_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS - success <br />
 CSL_EBADARGS - API fails due to bad input arguments</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><br />
 ESM module is reset and initialized for desired operation</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><br />
 None</dd></dl>
<p><b>Example</b> </p><pre class="fragment">    uint32_t            baseAddr = CSL_MCU_ESM0_CFG_BASE;
    esmRevisionId_t     revId;
    int32_t             cslRet;
    cslRet = ESMGetRevisionId (baseAddr, &amp;revId);</pre> 
</div>
</div>
<a id="gab0c5b45366ef756261a65fbcb873d353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0c5b45366ef756261a65fbcb873d353">&#9670;&nbsp;</a></span>ESMGetInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ESMGetInfo </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structesmInfo__t.html">esmInfo_t</a> *&#160;</td>
          <td class="paramname"><em>pInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used read the ESM information register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the ESM Registers.</td></tr>
    <tr><td class="paramname">pInfo</td><td>pointer to variable that Contains information register contents of ESM module.. Refer struct <a class="el" href="structesmInfo__t.html" title="Structure for accessing information register of ESM module.">esmInfo_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS - success <br />
 CSL_EBADARGS - API fails due to bad input arguments</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><br />
 None</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><br />
 None</dd></dl>
<p><b>Example</b> </p><pre class="fragment">    uint32_t            baseAddr = CSL_MCU_ESM0_CFG_BASE;
    esmInfo_t           esmInfo;
    int32_t             cslRet;
    cslRet = ESMGetInfo (baseAddr, &amp;esmInfo);</pre> 
</div>
</div>
<a id="gac01a6cb321ed85ea66d50356b5298f3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac01a6cb321ed85ea66d50356b5298f3c">&#9670;&nbsp;</a></span>ESMGetGlobalIntrEnabledStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ESMGetGlobalIntrEnabledStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used read the ESM information register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the ESM Registers.</td></tr>
    <tr><td class="paramname">pStatus</td><td>pointer to is global Interrupt enabled status 0h: all interrupts are enabled Fh: all interrupts are disabled -others: interrupts are in invalid state.Software should never write these values. If these values are ever read, they indicate that an error has occurred. In this state, all interrupts are enabled (biased to false enable).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS - success <br />
 CSL_EBADARGS - API fails due to bad input arguments</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><br />
 None</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><br />
 None</dd></dl>
<p><b>Example</b> </p><pre class="fragment">    uint32_t            baseAddr = CSL_MCU_ESM0_CFG_BASE;
    uint32_t            enStatus;
    int32_t             cslRet;
    cslRet = ESMGetGlobalIntrEnabledStatus (baseAddr, &amp;enStatus);</pre> 
</div>
</div>
<a id="ga4c78a748afcb5fc1ccb9d5c2695f33d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c78a748afcb5fc1ccb9d5c2695f33d8">&#9670;&nbsp;</a></span>ESMEnableGlobalIntr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ESMEnableGlobalIntr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to enable Global control of interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the ESM Registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS - success <br />
 CSL_EBADARGS - API fails due to bad input arguments</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><br />
 ESM module is reset and initialized for desired operation</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><br />
 None</dd></dl>
<p><b>Example</b> </p><pre class="fragment">    uint32_t            baseAddr = CSL_MCU_ESM0_CFG_BASE;
    int32_t             cslRet;
    cslRet = ESMEnableGlobalIntr (baseAddr);</pre> 
</div>
</div>
<a id="gabcec7663af7ea265599a24c518f91c94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcec7663af7ea265599a24c518f91c94">&#9670;&nbsp;</a></span>ESMDisableGlobalIntr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ESMDisableGlobalIntr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to disable Global control of interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the ESM Registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS - success <br />
 CSL_EBADARGS - API fails due to bad input arguments</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><br />
 ESM module is reset and initialized for desired operation</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><br />
 None</dd></dl>
<p><b>Example</b> </p><pre class="fragment">    uint32_t            baseAddr = CSL_MCU_ESM0_CFG_BASE;
    uint32_t            cslRet;
    cslRet = ESMDisableGlobalIntr (baseAddr);</pre> 
</div>
</div>
<a id="gaf43491d7de4d9f0eade112d2e743aa9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf43491d7de4d9f0eade112d2e743aa9e">&#9670;&nbsp;</a></span>ESMReset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ESMReset </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to reset ESM module. Reset is used to reset all enables and raw status bits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the ESM Registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS - success <br />
 CSL_EBADARGS - API fails due to bad input arguments</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><br />
 None</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><br />
 None</dd></dl>
<p><b>Example</b> </p><pre class="fragment">    uint32_t            baseAddr = CSL_MCU_ESM0_CFG_BASE;
    uint32_t            cslRet;
    cslRet = ESMReset (baseAddr);</pre> 
</div>
</div>
<a id="ga665947c3075020ac844dc74750eecf52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga665947c3075020ac844dc74750eecf52">&#9670;&nbsp;</a></span>ESMReadStaticRegs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ESMReadStaticRegs </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCSL__esmStaticRegs.html">CSL_esmStaticRegs</a> *&#160;</td>
          <td class="paramname"><em>pStaticRegs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to read static registers of ESM module. This API needs to be called after the initial configuration is done and hence mutliple read between static registers do not change the values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the ESM Registers.</td></tr>
    <tr><td class="paramname">pStaticRegs</td><td>pointer to static registers to be read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS - success <br />
 CSL_EBADARGS - API fails due to bad input arguments</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><br />
 None</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><br />
 None</dd></dl>
<p><b>Example</b> </p><pre class="fragment">    uint32_t            baseAddr = (uint32_t)CSL_MCU_ESM0_CFG_BASE;
    CSL_esmStaticRegs   staticRegs;
    uint32_t            cslRet;
    cslRet = ESMReadStaticRegs (baseAddr, &amp;staticRegs);</pre> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
