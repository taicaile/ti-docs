<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<title>PDK API Guide for J721S2: OSPI Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ti_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PDK API Guide for J721S2
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__CSL__OSPI__FUNCTION.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">OSPI Functions<div class="ingroups"><a class="el" href="group__CSL__IP__MODULE.html">CSL-FL</a> &raquo; <a class="el" href="group__CSL__OSPI__API.html">Octal SPI (OSPI) API</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Introduction</h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0ca29f9065be052e3d4621b5326f2496"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#ga0ca29f9065be052e3d4621b5326f2496">CSL_ospiEnable</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t enable)</td></tr>
<tr class="memdesc:ga0ca29f9065be052e3d4621b5326f2496"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables/disables the OSPI By definition, target can handle read/write transaction as long as it is enabled.  <a href="#ga0ca29f9065be052e3d4621b5326f2496">More...</a><br /></td></tr>
<tr class="separator:ga0ca29f9065be052e3d4621b5326f2496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf34bfba7f2dd973ea3468b368e4402c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#gaf34bfba7f2dd973ea3468b368e4402c1">CSL_ospiDacEnable</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t enable)</td></tr>
<tr class="memdesc:gaf34bfba7f2dd973ea3468b368e4402c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables/disables the OSPI Direct Access Controller.  <a href="#gaf34bfba7f2dd973ea3468b368e4402c1">More...</a><br /></td></tr>
<tr class="separator:gaf34bfba7f2dd973ea3468b368e4402c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9eee95f2222f1d401c3cde516e39b416"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#ga9eee95f2222f1d401c3cde516e39b416">CSL_ospiXipEnable</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t enable)</td></tr>
<tr class="memdesc:ga9eee95f2222f1d401c3cde516e39b416"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables/disables the OSPI XIP Controller.  <a href="#ga9eee95f2222f1d401c3cde516e39b416">More...</a><br /></td></tr>
<tr class="separator:ga9eee95f2222f1d401c3cde516e39b416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a375d1f28314f083690676d96632527"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#ga0a375d1f28314f083690676d96632527">CSL_ospiSetModeBits</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t flashModeVal)</td></tr>
<tr class="memdesc:ga0a375d1f28314f083690676d96632527"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the Mode bits which are sent to the device following address.  <a href="#ga0a375d1f28314f083690676d96632527">More...</a><br /></td></tr>
<tr class="separator:ga0a375d1f28314f083690676d96632527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac08ebdeec5cabc3cc1554ac5d5d5e35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#gaac08ebdeec5cabc3cc1554ac5d5d5e35">CSL_ospiPhyEnable</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t enable)</td></tr>
<tr class="memdesc:gaac08ebdeec5cabc3cc1554ac5d5d5e35"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables/disables the OSPI PHY mode.  <a href="#gaac08ebdeec5cabc3cc1554ac5d5d5e35">More...</a><br /></td></tr>
<tr class="separator:gaac08ebdeec5cabc3cc1554ac5d5d5e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8f685360ebe54c6d25dcea95f6e2c2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#gad8f685360ebe54c6d25dcea95f6e2c2b">CSL_ospiPipelinePhyEnable</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t enable)</td></tr>
<tr class="memdesc:gad8f685360ebe54c6d25dcea95f6e2c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables/disables the OSPI pipeline PHY mode.  <a href="#gad8f685360ebe54c6d25dcea95f6e2c2b">More...</a><br /></td></tr>
<tr class="separator:gad8f685360ebe54c6d25dcea95f6e2c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7b2f979833c68008e8275359a7c5696"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#gad7b2f979833c68008e8275359a7c5696">CSL_ospiDtrEnable</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t enable)</td></tr>
<tr class="memdesc:gad7b2f979833c68008e8275359a7c5696"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables/disables the OSPI DTR protocol.  <a href="#gad7b2f979833c68008e8275359a7c5696">More...</a><br /></td></tr>
<tr class="separator:gad7b2f979833c68008e8275359a7c5696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98118c36736e83d50035ac4c26303bc0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#ga98118c36736e83d50035ac4c26303bc0">CSL_ospiSetPreScaler</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t clkDividerVal)</td></tr>
<tr class="memdesc:ga98118c36736e83d50035ac4c26303bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the OSPI clock register divider value.  <a href="#ga98118c36736e83d50035ac4c26303bc0">More...</a><br /></td></tr>
<tr class="separator:ga98118c36736e83d50035ac4c26303bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98d28ce8d5131efb20a3c321211339db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#ga98d28ce8d5131efb20a3c321211339db">CSL_ospiSetClkMode</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t clkMode)</td></tr>
<tr class="memdesc:ga98d28ce8d5131efb20a3c321211339db"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configures the OSPI to work in different clock modes.  <a href="#ga98d28ce8d5131efb20a3c321211339db">More...</a><br /></td></tr>
<tr class="separator:ga98d28ce8d5131efb20a3c321211339db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga589aeb7f02f905f6697f6a7dbce13b8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#ga589aeb7f02f905f6697f6a7dbce13b8b">CSL_ospiSetChipSelect</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t chipSelect, uint32_t decSelect)</td></tr>
<tr class="memdesc:ga589aeb7f02f905f6697f6a7dbce13b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configures the chip select polarity for a selected chip select. This can only be done if OSPI module is not busy.  <a href="#ga589aeb7f02f905f6697f6a7dbce13b8b">More...</a><br /></td></tr>
<tr class="separator:ga589aeb7f02f905f6697f6a7dbce13b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fe08c94de5bd08d0f793f37577d2e48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#ga1fe08c94de5bd08d0f793f37577d2e48">CSL_ospiSetDevDelay</a> (const CSL_ospi_flash_cfgRegs *pRegs, const uint32_t *delays)</td></tr>
<tr class="memdesc:ga1fe08c94de5bd08d0f793f37577d2e48"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configures the device delays This can only be done if OSPI controller is idle.  <a href="#ga1fe08c94de5bd08d0f793f37577d2e48">More...</a><br /></td></tr>
<tr class="separator:ga1fe08c94de5bd08d0f793f37577d2e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae599049affdf8d90ef2d184c888bab06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#gae599049affdf8d90ef2d184c888bab06">CSL_ospiSetDevSize</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t numAddrBytes, uint32_t pageSize, uint32_t blkSize)</td></tr>
<tr class="memdesc:gae599049affdf8d90ef2d184c888bab06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set device size configrations.  <a href="#gae599049affdf8d90ef2d184c888bab06">More...</a><br /></td></tr>
<tr class="separator:gae599049affdf8d90ef2d184c888bab06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d8c6666c8fec4398c9095db6302566c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#ga1d8c6666c8fec4398c9095db6302566c">CSL_ospiSetIndTrigAddr</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t indTrigAddr)</td></tr>
<tr class="memdesc:ga1d8c6666c8fec4398c9095db6302566c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Indirect Trigger Address.  <a href="#ga1d8c6666c8fec4398c9095db6302566c">More...</a><br /></td></tr>
<tr class="separator:ga1d8c6666c8fec4398c9095db6302566c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2857f30dcc253ce15e3df2ea51895235"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#ga2857f30dcc253ce15e3df2ea51895235">CSL_ospiSetWrCompAutoPolling</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t pollingState)</td></tr>
<tr class="memdesc:ga2857f30dcc253ce15e3df2ea51895235"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set write completion auto polling configuration.  <a href="#ga2857f30dcc253ce15e3df2ea51895235">More...</a><br /></td></tr>
<tr class="separator:ga2857f30dcc253ce15e3df2ea51895235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b75fe940458003e1ef5023e8d3fa1a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#ga0b75fe940458003e1ef5023e8d3fa1a3">CSL_ospiSetPollingDummyCycles</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t dummyCycles)</td></tr>
<tr class="memdesc:ga0b75fe940458003e1ef5023e8d3fa1a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set write completion auto polling configuration.  <a href="#ga0b75fe940458003e1ef5023e8d3fa1a3">More...</a><br /></td></tr>
<tr class="separator:ga0b75fe940458003e1ef5023e8d3fa1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf747a3b701c1bc77706bf02c1df9fa17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#gaf747a3b701c1bc77706bf02c1df9fa17">CSL_ospiSetSramPartition</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t partition)</td></tr>
<tr class="memdesc:gaf747a3b701c1bc77706bf02c1df9fa17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set SRAM partition configuration.  <a href="#gaf747a3b701c1bc77706bf02c1df9fa17">More...</a><br /></td></tr>
<tr class="separator:gaf747a3b701c1bc77706bf02c1df9fa17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf5923f3cd1c4defd291e543c829422e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#gabf5923f3cd1c4defd291e543c829422e">CSL_ospiIntrEnable</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t intrFlag, uint32_t enable)</td></tr>
<tr class="memdesc:gabf5923f3cd1c4defd291e543c829422e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This Function enables/diables only specified OSPI interrupts.  <a href="#gabf5923f3cd1c4defd291e543c829422e">More...</a><br /></td></tr>
<tr class="separator:gabf5923f3cd1c4defd291e543c829422e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga632be9b0cc0676c8fbde7b8f69db4c28"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#ga632be9b0cc0676c8fbde7b8f69db4c28">CSL_ospiIntrStatus</a> (const CSL_ospi_flash_cfgRegs *pRegs)</td></tr>
<tr class="memdesc:ga632be9b0cc0676c8fbde7b8f69db4c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the status of interrupts. It specifies whether an interrupt is active or inactive. After an interrupt is serviced, the software must set to 0 the corresponding flag in the interrupt status register.  <a href="#ga632be9b0cc0676c8fbde7b8f69db4c28">More...</a><br /></td></tr>
<tr class="separator:ga632be9b0cc0676c8fbde7b8f69db4c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga262e95f450ff6d9b9a95556535e1fdca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#ga262e95f450ff6d9b9a95556535e1fdca">CSL_ospiIntrClear</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t intrFlag)</td></tr>
<tr class="memdesc:ga262e95f450ff6d9b9a95556535e1fdca"><td class="mdescLeft">&#160;</td><td class="mdescRight">This Function clears the status of specified interrupts.  <a href="#ga262e95f450ff6d9b9a95556535e1fdca">More...</a><br /></td></tr>
<tr class="separator:ga262e95f450ff6d9b9a95556535e1fdca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga754389cfe8f87f2d5876946b901a1365"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#ga754389cfe8f87f2d5876946b901a1365">CSL_ospiGetSramLvl</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t read)</td></tr>
<tr class="memdesc:ga754389cfe8f87f2d5876946b901a1365"><td class="mdescLeft">&#160;</td><td class="mdescRight">This Function gets the OSPI SRAM FIFO fill level bytes.  <a href="#ga754389cfe8f87f2d5876946b901a1365">More...</a><br /></td></tr>
<tr class="separator:ga754389cfe8f87f2d5876946b901a1365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga374e7d32091bbb266a63bc1daeefcb0e"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#ga374e7d32091bbb266a63bc1daeefcb0e">CSL_ospiCmdRead</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t <a class="el" href="gptpipc_8h.html#a2766e0be89a1a57a241e8557b71cf9e1">cmd</a>, uint32_t rxLen)</td></tr>
<tr class="memdesc:ga374e7d32091bbb266a63bc1daeefcb0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read operation in config mode.  <a href="#ga374e7d32091bbb266a63bc1daeefcb0e">More...</a><br /></td></tr>
<tr class="separator:ga374e7d32091bbb266a63bc1daeefcb0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba05f486ce1ca3c1a27069057f2e88fc"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#gaba05f486ce1ca3c1a27069057f2e88fc">CSL_ospiCmdExtRead</a> (const CSL_ospi_flash_cfgRegs *pRegs, const uint8_t *cmdBuf, uint32_t cmdLen, uint32_t rxLen, uint32_t dummyCycles)</td></tr>
<tr class="memdesc:gaba05f486ce1ca3c1a27069057f2e88fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extended opcode read operation in config mode.  <a href="#gaba05f486ce1ca3c1a27069057f2e88fc">More...</a><br /></td></tr>
<tr class="separator:gaba05f486ce1ca3c1a27069057f2e88fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga242b8cf08a3c7df1b70747d7dc889074"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#ga242b8cf08a3c7df1b70747d7dc889074">CSL_ospiCmdWrite</a> (const CSL_ospi_flash_cfgRegs *pRegs, const uint8_t *cmdBuf, uint32_t cmdLen, const uint8_t *txBuf, uint32_t txLen)</td></tr>
<tr class="memdesc:ga242b8cf08a3c7df1b70747d7dc889074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write operation in config mode.  <a href="#ga242b8cf08a3c7df1b70747d7dc889074">More...</a><br /></td></tr>
<tr class="separator:ga242b8cf08a3c7df1b70747d7dc889074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c9a1d8db873f6053a03f49ec800e243"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#ga6c9a1d8db873f6053a03f49ec800e243">CSL_ospiConfigRead</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t <a class="el" href="gptpipc_8h.html#a2766e0be89a1a57a241e8557b71cf9e1">cmd</a>, uint32_t <a class="el" href="tisci__rm__ra_8h.html#a37e90f5e3bd99fac2021fb3a326607d4">mode</a>, uint32_t dummyClk)</td></tr>
<tr class="memdesc:ga6c9a1d8db873f6053a03f49ec800e243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup read operation transfer mode.  <a href="#ga6c9a1d8db873f6053a03f49ec800e243">More...</a><br /></td></tr>
<tr class="separator:ga6c9a1d8db873f6053a03f49ec800e243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf786362643a4215db7f13bd389d4050"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#gadf786362643a4215db7f13bd389d4050">CSL_ospiIndReadExecute</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t rxLen)</td></tr>
<tr class="memdesc:gadf786362643a4215db7f13bd389d4050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute read operation in indirect transfer mode.  <a href="#gadf786362643a4215db7f13bd389d4050">More...</a><br /></td></tr>
<tr class="separator:gadf786362643a4215db7f13bd389d4050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d76207f28a007888acf3e820ed332ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#ga5d76207f28a007888acf3e820ed332ad">CSL_ospiClrIndReadComplete</a> (const CSL_ospi_flash_cfgRegs *pRegs)</td></tr>
<tr class="memdesc:ga5d76207f28a007888acf3e820ed332ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear indirect read operation done status.  <a href="#ga5d76207f28a007888acf3e820ed332ad">More...</a><br /></td></tr>
<tr class="separator:ga5d76207f28a007888acf3e820ed332ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b039af1efe8f8d1c8283c546c6546cf"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#ga1b039af1efe8f8d1c8283c546c6546cf">CSL_ospiIndReadComplete</a> (const CSL_ospi_flash_cfgRegs *pRegs)</td></tr>
<tr class="memdesc:ga1b039af1efe8f8d1c8283c546c6546cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if indirect read operation is done.  <a href="#ga1b039af1efe8f8d1c8283c546c6546cf">More...</a><br /></td></tr>
<tr class="separator:ga1b039af1efe8f8d1c8283c546c6546cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1f2bf2c3d39baf80176d8342c249963"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#gaa1f2bf2c3d39baf80176d8342c249963">CSL_ospiReadFifoData</a> (uintptr_t indAddr, uint8_t *dest, uint32_t rdLen)</td></tr>
<tr class="memdesc:gaa1f2bf2c3d39baf80176d8342c249963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from the SRAM FIFO.  <a href="#gaa1f2bf2c3d39baf80176d8342c249963">More...</a><br /></td></tr>
<tr class="separator:gaa1f2bf2c3d39baf80176d8342c249963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22aa9309cf92d103b0a1f9dd6711f152"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#ga22aa9309cf92d103b0a1f9dd6711f152">CSL_ospiWriteSetup</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t <a class="el" href="gptpipc_8h.html#a2766e0be89a1a57a241e8557b71cf9e1">cmd</a>, uint32_t <a class="el" href="tisci__rm__ra_8h.html#a37e90f5e3bd99fac2021fb3a326607d4">mode</a>)</td></tr>
<tr class="memdesc:ga22aa9309cf92d103b0a1f9dd6711f152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup write operation transfer mode.  <a href="#ga22aa9309cf92d103b0a1f9dd6711f152">More...</a><br /></td></tr>
<tr class="separator:ga22aa9309cf92d103b0a1f9dd6711f152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga842c89c830fce446210a8f28fad8b709"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#ga842c89c830fce446210a8f28fad8b709">CSL_ospiIsIndWriteComplete</a> (const CSL_ospi_flash_cfgRegs *pRegs)</td></tr>
<tr class="memdesc:ga842c89c830fce446210a8f28fad8b709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if indirect write operation is done.  <a href="#ga842c89c830fce446210a8f28fad8b709">More...</a><br /></td></tr>
<tr class="separator:ga842c89c830fce446210a8f28fad8b709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1505f040be3c3a65fb105556ec346490"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#ga1505f040be3c3a65fb105556ec346490">CSL_ospiClrIndWriteComplete</a> (const CSL_ospi_flash_cfgRegs *pRegs)</td></tr>
<tr class="memdesc:ga1505f040be3c3a65fb105556ec346490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear indirect write operation done status.  <a href="#ga1505f040be3c3a65fb105556ec346490">More...</a><br /></td></tr>
<tr class="separator:ga1505f040be3c3a65fb105556ec346490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa9e15223a027d32ac41208cacb09f0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#gaaa9e15223a027d32ac41208cacb09f0d">CSL_ospiIndWriteExecute</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t txLen)</td></tr>
<tr class="memdesc:gaaa9e15223a027d32ac41208cacb09f0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute write operation in indirect transfer mode.  <a href="#gaaa9e15223a027d32ac41208cacb09f0d">More...</a><br /></td></tr>
<tr class="separator:gaaa9e15223a027d32ac41208cacb09f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaea41411aa63bc90dd1d968c3e1a79c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#gaaea41411aa63bc90dd1d968c3e1a79c0">CSL_ospiIndWriteCancel</a> (const CSL_ospi_flash_cfgRegs *pRegs)</td></tr>
<tr class="memdesc:gaaea41411aa63bc90dd1d968c3e1a79c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel write operation in indirect transfer mode.  <a href="#gaaea41411aa63bc90dd1d968c3e1a79c0">More...</a><br /></td></tr>
<tr class="separator:gaaea41411aa63bc90dd1d968c3e1a79c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed3f08ca441621893a208a72bfad0b3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#gaed3f08ca441621893a208a72bfad0b3e">CSL_ospiWriteFifoData</a> (uintptr_t indAddr, const uint8_t *src, uint32_t wrLen)</td></tr>
<tr class="memdesc:gaed3f08ca441621893a208a72bfad0b3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to the SRAM FIFO.  <a href="#gaed3f08ca441621893a208a72bfad0b3e">More...</a><br /></td></tr>
<tr class="separator:gaed3f08ca441621893a208a72bfad0b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga815beb57187a9f4ac3ebde81ae00cfa4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#ga815beb57187a9f4ac3ebde81ae00cfa4">CSL_ospiLoopbackClkEnable</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t enable)</td></tr>
<tr class="memdesc:ga815beb57187a9f4ac3ebde81ae00cfa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the adapted loopback clock circuit.  <a href="#ga815beb57187a9f4ac3ebde81ae00cfa4">More...</a><br /></td></tr>
<tr class="separator:ga815beb57187a9f4ac3ebde81ae00cfa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga611c6741d0311e531010fc0ed1177339"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#ga611c6741d0311e531010fc0ed1177339">CSL_ospiIsIdle</a> (const CSL_ospi_flash_cfgRegs *pRegs)</td></tr>
<tr class="memdesc:ga611c6741d0311e531010fc0ed1177339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if OSPI is idle or not.  <a href="#ga611c6741d0311e531010fc0ed1177339">More...</a><br /></td></tr>
<tr class="separator:ga611c6741d0311e531010fc0ed1177339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71f0899a097589bfa2e3aee4f45d4afa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#ga71f0899a097589bfa2e3aee4f45d4afa">CSL_ospiFlashExecCmd</a> (const CSL_ospi_flash_cfgRegs *pRegs)</td></tr>
<tr class="memdesc:ga71f0899a097589bfa2e3aee4f45d4afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Excecute the flash read/write command.  <a href="#ga71f0899a097589bfa2e3aee4f45d4afa">More...</a><br /></td></tr>
<tr class="separator:ga71f0899a097589bfa2e3aee4f45d4afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga511a37812ee2a78374f87eb9dcdd326d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#ga511a37812ee2a78374f87eb9dcdd326d">CSL_ospiFlashExecCmdComplete</a> (const CSL_ospi_flash_cfgRegs *pRegs)</td></tr>
<tr class="memdesc:ga511a37812ee2a78374f87eb9dcdd326d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the flash command execution status.  <a href="#ga511a37812ee2a78374f87eb9dcdd326d">More...</a><br /></td></tr>
<tr class="separator:ga511a37812ee2a78374f87eb9dcdd326d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3c92ecbbbac9bb7636c35ecb961179e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#gae3c92ecbbbac9bb7636c35ecb961179e">CSL_ospiConfigPhy</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t lockCycle, uint32_t masterDelay, const uint32_t *pSlaveDelay)</td></tr>
<tr class="memdesc:gae3c92ecbbbac9bb7636c35ecb961179e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the PHY.  <a href="#gae3c92ecbbbac9bb7636c35ecb961179e">More...</a><br /></td></tr>
<tr class="separator:gae3c92ecbbbac9bb7636c35ecb961179e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8b6057e309b1cac67c243fc3a744749"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#gab8b6057e309b1cac67c243fc3a744749">CSL_ospiFlashStig</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t <a class="el" href="gptpipc_8h.html#a2766e0be89a1a57a241e8557b71cf9e1">cmd</a>, uint32_t <a class="el" href="csl__bcdma_8h.html#a0e89cf6b9f6cd3125470b1bed2b823df">addr</a>, uint32_t <a class="el" href="tisci__rm__psil_8h.html#a1e43bf7d608e87228b625cca2c04d641">data</a>)</td></tr>
<tr class="memdesc:gab8b6057e309b1cac67c243fc3a744749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set configurations for a flash STIG command.  <a href="#gab8b6057e309b1cac67c243fc3a744749">More...</a><br /></td></tr>
<tr class="separator:gab8b6057e309b1cac67c243fc3a744749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f30588b1a0248699ff9c18e7f2e3ff9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#ga0f30588b1a0248699ff9c18e7f2e3ff9">CSL_ospiIndSetStartAddr</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t startAddr, uint32_t read)</td></tr>
<tr class="memdesc:ga0f30588b1a0248699ff9c18e7f2e3ff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the read or wrtie start address in Indirect mode.  <a href="#ga0f30588b1a0248699ff9c18e7f2e3ff9">More...</a><br /></td></tr>
<tr class="separator:ga0f30588b1a0248699ff9c18e7f2e3ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89a949442c7608b5799bb4a728d0ca02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#ga89a949442c7608b5799bb4a728d0ca02">CSL_ospiSetDataReadCapDelay</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t delay)</td></tr>
<tr class="memdesc:ga89a949442c7608b5799bb4a728d0ca02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the read data capture delay.  <a href="#ga89a949442c7608b5799bb4a728d0ca02">More...</a><br /></td></tr>
<tr class="separator:ga89a949442c7608b5799bb4a728d0ca02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae04cb3e20740f4992e17db0f5004e34d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#gae04cb3e20740f4992e17db0f5004e34d">CSL_ospiSetCsSotDelay</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t delay)</td></tr>
<tr class="memdesc:gae04cb3e20740f4992e17db0f5004e34d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Chip Select Start of Transfer delay.  <a href="#gae04cb3e20740f4992e17db0f5004e34d">More...</a><br /></td></tr>
<tr class="separator:gae04cb3e20740f4992e17db0f5004e34d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40abffa106afb0b9e20b1c03d9877c62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#ga40abffa106afb0b9e20b1c03d9877c62">CSL_ospiSetDualByteOpcodeMode</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t opcodeMode)</td></tr>
<tr class="memdesc:ga40abffa106afb0b9e20b1c03d9877c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the dual byte opcode mode.  <a href="#ga40abffa106afb0b9e20b1c03d9877c62">More...</a><br /></td></tr>
<tr class="separator:ga40abffa106afb0b9e20b1c03d9877c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf18b8b99e9cdc9ff53f2187f32fa0a09"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#gaf18b8b99e9cdc9ff53f2187f32fa0a09">CSL_ospiGetDualByteOpcodeMode</a> (const CSL_ospi_flash_cfgRegs *pRegs)</td></tr>
<tr class="memdesc:gaf18b8b99e9cdc9ff53f2187f32fa0a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dual byte opcode mode.  <a href="#gaf18b8b99e9cdc9ff53f2187f32fa0a09">More...</a><br /></td></tr>
<tr class="separator:gaf18b8b99e9cdc9ff53f2187f32fa0a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeac7b4b4b6250aca6bf118ce2ed687af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#gaeac7b4b4b6250aca6bf118ce2ed687af">CSL_ospiExtOpcodeSet</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t opcodeLo, uint32_t opcodeUp)</td></tr>
<tr class="memdesc:gaeac7b4b4b6250aca6bf118ce2ed687af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the dual byte opcode parameters.  <a href="#gaeac7b4b4b6250aca6bf118ce2ed687af">More...</a><br /></td></tr>
<tr class="separator:gaeac7b4b4b6250aca6bf118ce2ed687af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0df624628cd932619c48db663de5fff2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#ga0df624628cd932619c48db663de5fff2">CSL_ospiExtOpcodeGet</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t *opcodeLo, uint32_t *opcodeUp)</td></tr>
<tr class="memdesc:ga0df624628cd932619c48db663de5fff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dual byte opcode parameters.  <a href="#ga0df624628cd932619c48db663de5fff2">More...</a><br /></td></tr>
<tr class="separator:ga0df624628cd932619c48db663de5fff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae69830d64decf38a51b977805c8243cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#gae69830d64decf38a51b977805c8243cd">CSL_ospiConfigPhyDLL</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t txDelay, uint32_t rxDelay, uint32_t opMode, uint32_t lockCycle, uint32_t funcClk)</td></tr>
<tr class="memdesc:gae69830d64decf38a51b977805c8243cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the PHY TX/RX DLL delays.  <a href="#gae69830d64decf38a51b977805c8243cd">More...</a><br /></td></tr>
<tr class="separator:gae69830d64decf38a51b977805c8243cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga899ae1e092e25e8807e6c6f69c438e8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__OSPI__FUNCTION.html#ga899ae1e092e25e8807e6c6f69c438e8c">CSL_ospiPhyResyncDll</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t lockCycle)</td></tr>
<tr class="memdesc:ga899ae1e092e25e8807e6c6f69c438e8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resync the PHY DLLs after configuring the TX delays.  <a href="#ga899ae1e092e25e8807e6c6f69c438e8c">More...</a><br /></td></tr>
<tr class="separator:ga899ae1e092e25e8807e6c6f69c438e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga0ca29f9065be052e3d4621b5326f2496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ca29f9065be052e3d4621b5326f2496">&#9670;&nbsp;</a></span>CSL_ospiEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiEnable </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables/disables the OSPI By definition, target can handle read/write transaction as long as it is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">enable</td><td>[IN] TRUE: enable OSPI to handle read/write transaction FALSE: disable OSPI once current transaction of the data word is complete</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf34bfba7f2dd973ea3468b368e4402c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf34bfba7f2dd973ea3468b368e4402c1">&#9670;&nbsp;</a></span>CSL_ospiDacEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiDacEnable </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables/disables the OSPI Direct Access Controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">enable</td><td>[IN] TRUE: enable OSPI DAC, FALSE: disable OSPI DAC</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9eee95f2222f1d401c3cde516e39b416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9eee95f2222f1d401c3cde516e39b416">&#9670;&nbsp;</a></span>CSL_ospiXipEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiXipEnable </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables/disables the OSPI XIP Controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">enable</td><td>[IN] TRUE: enable OSPI XIP, FALSE: disable OSPI XIP</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0a375d1f28314f083690676d96632527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a375d1f28314f083690676d96632527">&#9670;&nbsp;</a></span>CSL_ospiSetModeBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiSetModeBits </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flashModeVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the Mode bits which are sent to the device following address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">flashModeVal</td><td>[IN] Mode bit value to be set</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaac08ebdeec5cabc3cc1554ac5d5d5e35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac08ebdeec5cabc3cc1554ac5d5d5e35">&#9670;&nbsp;</a></span>CSL_ospiPhyEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiPhyEnable </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables/disables the OSPI PHY mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">enable</td><td>[IN] TRUE: enable OSPI PHY mode FALSE: disable OSPI PHY mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad8f685360ebe54c6d25dcea95f6e2c2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8f685360ebe54c6d25dcea95f6e2c2b">&#9670;&nbsp;</a></span>CSL_ospiPipelinePhyEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiPipelinePhyEnable </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables/disables the OSPI pipeline PHY mode. </p>
<p>Enable PHY Pipeline when user needs to read at least four AHB 4-byte-sized words (16 bytes) in a sequential manner. Hence PHY is supported only when either DMA or Cache is enabled in the system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">enable</td><td>[IN] TRUE: enable OSPI pipeline PHY mode FALSE: disable OSPI pipeline PHY mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad7b2f979833c68008e8275359a7c5696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7b2f979833c68008e8275359a7c5696">&#9670;&nbsp;</a></span>CSL_ospiDtrEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiDtrEnable </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables/disables the OSPI DTR protocol. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">enable</td><td>[IN] TRUE: enable OSPI DTR protocol FALSE: disable OSPI DTR protocol</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga98118c36736e83d50035ac4c26303bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98118c36736e83d50035ac4c26303bc0">&#9670;&nbsp;</a></span>CSL_ospiSetPreScaler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiSetPreScaler </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clkDividerVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the OSPI clock register divider value. </p>
<p>This function sets the OSPI clock control register with serial data clock divider ratio (DCLK_DIV) according to the input clock provided and the output clock required. DCLK_DIV = ((input clock) / (output clock)) - 1. This function also enables the clock for OSPI module. This can only be done if OSPI module is not busy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">clkDividerVal</td><td>[IN] clock divider value to be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga98d28ce8d5131efb20a3c321211339db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98d28ce8d5131efb20a3c321211339db">&#9670;&nbsp;</a></span>CSL_ospiSetClkMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiSetClkMode </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clkMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configures the OSPI to work in different clock modes. </p>
<p>The combination of Clock phase and clock polarity creates the SPI mode. Most serial flash devices support only mode 0 and mode 3. Changing the clock polarity also swaps the transmit/receive clock edge relationship. If a slave device states that it receives data on the rising edge and transmits on the falling edge of the clock, then it can only support mode 0 or 3. This can only be done if OSPI module is not busy.</p>
<p>The 4 possible modes are :</p>
<p>CKP CKPH Description 0 0 Data input captured on rising edge of ospi1_sclk clock. Data output generated on falling edge of ospi1_sclk clock 0 1 Data input captured on falling edge of ospi1_sclk clock. Data output generate on rising edge of ospi1_sclk clock 1 0 Data input captured on falling edge of ospi1_sclk clock. Data output generated on rising edge of ospi1_sclk clock 1 1 Data input captured on rising edge of ospi1_sclk clock. Data output generated on falling edge of ospi1_sclk clock</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">clkMode</td><td>[IN] Mode required to be selected. Supported values given by CSL_OspiClkMode_t</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga589aeb7f02f905f6697f6a7dbce13b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga589aeb7f02f905f6697f6a7dbce13b8b">&#9670;&nbsp;</a></span>CSL_ospiSetChipSelect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiSetChipSelect </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>chipSelect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>decSelect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configures the chip select polarity for a selected chip select. This can only be done if OSPI module is not busy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">chipSelect</td><td>[IN] Peripheral chip select lines. Supported values are according to CSL_OspiChipSelect_t. </td></tr>
    <tr><td class="paramname">decSelect</td><td>[IN] Peripheral select decode. Supported values are according to CSL_OspiDecSelect_t.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1fe08c94de5bd08d0f793f37577d2e48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fe08c94de5bd08d0f793f37577d2e48">&#9670;&nbsp;</a></span>CSL_ospiSetDevDelay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiSetDevDelay </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>delays</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configures the device delays This can only be done if OSPI controller is idle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">delays</td><td>[IN] Pointer to the device delay array</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae599049affdf8d90ef2d184c888bab06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae599049affdf8d90ef2d184c888bab06">&#9670;&nbsp;</a></span>CSL_ospiSetDevSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiSetDevSize </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numAddrBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pageSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>blkSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set device size configrations. </p>
<p>This function configures the number af Address Bytes, device page size and block size. This can only be done if OSPI module is not busy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">numAddrBytes</td><td>[IN] Number of Address bytes to be sent for memory mapped protocol translator. Supported values are given by CSL_OspiMemMapNumAddrBytes_t. </td></tr>
    <tr><td class="paramname">pageSize</td><td>[IN] Device page size in bytes. </td></tr>
    <tr><td class="paramname">blkSize</td><td>[IN] Device block size in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1d8c6666c8fec4398c9095db6302566c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d8c6666c8fec4398c9095db6302566c">&#9670;&nbsp;</a></span>CSL_ospiSetIndTrigAddr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiSetIndTrigAddr </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>indTrigAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Indirect Trigger Address. </p>
<p>This function sets the base address that will be used by the AHB controller. This can only be done if OSPI module is not busy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">indTrigAddr</td><td>[IN] Indirect Trigger Address, base address used by the AHB controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2857f30dcc253ce15e3df2ea51895235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2857f30dcc253ce15e3df2ea51895235">&#9670;&nbsp;</a></span>CSL_ospiSetWrCompAutoPolling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiSetWrCompAutoPolling </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pollingState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set write completion auto polling configuration. </p>
<p>This function configures the write compltion auto polling state. This can only be done if OSPI module is not busy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">pollingState</td><td>[IN] Auto polling state. Supported values are given by CSL_OspiWriteCompAutoPolling_t.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0b75fe940458003e1ef5023e8d3fa1a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b75fe940458003e1ef5023e8d3fa1a3">&#9670;&nbsp;</a></span>CSL_ospiSetPollingDummyCycles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiSetPollingDummyCycles </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dummyCycles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set write completion auto polling configuration. </p>
<p>This function configures the write compltion auto polling state. This can only be done if OSPI module is not busy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">dummyCycles</td><td>[IN] number of dummy cycles required for a read ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf747a3b701c1bc77706bf02c1df9fa17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf747a3b701c1bc77706bf02c1df9fa17">&#9670;&nbsp;</a></span>CSL_ospiSetSramPartition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiSetSramPartition </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>partition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set SRAM partition configuration. </p>
<p>This function configures the size of the indirect read partition in the SRAM, in units of SRAM locations. This can only be done if OSPI module is not busy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">partition</td><td>[IN] Auto polling state. Supported values are given by CSL_OspiWriteCompAutoPolling_t.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabf5923f3cd1c4defd291e543c829422e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf5923f3cd1c4defd291e543c829422e">&#9670;&nbsp;</a></span>CSL_ospiIntrEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiIntrEnable </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrFlag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This Function enables/diables only specified OSPI interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">intrFlag</td><td>[IN] mask value for the interrupts to be enabled. Supported values are given by the CSL_OspiIntrMask_t. </td></tr>
    <tr><td class="paramname">enable</td><td>[IN] TRUE: enable the specified OSPI interrupts FALSE: disable the specified OSPI interrupts</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga632be9b0cc0676c8fbde7b8f69db4c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga632be9b0cc0676c8fbde7b8f69db4c28">&#9670;&nbsp;</a></span>CSL_ospiIntrStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CSL_ospiIntrStatus </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the status of interrupts. It specifies whether an interrupt is active or inactive. After an interrupt is serviced, the software must set to 0 the corresponding flag in the interrupt status register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">status</td><td>All the interrupt status. The return status can take value from the CSL_OspiIntrMask_t. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga262e95f450ff6d9b9a95556535e1fdca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga262e95f450ff6d9b9a95556535e1fdca">&#9670;&nbsp;</a></span>CSL_ospiIntrClear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiIntrClear </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This Function clears the status of specified interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">intrFlag</td><td>[IN] mask value for the interrupts to be cleared. given by CSL_OspiIntrMask_t.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga754389cfe8f87f2d5876946b901a1365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga754389cfe8f87f2d5876946b901a1365">&#9670;&nbsp;</a></span>CSL_ospiGetSramLvl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CSL_ospiGetSramLvl </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>read</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This Function gets the OSPI SRAM FIFO fill level bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">read</td><td>[IN] TRUE: indirect read, FALSE: indirect write</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SRAM</td><td>fifo fill level in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga374e7d32091bbb266a63bc1daeefcb0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga374e7d32091bbb266a63bc1daeefcb0e">&#9670;&nbsp;</a></span>CSL_ospiCmdRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_ospiCmdRead </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rxLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read operation in config mode. </p>
<p>This function performs the read operation in config mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">cmd</td><td>[IN] Flash command opcode. </td></tr>
    <tr><td class="paramname">rxLen</td><td>[IN] Number of read data bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CSL_ErrType_t</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaba05f486ce1ca3c1a27069057f2e88fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba05f486ce1ca3c1a27069057f2e88fc">&#9670;&nbsp;</a></span>CSL_ospiCmdExtRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_ospiCmdExtRead </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cmdLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rxLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dummyCycles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extended opcode read operation in config mode. </p>
<p>This function performs the read operation in config mode with extended/dual opcodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">cmdBuf</td><td>[IN] Flash command opcode buffer. </td></tr>
    <tr><td class="paramname">cmdLen</td><td>[IN] Nuber of command bytes in opcode buffer. </td></tr>
    <tr><td class="paramname">rxLen</td><td>[IN] Number of read data bytes. </td></tr>
    <tr><td class="paramname">dummyCycles</td><td>[IN] Dummy cyles for read operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CSL_ErrType_t</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga242b8cf08a3c7df1b70747d7dc889074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga242b8cf08a3c7df1b70747d7dc889074">&#9670;&nbsp;</a></span>CSL_ospiCmdWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_ospiCmdWrite </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cmdLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>txBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>txLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write operation in config mode. </p>
<p>This function performs the write operation in config mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">cmdBuf</td><td>[IN] Pointer to the flash command buffer. </td></tr>
    <tr><td class="paramname">cmdLen</td><td>[IN] Command buffer size in bytes. </td></tr>
    <tr><td class="paramname">txBuf</td><td>[IN] Pointer to the write data buffer </td></tr>
    <tr><td class="paramname">txLen</td><td>[IN] Number of write data bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CSL_ErrType_t</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6c9a1d8db873f6053a03f49ec800e243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c9a1d8db873f6053a03f49ec800e243">&#9670;&nbsp;</a></span>CSL_ospiConfigRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiConfigRead </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dummyClk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setup read operation transfer mode. </p>
<p>This function setup the configurations for read operation transfer mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">cmd</td><td>[IN] command opcode. </td></tr>
    <tr><td class="paramname">mode</td><td>[IN] data transfer mode (single/dual/quad mode) </td></tr>
    <tr><td class="paramname">dummyClk</td><td>[IN] Number of dummy clock cycles required for read op</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadf786362643a4215db7f13bd389d4050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf786362643a4215db7f13bd389d4050">&#9670;&nbsp;</a></span>CSL_ospiIndReadExecute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiIndReadExecute </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rxLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute read operation in indirect transfer mode. </p>
<p>This function kicks off the read operation in indirect transfer mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">rxLen</td><td>[IN] read length in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5d76207f28a007888acf3e820ed332ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d76207f28a007888acf3e820ed332ad">&#9670;&nbsp;</a></span>CSL_ospiClrIndReadComplete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiClrIndReadComplete </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear indirect read operation done status. </p>
<p>This function clears the indirect completion status in the Indirect Read Transfer Control Register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1b039af1efe8f8d1c8283c546c6546cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b039af1efe8f8d1c8283c546c6546cf">&#9670;&nbsp;</a></span>CSL_ospiIndReadComplete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CSL_ospiIndReadComplete </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if indirect read operation is done. </p>
<p>This function checks if indirect read operation is done</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">status</td><td>TRUE: read is done, FALSE: read is in progress </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa1f2bf2c3d39baf80176d8342c249963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1f2bf2c3d39baf80176d8342c249963">&#9670;&nbsp;</a></span>CSL_ospiReadFifoData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiReadFifoData </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>indAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rdLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data from the SRAM FIFO. </p>
<p>This function reads the data from the SRAM FIFO in indirect transfer mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indAddr</td><td>[IN] OSPI indirect AHB base address. </td></tr>
    <tr><td class="paramname">dest</td><td>[IN] Destination address to copy the read data </td></tr>
    <tr><td class="paramname">rdLen</td><td>[IN] read length in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga22aa9309cf92d103b0a1f9dd6711f152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22aa9309cf92d103b0a1f9dd6711f152">&#9670;&nbsp;</a></span>CSL_ospiWriteSetup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiWriteSetup </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setup write operation transfer mode. </p>
<p>This function setup the configurations for write operation transfer mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">cmd</td><td>[IN] command opcode. </td></tr>
    <tr><td class="paramname">mode</td><td>[IN] data transfer mode (single/dual/quad mode)</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga842c89c830fce446210a8f28fad8b709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga842c89c830fce446210a8f28fad8b709">&#9670;&nbsp;</a></span>CSL_ospiIsIndWriteComplete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CSL_ospiIsIndWriteComplete </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if indirect write operation is done. </p>
<p>This function checks if indirect write operation is done</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">status</td><td>TRUE: write is done, FALSE: write is in progress </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1505f040be3c3a65fb105556ec346490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1505f040be3c3a65fb105556ec346490">&#9670;&nbsp;</a></span>CSL_ospiClrIndWriteComplete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiClrIndWriteComplete </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear indirect write operation done status. </p>
<p>This function clears the indirect completion status in the Indirect Write Transfer Control Register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaa9e15223a027d32ac41208cacb09f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa9e15223a027d32ac41208cacb09f0d">&#9670;&nbsp;</a></span>CSL_ospiIndWriteExecute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiIndWriteExecute </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>txLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute write operation in indirect transfer mode. </p>
<p>This function performs the write operation in indirect transfer mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">txLen</td><td>[IN] write length in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaea41411aa63bc90dd1d968c3e1a79c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaea41411aa63bc90dd1d968c3e1a79c0">&#9670;&nbsp;</a></span>CSL_ospiIndWriteCancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiIndWriteCancel </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel write operation in indirect transfer mode. </p>
<p>This function cancels the write operation in indirect transfer mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaed3f08ca441621893a208a72bfad0b3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed3f08ca441621893a208a72bfad0b3e">&#9670;&nbsp;</a></span>CSL_ospiWriteFifoData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiWriteFifoData </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>indAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>wrLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data to the SRAM FIFO. </p>
<p>This function writes the data to the SRAM FIFO in indirect transfer mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indAddr</td><td>OSPI Indirect AHB base address </td></tr>
    <tr><td class="paramname">src</td><td>Source address to copy the write data </td></tr>
    <tr><td class="paramname">wrLen</td><td>write length in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga815beb57187a9f4ac3ebde81ae00cfa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga815beb57187a9f4ac3ebde81ae00cfa4">&#9670;&nbsp;</a></span>CSL_ospiLoopbackClkEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiLoopbackClkEnable </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the adapted loopback clock circuit. </p>
<p>This function enables the loopback mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">enable</td><td>[IN] TRUE: enable OSPI loopback clock FALSE: disable OSPI loopback clock</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga611c6741d0311e531010fc0ed1177339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga611c6741d0311e531010fc0ed1177339">&#9670;&nbsp;</a></span>CSL_ospiIsIdle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CSL_ospiIsIdle </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if OSPI is idle or not. </p>
<p>This function checks the OSPI idle status</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">idle</td><td>status TRUE: OSPI is idle, FALSE: OSPI is busy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga71f0899a097589bfa2e3aee4f45d4afa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71f0899a097589bfa2e3aee4f45d4afa">&#9670;&nbsp;</a></span>CSL_ospiFlashExecCmd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiFlashExecCmd </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Excecute the flash read/write command. </p>
<p>This function excecute the flash read/write command</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga511a37812ee2a78374f87eb9dcdd326d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga511a37812ee2a78374f87eb9dcdd326d">&#9670;&nbsp;</a></span>CSL_ospiFlashExecCmdComplete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CSL_ospiFlashExecCmdComplete </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check the flash command execution status. </p>
<p>This function checks the execution status of the flash read/write command</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">status</td><td>TRUE: command execution completed FALSE: command execution in progress </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae3c92ecbbbac9bb7636c35ecb961179e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3c92ecbbbac9bb7636c35ecb961179e">&#9670;&nbsp;</a></span>CSL_ospiConfigPhy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiConfigPhy </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lockCycle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>masterDelay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>pSlaveDelay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the PHY. </p>
<p>This function configures and calibrates the PHY</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">lockCycle</td><td>[IN] </td></tr>
    <tr><td class="paramname">masterDelay</td><td>[IN] Initial number of delay elements for Master DLL </td></tr>
    <tr><td class="paramname">pSlaveDelay</td><td>[IN] Point to initial number of delay elements for Slave DLL if pDelay == NULL, do calibration operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab8b6057e309b1cac67c243fc3a744749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8b6057e309b1cac67c243fc3a744749">&#9670;&nbsp;</a></span>CSL_ospiFlashStig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiFlashStig </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set configurations for a flash STIG command. </p>
<p>This function sets the command address, data and contorl for a generic STIG command</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">cmd</td><td>[IN] </td></tr>
    <tr><td class="paramname">addr</td><td>[IN] </td></tr>
    <tr><td class="paramname">data</td><td>[IN]</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0f30588b1a0248699ff9c18e7f2e3ff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f30588b1a0248699ff9c18e7f2e3ff9">&#9670;&nbsp;</a></span>CSL_ospiIndSetStartAddr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiIndSetStartAddr </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>startAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>read</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the read or wrtie start address in Indirect mode. </p>
<p>This function configures indac read or write start address</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">startAddr</td><td>[IN] Indirect access start address </td></tr>
    <tr><td class="paramname">read</td><td>[IN] TRUE: read operation; FALSE: write operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga89a949442c7608b5799bb4a728d0ca02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89a949442c7608b5799bb4a728d0ca02">&#9670;&nbsp;</a></span>CSL_ospiSetDataReadCapDelay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiSetDataReadCapDelay </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the read data capture delay. </p>
<p>This function sets the read data capture delay in # of ref_clk cycles</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">delay</td><td>[IN] delay in # of ref_clk cycle</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae04cb3e20740f4992e17db0f5004e34d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae04cb3e20740f4992e17db0f5004e34d">&#9670;&nbsp;</a></span>CSL_ospiSetCsSotDelay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiSetCsSotDelay </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the Chip Select Start of Transfer delay. </p>
<p>This function sets the Chip Select Start of Transfer delay in # of ref_clk cycles</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">delay</td><td>[IN] delay in # of ref_clk cycle</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga40abffa106afb0b9e20b1c03d9877c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40abffa106afb0b9e20b1c03d9877c62">&#9670;&nbsp;</a></span>CSL_ospiSetDualByteOpcodeMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiSetDualByteOpcodeMode </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>opcodeMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the dual byte opcode mode. </p>
<p>This function enables/disables the dual byte opcode mode for OSPI commands</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">opcodeMode</td><td>[IN] Opcode COnfigurations 0 - Disable dual byte opcode 1 - Enable dual byte opcode</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf18b8b99e9cdc9ff53f2187f32fa0a09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf18b8b99e9cdc9ff53f2187f32fa0a09">&#9670;&nbsp;</a></span>CSL_ospiGetDualByteOpcodeMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CSL_ospiGetDualByteOpcodeMode </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the dual byte opcode mode. </p>
<p>This function reads the dual byte opcode mode enable/disable status</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaeac7b4b4b6250aca6bf118ce2ed687af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeac7b4b4b6250aca6bf118ce2ed687af">&#9670;&nbsp;</a></span>CSL_ospiExtOpcodeSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiExtOpcodeSet </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>opcodeLo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>opcodeUp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the dual byte opcode parameters. </p>
<p>This function configures the dual byte opcodes in extended opcode registers</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">opcodeLo</td><td>[IN] Extended opcode lower 32-bit value. </td></tr>
    <tr><td class="paramname">opcodeUp</td><td>[IN] Extended opcode upper 32-bit value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0df624628cd932619c48db663de5fff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0df624628cd932619c48db663de5fff2">&#9670;&nbsp;</a></span>CSL_ospiExtOpcodeGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiExtOpcodeGet </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>opcodeLo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>opcodeUp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the dual byte opcode parameters. </p>
<p>This function reads the dual byte opcodes from extended opcode registers</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">opcodeLo</td><td>[OUT] Extended opcode lower 32-bit value. </td></tr>
    <tr><td class="paramname">opcodeUp</td><td>[OUT] Extended opcode upper 32-bit value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae69830d64decf38a51b977805c8243cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae69830d64decf38a51b977805c8243cd">&#9670;&nbsp;</a></span>CSL_ospiConfigPhyDLL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiConfigPhyDLL </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>txDelay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rxDelay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>opMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lockCycle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>funcClk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the PHY TX/RX DLL delays. </p>
<p>This function configures the TX/RX DLL delays of the PHY</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">txDelay</td><td>[IN] TX DLL delay value </td></tr>
    <tr><td class="paramname">rxDelay</td><td>[IN] RX DLL delay value </td></tr>
    <tr><td class="paramname">opMode</td><td>[IN] PHY operation mode </td></tr>
    <tr><td class="paramname">lockCycle</td><td>[IN] </td></tr>
    <tr><td class="paramname">funcClk</td><td>[IN] OSPI CLK Frequency</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga899ae1e092e25e8807e6c6f69c438e8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga899ae1e092e25e8807e6c6f69c438e8c">&#9670;&nbsp;</a></span>CSL_ospiPhyResyncDll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiPhyResyncDll </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lockCycle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resync the PHY DLLs after configuring the TX delays. </p>
<p>This function resynchronizes the PHY DLLs after configuring the TX delays. This function is invoked internally by CSL_ospiConfigPhyDLL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">lockCycle</td><td>[IN]</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
