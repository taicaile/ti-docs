<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<title>PDK API Guide for J721S2: CPTS Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ti_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PDK API Guide for J721S2
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__CSL__CPTS__FUNCTION.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">CPTS Functions<div class="ingroups"><a class="el" href="group__CSL__IP__MODULE.html">CSL-FL</a> &raquo; <a class="el" href="group__CSL__CPSWITCH.html">CPSW CSL-FL</a> &raquo; <a class="el" href="group__CSL__CPTS__API.html">CPTS API</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Introduction</h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaefe92f832045cde89b52406326aa1786"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPTS__FUNCTION.html#gaefe92f832045cde89b52406326aa1786">CSL_CPTS_getCptsVersionInfo</a> (const CSL_cptsRegs *pCptsRegs, <a class="el" href="structCSL__CPTS__VERSION.html">CSL_CPTS_VERSION</a> *pVersionInfo)</td></tr>
<tr class="separator:gaefe92f832045cde89b52406326aa1786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56e078278e3ceb2a283ec64e4d765859"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPTS__FUNCTION.html#ga56e078278e3ceb2a283ec64e4d765859">CSL_CPTS_isCptsEnabled</a> (const CSL_cptsRegs *pCptsRegs)</td></tr>
<tr class="separator:ga56e078278e3ceb2a283ec64e4d765859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4de1d6398a8e766d3e432e65c6b0a441"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPTS__FUNCTION.html#ga4de1d6398a8e766d3e432e65c6b0a441">CSL_CPTS_enableCpts</a> (CSL_cptsRegs *pCptsRegs)</td></tr>
<tr class="separator:ga4de1d6398a8e766d3e432e65c6b0a441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ef22d24c4c10eed055d1559cb55c090"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPTS__FUNCTION.html#ga7ef22d24c4c10eed055d1559cb55c090">CSL_CPTS_disableCpts</a> (CSL_cptsRegs *pCptsRegs)</td></tr>
<tr class="separator:ga7ef22d24c4c10eed055d1559cb55c090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga871d65f51474c75a6a128c8d1a1a3860"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPTS__FUNCTION.html#ga871d65f51474c75a6a128c8d1a1a3860">CSL_CPTS_getCntlReg</a> (const CSL_cptsRegs *pCptsRegs, <a class="el" href="structCSL__CPTS__CONTROL.html">CSL_CPTS_CONTROL</a> *pCntlCfg)</td></tr>
<tr class="separator:ga871d65f51474c75a6a128c8d1a1a3860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff491084f4d483eb8457c8791261efc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPTS__FUNCTION.html#gaff491084f4d483eb8457c8791261efc4">CSL_CPTS_setCntlReg</a> (CSL_cptsRegs *pCptsRegs, const <a class="el" href="structCSL__CPTS__CONTROL.html">CSL_CPTS_CONTROL</a> *pCntlCfg)</td></tr>
<tr class="separator:gaff491084f4d483eb8457c8791261efc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga562fff13f4695e03208ff79b4dac083a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPTS__FUNCTION.html#ga562fff13f4695e03208ff79b4dac083a">CSL_CPTS_getRFTCLKSelectReg</a> (const CSL_cptsRegs *pCptsRegs, uint32_t *pRefClockSelect)</td></tr>
<tr class="separator:ga562fff13f4695e03208ff79b4dac083a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6546da24b47160cb600bc543dd83b07b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPTS__FUNCTION.html#ga6546da24b47160cb600bc543dd83b07b">CSL_CPTS_setRFTCLKSelectReg</a> (CSL_cptsRegs *pCptsRegs, uint32_t refClockSetVal)</td></tr>
<tr class="separator:ga6546da24b47160cb600bc543dd83b07b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e1f56e0a790d9149bd5f01a4465b2b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPTS__FUNCTION.html#ga5e1f56e0a790d9149bd5f01a4465b2b6">CSL_CPTS_TSEventPush</a> (CSL_cptsRegs *pCptsRegs)</td></tr>
<tr class="separator:ga5e1f56e0a790d9149bd5f01a4465b2b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga916f2fe009924841bd78d02efd38e798"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPTS__FUNCTION.html#ga916f2fe009924841bd78d02efd38e798">CSL_CPTS_getTSLoadValReg</a> (const CSL_cptsRegs *pCptsRegs, uint32_t *pTSLoadVal)</td></tr>
<tr class="separator:ga916f2fe009924841bd78d02efd38e798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7a95a90f07192dd9c3b895574b53f17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPTS__FUNCTION.html#gad7a95a90f07192dd9c3b895574b53f17">CSL_CPTS_setTSLoadValReg</a> (CSL_cptsRegs *pCptsRegs, uint32_t tsLoadValLo, uint32_t tsLoadValHi)</td></tr>
<tr class="separator:gad7a95a90f07192dd9c3b895574b53f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae77b60f04f5bbb88bd54557b987ca252"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPTS__FUNCTION.html#gae77b60f04f5bbb88bd54557b987ca252">CSL_CPTS_setTSVal</a> (CSL_cptsRegs *pCptsRegs, uint32_t tsValLo, uint32_t tsValHi)</td></tr>
<tr class="separator:gae77b60f04f5bbb88bd54557b987ca252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0816aae3281112e371ef071259a2f44f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPTS__FUNCTION.html#ga0816aae3281112e371ef071259a2f44f">CSL_CPTS_setTSCompVal</a> (CSL_cptsRegs *pCptsRegs, uint32_t tsCompValLo, uint32_t tsCompValHi, uint32_t tsCompLen)</td></tr>
<tr class="separator:ga0816aae3281112e371ef071259a2f44f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac77ae89d3b211d38c166bde2240a5e5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPTS__FUNCTION.html#gac77ae89d3b211d38c166bde2240a5e5a">CSL_CPTS_setTSCompNudge</a> (CSL_cptsRegs *pCptsRegs, int32_t tsCompNudge)</td></tr>
<tr class="separator:gac77ae89d3b211d38c166bde2240a5e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac90d6b97b58d14b02cd711a6f967d51b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPTS__FUNCTION.html#gac90d6b97b58d14b02cd711a6f967d51b">CSL_CPTS_getTSAddVal</a> (CSL_cptsRegs *pCptsRegs)</td></tr>
<tr class="separator:gac90d6b97b58d14b02cd711a6f967d51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03f5e389022975228de44242dd1ce2ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPTS__FUNCTION.html#ga03f5e389022975228de44242dd1ce2ae">CSL_CPTS_setTSAddVal</a> (CSL_cptsRegs *pCptsRegs, uint32_t tsAddVal)</td></tr>
<tr class="separator:ga03f5e389022975228de44242dd1ce2ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7d5ffabe89d5b4450b05ab2d1ac8bff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPTS__FUNCTION.html#gab7d5ffabe89d5b4450b05ab2d1ac8bff">CSL_CPTS_setTSNudge</a> (CSL_cptsRegs *pCptsRegs, int32_t tsNudge)</td></tr>
<tr class="separator:gab7d5ffabe89d5b4450b05ab2d1ac8bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4813608c74c41d29e34dc48689d8e986"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPTS__FUNCTION.html#ga4813608c74c41d29e34dc48689d8e986">CSL_CPTS_getTSPpm</a> (const CSL_cptsRegs *pCptsRegs, uint32_t tsPpmVal[2])</td></tr>
<tr class="separator:ga4813608c74c41d29e34dc48689d8e986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2f8c9292a942a40e8d3ea85533bcab5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPTS__FUNCTION.html#gaf2f8c9292a942a40e8d3ea85533bcab5">CSL_CPTS_setTSPpm</a> (CSL_cptsRegs *pCptsRegs, uint32_t tsPpmValLo, uint32_t tsPpmValHi, <a class="el" href="group__CSL__CPTS__DATASTRUCT.html#ga04af4285bbbf036d3c6fb60c57049189">CSL_CPTS_TS_PPM_DIR</a> tsPpmDir)</td></tr>
<tr class="separator:gaf2f8c9292a942a40e8d3ea85533bcab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a84ba0252d655f304a641b7dbdb5367"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPTS__FUNCTION.html#ga9a84ba0252d655f304a641b7dbdb5367">CSL_CPTS_isRawInterruptStatusBitSet</a> (const CSL_cptsRegs *pCptsRegs)</td></tr>
<tr class="separator:ga9a84ba0252d655f304a641b7dbdb5367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75e95529add3e9dd2a5774245a36e56a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPTS__FUNCTION.html#ga75e95529add3e9dd2a5774245a36e56a">CSL_CPTS_isMaskedInterruptStatusBitSet</a> (const CSL_cptsRegs *pCptsRegs)</td></tr>
<tr class="separator:ga75e95529add3e9dd2a5774245a36e56a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59d5c2b6aed3ea2145e6479c1e7c233b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPTS__FUNCTION.html#ga59d5c2b6aed3ea2145e6479c1e7c233b">CSL_CPTS_isInterruptEnabled</a> (const CSL_cptsRegs *pCptsRegs)</td></tr>
<tr class="separator:ga59d5c2b6aed3ea2145e6479c1e7c233b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga597fb448cd877a180e2cc85f1067e9ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPTS__FUNCTION.html#ga597fb448cd877a180e2cc85f1067e9ce">CSL_CPTS_enableInterrupt</a> (CSL_cptsRegs *pCptsRegs)</td></tr>
<tr class="separator:ga597fb448cd877a180e2cc85f1067e9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f2c24e868686146b73a94ed8f25b9d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPTS__FUNCTION.html#ga2f2c24e868686146b73a94ed8f25b9d2">CSL_CPTS_disableInterrupt</a> (CSL_cptsRegs *pCptsRegs)</td></tr>
<tr class="separator:ga2f2c24e868686146b73a94ed8f25b9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57bd08d9d5bf2bce79c301f097e076c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPTS__FUNCTION.html#ga57bd08d9d5bf2bce79c301f097e076c8">CSL_CPTS_popEvent</a> (CSL_cptsRegs *pCptsRegs)</td></tr>
<tr class="separator:ga57bd08d9d5bf2bce79c301f097e076c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1efc479ce4f4fe6f01eaa2fe852df929"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPTS__FUNCTION.html#ga1efc479ce4f4fe6f01eaa2fe852df929">CSL_CPTS_getEventInfo</a> (const CSL_cptsRegs *pCptsRegs, <a class="el" href="structCSL__CPTS__EVENTINFO.html">CSL_CPTS_EVENTINFO</a> *pEventInfo)</td></tr>
<tr class="separator:ga1efc479ce4f4fe6f01eaa2fe852df929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga770ad74a401e5e80cc2ec81bb3a02d20"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPTS__FUNCTION.html#ga770ad74a401e5e80cc2ec81bb3a02d20">CSL_CPTS_getGENFnLength</a> (CSL_cptsRegs *pCptsRegs, uint32_t genfIndex, uint32_t *pGenfLength)</td></tr>
<tr class="separator:ga770ad74a401e5e80cc2ec81bb3a02d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87f75817cd9f6c466c2209cb116ac7f5"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPTS__FUNCTION.html#ga87f75817cd9f6c466c2209cb116ac7f5">CSL_CPTS_setupGENFn</a> (CSL_cptsRegs *pCptsRegs, uint32_t genfIndex, uint32_t length, uint64_t compare, uint32_t polarityInv, uint64_t ppmAdjust, <a class="el" href="group__CSL__CPTS__DATASTRUCT.html#ga04af4285bbbf036d3c6fb60c57049189">CSL_CPTS_TS_PPM_DIR</a> ppmDir)</td></tr>
<tr class="separator:ga87f75817cd9f6c466c2209cb116ac7f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1de80067232613c909ceb2f87a04a3f"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPTS__FUNCTION.html#gae1de80067232613c909ceb2f87a04a3f">CSL_CPTS_setGENFnNudge</a> (CSL_cptsRegs *pCptsRegs, uint32_t genfIndex, int32_t tsNudge)</td></tr>
<tr class="separator:gae1de80067232613c909ceb2f87a04a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fc2833f49cccd9eef735c8d0e1a875c"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPTS__FUNCTION.html#ga5fc2833f49cccd9eef735c8d0e1a875c">CSL_CPTS_getESTFnLength</a> (CSL_cptsRegs *pCptsRegs, uint32_t estfIndex, uint32_t *pEstfLength)</td></tr>
<tr class="separator:ga5fc2833f49cccd9eef735c8d0e1a875c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33c1241061af9c52870ee1fa1b06b143"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPTS__FUNCTION.html#ga33c1241061af9c52870ee1fa1b06b143">CSL_CPTS_setupESTFn</a> (CSL_cptsRegs *pCptsRegs, uint32_t estfIndex, uint32_t length, uint64_t compare, uint32_t polarityInv, uint64_t ppmAdjust, <a class="el" href="group__CSL__CPTS__DATASTRUCT.html#ga04af4285bbbf036d3c6fb60c57049189">CSL_CPTS_TS_PPM_DIR</a> ppmDir)</td></tr>
<tr class="separator:ga33c1241061af9c52870ee1fa1b06b143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacebcb156a3ef4333e45e20e4b95ab308"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__CPTS__FUNCTION.html#gacebcb156a3ef4333e45e20e4b95ab308">CSL_CPTS_setESTFnNudge</a> (CSL_cptsRegs *pCptsRegs, uint32_t estfIndex, int32_t tsNudge)</td></tr>
<tr class="separator:gacebcb156a3ef4333e45e20e4b95ab308"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaefe92f832045cde89b52406326aa1786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefe92f832045cde89b52406326aa1786">&#9670;&nbsp;</a></span>CSL_CPTS_getCptsVersionInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPTS_getCptsVersionInfo </td>
          <td>(</td>
          <td class="paramtype">const CSL_cptsRegs *&#160;</td>
          <td class="paramname"><em>pCptsRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCSL__CPTS__VERSION.html">CSL_CPTS_VERSION</a> *&#160;</td>
          <td class="paramname"><em>pVersionInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPTS_getCptsVersionInfo</b> </p>
<p><b>Description</b> <br />
 This function retrieves the CPTS module identification and version information.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pCptsRegs           Pointer to CSL_cptsRegs structure
       pVersionInfo        CSL_CPTS_VERSION structure that needs to be populated
                           with the version info read from the hardware.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPTS_IDVER_REG_MINOR_VER, CPTS_IDVER_REG_MAJOR_VER, CPTS_IDVER_REG_RTL_VER, CPTS_IDVER_REG_TX_IDENT</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_CPTS_VERSION    versionInfo;

       CSL_CPTS_getCptsVersionInfo (pCptsRegs, &amp;versionInfo);</pre> <hr/>
 
</div>
</div>
<a id="ga56e078278e3ceb2a283ec64e4d765859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56e078278e3ceb2a283ec64e4d765859">&#9670;&nbsp;</a></span>CSL_CPTS_isCptsEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CSL_CPTS_isCptsEnabled </td>
          <td>(</td>
          <td class="paramtype">const CSL_cptsRegs *&#160;</td>
          <td class="paramname"><em>pCptsRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPTS_isCptsEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if time sync is enabled or not.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pCptsRegs           Pointer to CSL_cptsRegs structure
*   </pre><p><b> Return Value </b> <br />
 TRUE CPTS enabled. <br />
 FALSE CPTS disabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPTS_CONTROL_REG_CPTS_EN</p>
<p><b>Example</b> </p><pre class="fragment">       if (CSL_CPTS_isCptsEnabled (pCptsRegs) == TRUE)
       {
           // CPTS on
       }
       else
       {
           // CPTS off
       }</pre> <hr/>
 
</div>
</div>
<a id="ga4de1d6398a8e766d3e432e65c6b0a441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4de1d6398a8e766d3e432e65c6b0a441">&#9670;&nbsp;</a></span>CSL_CPTS_enableCpts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPTS_enableCpts </td>
          <td>(</td>
          <td class="paramtype">CSL_cptsRegs *&#160;</td>
          <td class="paramname"><em>pCptsRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPTS_enableCpts</b> </p>
<p><b>Description</b> <br />
 This function configures the CPTS control register to enable time sync.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pCptsRegs           Pointer to CSL_cptsRegs structure
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPTS_CONTROL_REG_CPTS_EN=1</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_CPTS_enableCpts (pCptsRegs);</pre> <hr/>
 
</div>
</div>
<a id="ga7ef22d24c4c10eed055d1559cb55c090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ef22d24c4c10eed055d1559cb55c090">&#9670;&nbsp;</a></span>CSL_CPTS_disableCpts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPTS_disableCpts </td>
          <td>(</td>
          <td class="paramtype">CSL_cptsRegs *&#160;</td>
          <td class="paramname"><em>pCptsRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPTS_disableCpts</b> </p>
<p><b>Description</b> <br />
 This function configures the CPTS control register to disable time sync.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pCptsRegs           Pointer to CSL_cptsRegs structure
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPTS_CONTROL_REG_CPTS_EN=0</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_CPTS_disableCpts (pCptsRegs);</pre> <hr/>
 
</div>
</div>
<a id="ga871d65f51474c75a6a128c8d1a1a3860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga871d65f51474c75a6a128c8d1a1a3860">&#9670;&nbsp;</a></span>CSL_CPTS_getCntlReg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPTS_getCntlReg </td>
          <td>(</td>
          <td class="paramtype">const CSL_cptsRegs *&#160;</td>
          <td class="paramname"><em>pCptsRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCSL__CPTS__CONTROL.html">CSL_CPTS_CONTROL</a> *&#160;</td>
          <td class="paramname"><em>pCntlCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPTS_getCntllReg</b> </p>
<p><b>Description</b> <br />
 This function retreives the contents of CPTS control register</p>
<p><b>Arguments</b> </p><pre class="fragment">       pCptsRegs           Pointer to CSL_cptsRegs structure
       pCntlCfg            CSL_CPTS_CONTROL that needs to be populated with
                           contents of CPTS control register.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPTS_CONTROL_REG_CPTS_EN CPTS_CONTROL_REG_INT_TEST CPTS_CONTROL_REG_TS_COMP_POLARITY CPTS_CONTROL_REG_TSTAMP_EN CPTS_CONTROL_REG_SEQUENCE_EN CPTS_CONTROL_REG_MODE CPTS_CONTROL_REG_TS_COMP_TOG CPTS_CONTROL_REG_HW1_TS_PUSH_EN CPTS_CONTROL_REG_HW2_TS_PUSH_EN CPTS_CONTROL_REG_HW3_TS_PUSH_EN CPTS_CONTROL_REG_HW4_TS_PUSH_EN CPTS_CONTROL_REG_HW5_TS_PUSH_EN CPTS_CONTROL_REG_HW6_TS_PUSH_EN CPTS_CONTROL_REG_HW7_TS_PUSH_EN CPTS_CONTROL_REG_HW8_TS_PUSH_EN CPTS_CONTROL_REG_TS_SYNC_SEL CPTS_CONTROL_REG_TS_RX_NO_EVENT CPTS_CONTROL_REG_TS_GENF_CLR_EN</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_CPTS_CONTROL     cntlCfg;

       CSL_CPTS_getCntlReg (pCptsRegs, &amp;cntlCfg);</pre> <hr/>
 
</div>
</div>
<a id="gaff491084f4d483eb8457c8791261efc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff491084f4d483eb8457c8791261efc4">&#9670;&nbsp;</a></span>CSL_CPTS_setCntlReg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPTS_setCntlReg </td>
          <td>(</td>
          <td class="paramtype">CSL_cptsRegs *&#160;</td>
          <td class="paramname"><em>pCptsRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structCSL__CPTS__CONTROL.html">CSL_CPTS_CONTROL</a> *&#160;</td>
          <td class="paramname"><em>pCntlCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPTS_setCntllReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of CPTS control register</p>
<p><b>Arguments</b> </p><pre class="fragment">       pCptsRegs           Pointer to CSL_cptsRegs structure
       pCntlCfg            CSL_CPTS_CONTROL contain settings for
                           CPTS control register.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPTS_CONTROL_REG_CPTS_EN CPTS_CONTROL_REG_INT_TEST CPTS_CONTROL_REG_TS_COMP_POLARITY CPTS_CONTROL_REG_TSTAMP_EN CPTS_CONTROL_REG_SEQUENCE_EN CPTS_CONTROL_REG_MODE CPTS_CONTROL_REG_TS_COMP_TOG CPTS_CONTROL_REG_HW1_TS_PUSH_EN CPTS_CONTROL_REG_HW2_TS_PUSH_EN CPTS_CONTROL_REG_HW3_TS_PUSH_EN CPTS_CONTROL_REG_HW4_TS_PUSH_EN CPTS_CONTROL_REG_HW5_TS_PUSH_EN CPTS_CONTROL_REG_HW6_TS_PUSH_EN CPTS_CONTROL_REG_HW7_TS_PUSH_EN CPTS_CONTROL_REG_HW8_TS_PUSH_EN CPTS_CONTROL_REG_TS_SYNC_SEL CPTS_CONTROL_REG_TS_RX_NO_EVENT CPTS_CONTROL_REG_TS_GENF_CLR_EN</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_CPTS_CONTROL     cntlCfg;

       CSL_CPTS_setCntlReg (pCptsRegs, &amp;cntlCfg);</pre> <hr/>
 
</div>
</div>
<a id="ga562fff13f4695e03208ff79b4dac083a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga562fff13f4695e03208ff79b4dac083a">&#9670;&nbsp;</a></span>CSL_CPTS_getRFTCLKSelectReg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPTS_getRFTCLKSelectReg </td>
          <td>(</td>
          <td class="paramtype">const CSL_cptsRegs *&#160;</td>
          <td class="paramname"><em>pCptsRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pRefClockSelect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPTS_getRFTCLKSelectReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the reference clock select register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pCptsRegs           Pointer to CSL_cptsRegs structure
       pRefClockSelect     Reference clock select value read from hardware.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPTS_RFTCLK_SEL_REG_RFTCLK_SEL</p>
<p><b>Example</b> </p><pre class="fragment">       uint32_t          refClockSelect;

       CSL_CPTS_getRFTCLKSelectReg (pCptsRegs, &amp;refClockSelect);</pre> <hr/>
 
</div>
</div>
<a id="ga6546da24b47160cb600bc543dd83b07b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6546da24b47160cb600bc543dd83b07b">&#9670;&nbsp;</a></span>CSL_CPTS_setRFTCLKSelectReg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPTS_setRFTCLKSelectReg </td>
          <td>(</td>
          <td class="paramtype">CSL_cptsRegs *&#160;</td>
          <td class="paramname"><em>pCptsRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>refClockSetVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPTS_setRFTCLKSelectReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the reference clock select value. The Reference clock value can be setup only when the CPTS enable bit is cleared in the CPTS control register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pCptsRegs           Pointer to CSL_cptsRegs structure
       refClockSetVal      Reference clock select value to configure.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 <em>CSL_CPTS_setTimeSyncControlReg</em> () must be called to clear the CPTS enable bit before calling this API.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Affects</b> <br />
 CPTS_RFTCLK_SEL_REG_RFTCLK_SEL</p>
<p><b>Example</b> </p><pre class="fragment">       uint32_t          refClockSelect;

       refClockSelect  =   0;

       CSL_CPTS_setRFTCLKSelectReg (pCptsRegs, refClockSelect);</pre> <hr/>
 
</div>
</div>
<a id="ga5e1f56e0a790d9149bd5f01a4465b2b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e1f56e0a790d9149bd5f01a4465b2b6">&#9670;&nbsp;</a></span>CSL_CPTS_TSEventPush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPTS_TSEventPush </td>
          <td>(</td>
          <td class="paramtype">CSL_cptsRegs *&#160;</td>
          <td class="paramname"><em>pCptsRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPTS_TSEventPush</b> </p>
<p><b>Description</b> <br />
 This function writes an 1 to the Time Stamp Event Push register to generate a timestamp event. The time stamp value is the time of the write of this register, not the time of the event read. The time stamp value can then be read on interrupt via the event registers.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pCptsRegs           Pointer to CSL_cptsRegs structure
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Affects</b> <br />
 CPTS_TS_PUSH_REG_TS_PUSH</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_CPTS_TSEventPush (pCptsRegs);</pre><dl class="section note"><dt>Note</dt><dd>: Software should not push a second time stamp event onto the event FIFO until the first time stamp value has been read from the event FIFO (there should be only one time stamp event in the event FIFO at any <h1>given time). </h1>
</dd></dl>

</div>
</div>
<a id="ga916f2fe009924841bd78d02efd38e798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga916f2fe009924841bd78d02efd38e798">&#9670;&nbsp;</a></span>CSL_CPTS_getTSLoadValReg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPTS_getTSLoadValReg </td>
          <td>(</td>
          <td class="paramtype">const CSL_cptsRegs *&#160;</td>
          <td class="paramname"><em>pCptsRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pTSLoadVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPTS_getTSLoadValReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the Time Stamp Load Value register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pCptsRegs           Pointer to CSL_cptsRegs structure
       pTSLoadVal          Time stamp load value read from hardware.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPTS_TS_LOAD_VAL_REG_TS_LOAD_VAL <br />
 CPTS_TS_LOAD_HIGH_VAL_REG_TS_LOAD_VAL</p>
<p><b>Example</b> </p><pre class="fragment">       uint32_t          tsLoadVal[2];

       CSL_CPTS_getTSLoadValReg (pCptsRegs, tsLoadVal);</pre><dl class="section note"><dt>Note</dt><dd>: When reading this register, the value read is not the time <h1>stamp, but is the value that was last written to this register. </h1>
</dd></dl>

</div>
</div>
<a id="gad7a95a90f07192dd9c3b895574b53f17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7a95a90f07192dd9c3b895574b53f17">&#9670;&nbsp;</a></span>CSL_CPTS_setTSLoadValReg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPTS_setTSLoadValReg </td>
          <td>(</td>
          <td class="paramtype">CSL_cptsRegs *&#160;</td>
          <td class="paramname"><em>pCptsRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tsLoadValLo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tsLoadValHi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPTS_setTSLoadValReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the Time Stamp Load Value.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pCptsRegs           Pointer to CSL_cptsRegs structure
       tsLoadValLo         Time stamp load value (lower 32-bits) to configure
       tsLoadValHi         Time stamp load value (upper 32-bits) to configure
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Affects</b> <br />
 CPTS_TS_LOAD_VAL_REG_TS_LOAD_VAL <br />
 CPTS_TS_LOAD_HIGH_VAL_REG_TS_LOAD_VAL</p>
<p><b>Example</b> </p><pre class="fragment">       uint32_t tsLoadValLo, tsLoadValHi;

       tsLoadValLo = tsLoadValHi = 0;

       CSL_CPTS_setTSLoadValReg (pCptsRegs, tsLoadValLo, tsLoadValHi);</pre> <hr/>
 
</div>
</div>
<a id="gae77b60f04f5bbb88bd54557b987ca252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae77b60f04f5bbb88bd54557b987ca252">&#9670;&nbsp;</a></span>CSL_CPTS_setTSVal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPTS_setTSVal </td>
          <td>(</td>
          <td class="paramtype">CSL_cptsRegs *&#160;</td>
          <td class="paramname"><em>pCptsRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tsValLo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tsValHi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPTS_setTSVal</b> </p>
<p><b>Description</b> <br />
 This function sets the Time Stamp Value.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pCptsRegs           Pointer to CSL_cptsRegs structure
       tsValLo             Time stamp value (lower 32-bits) to be loaded.
       tsValHi             Time stamp value (upper 32-bits) to be loaded.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Affects</b> <br />
 CPTS_TS_LOAD_VAL_REG_TS_LOAD_VAL <br />
 CPTS_TS_LOAD_HIGH_VAL_REG_TS_LOAD_VAL <br />
 CPTS_TS_LOAD_EN_REG_TS_LOAD_EN</p>
<p><b>Example</b> </p><pre class="fragment">       uint32_t tsValLo, tsValHi;

       tsValLo = tsValHi = 0;

       CSL_CPTS_setTSVal (pCptsRegs, tsValLo, tsValHi);</pre> <hr/>
 
</div>
</div>
<a id="ga0816aae3281112e371ef071259a2f44f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0816aae3281112e371ef071259a2f44f">&#9670;&nbsp;</a></span>CSL_CPTS_setTSCompVal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPTS_setTSCompVal </td>
          <td>(</td>
          <td class="paramtype">CSL_cptsRegs *&#160;</td>
          <td class="paramname"><em>pCptsRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tsCompValLo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tsCompValHi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tsCompLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPTS_setTSCompVal</b> </p>
<p><b>Description</b> <br />
 This function sets the Time Stamp Compare Value and triggers the Time Stamp Comparsion operation.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pCptsRegs           Pointer to CSL_cptsRegs structure
       tsCompValLo         Time stamp compare value (lower 32-bits) to be loaded.
       tsCompValHi         Time stamp compare value (upper 32-bits) to be loaded.
       tsCompLen           Length of the TS_COMP output pluse in non-toggle mode
                           Half Period of the TS_COMP wave in toggle mode
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Affects</b> <br />
 CPTS_TS_COMP_VAL_REG_TS_COMP_VAL <br />
 CPTS_TS_COMP_HIGH_VAL_REG_TS_COMP_VAL <br />
 CPTS_TS_COMP_LEN_REG_TS_COMP_LENGTH</p>
<p><b>Example</b> </p><pre class="fragment">       uint32_t          tsCompValLo, tsCompValHi;
       uint32_t          tsCompLen;

       tsCompValLo =   0x3000;
       tsCompValHi =   0;
       tsCompLen   =   1000;

       CSL_CPTS_setTSCompVal (pCptsRegs, tsCompValLo, tsCompValHi, tsCompLen);</pre> <hr/>
 
</div>
</div>
<a id="gac77ae89d3b211d38c166bde2240a5e5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac77ae89d3b211d38c166bde2240a5e5a">&#9670;&nbsp;</a></span>CSL_CPTS_setTSCompNudge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPTS_setTSCompNudge </td>
          <td>(</td>
          <td class="paramtype">CSL_cptsRegs *&#160;</td>
          <td class="paramname"><em>pCptsRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>tsCompNudge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPTS_setTSCompNudge</b> </p>
<p><b>Description</b> <br />
 This function sets the Time Stamp Compare Nudge Value to adjust the phase of time compare wave in Toggle mode. This two's complement number is added to the ts_comp_length[23:0] value to increase or decrease the TS_COMP length by the ts_comp_nudge amount. Only a single high or low time is adjusted and the tsCompNudge value is cleared to zero when the nudge has occurred.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pCptsRegs           Pointer to CSL_cptsRegs structure
       tsCompNudge         Time stamp compare nudge value [-128, 127]
*
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Affects</b> <br />
 CPTS_TS_COMP_NUDGE_REG_NUDGE</p>
<p><b>Example</b> </p><pre class="fragment">       int32_t        tsCompNudge;

       tsCompNudge   =   -2;

       CSL_CPTS_setTSCompNudge (pCptsRegs, tsCompNudge);</pre> <hr/>
 
</div>
</div>
<a id="gac90d6b97b58d14b02cd711a6f967d51b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac90d6b97b58d14b02cd711a6f967d51b">&#9670;&nbsp;</a></span>CSL_CPTS_getTSAddVal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CSL_CPTS_getTSAddVal </td>
          <td>(</td>
          <td class="paramtype">CSL_cptsRegs *&#160;</td>
          <td class="paramname"><em>pCptsRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPTS_getTSAddVal</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the Time Stamp Add Value register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pCptsRegs           Pointer to CSL_cptsRegs structure
       pTsAddVal           Time stamp add value read from hardware.
*   </pre><p><b> Return Value </b> <br />
 tsAddVal Time stamp add value read from hardware.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPTS_TS_ADD_VAL_REG_ADD_VAL</p>
<p><b>Example</b> </p><pre class="fragment">       uint32_t          tsAddVal;

       tsAddVal = CSL_CPTS_getTSAddVal (pCptsRegs);</pre> <hr/>
 
</div>
</div>
<a id="ga03f5e389022975228de44242dd1ce2ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03f5e389022975228de44242dd1ce2ae">&#9670;&nbsp;</a></span>CSL_CPTS_setTSAddVal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPTS_setTSAddVal </td>
          <td>(</td>
          <td class="paramtype">CSL_cptsRegs *&#160;</td>
          <td class="paramname"><em>pCptsRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tsAddVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPTS_setTSAddVal</b> </p>
<p><b>Description</b> <br />
 This function sets the Time Stamp Add Value to adjust the 64-bit timestamp value. The tsAddVal[2:0] is added to 1 to comprise the timestamp increment value. The timestamp increment value is added to the current timestamp (time_stamp[63:0]) on each RCLK.</p>
<p>Note that this function is only applicable for 64-bit timestamp mode. In 32-bit timestamp mode, 0 is written.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pCptsRegs           Pointer to CSL_cptsRegs structure
       tsAddVal            Time stamp add value [0, 7]
*
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Affects</b> <br />
 CPTS_TS_ADD_VAL_REG_ADD_VAL</p>
<p><b>Example</b> </p><pre class="fragment">       uint32_t          tsAddVal;

       tsAddVal   =   3;

       CSL_CPTS_setTSAddVal (pCptsRegs, tsAddVal);</pre> <hr/>
 
</div>
</div>
<a id="gab7d5ffabe89d5b4450b05ab2d1ac8bff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7d5ffabe89d5b4450b05ab2d1ac8bff">&#9670;&nbsp;</a></span>CSL_CPTS_setTSNudge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPTS_setTSNudge </td>
          <td>(</td>
          <td class="paramtype">CSL_cptsRegs *&#160;</td>
          <td class="paramname"><em>pCptsRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>tsNudge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPTS_setTSNudge</b> </p>
<p><b>Description</b> <br />
 This function sets the Time Stamp Nudge Value to adjust the 64-bit timestamp value. This two's complement number is added to the time_stamp[63:0] value to increase or decrease the timestamp value by the tsNudge amount. The tsNudge value is cleared to zero when the nudge has occurred.</p>
<p>Note that this function is only applicable for 64-bit timestamp mode. In 32-bit timestamp mode, this function does nothing.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pCptsRegs           Pointer to CSL_cptsRegs structure
       tsNudge             Time stamp nudge value [-128, 127]
*
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Affects</b> <br />
 CPTS_TS_NUDGE_VAL_REG_TS_NUDGE_VAL</p>
<p><b>Example</b> </p><pre class="fragment">       int32_t        tsNudge;

       tsNudge   =   -2;

       CSL_CPTS_setTSNudge (pCptsRegs, tsNudge);</pre> <hr/>
 
</div>
</div>
<a id="ga4813608c74c41d29e34dc48689d8e986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4813608c74c41d29e34dc48689d8e986">&#9670;&nbsp;</a></span>CSL_CPTS_getTSPpm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPTS_getTSPpm </td>
          <td>(</td>
          <td class="paramtype">const CSL_cptsRegs *&#160;</td>
          <td class="paramname"><em>pCptsRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tsPpmVal</em>[2]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPTS_getTSPpm</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the Time Stamp PPM Value register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pCptsRegs           Pointer to CSL_cptsRegs structure
       pTSPpm              PPM value read from hardware.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPTS_TS_PPM_LOW_VAL_REG_TS_PPM_LOW_VAL <br />
 CPTS_TS_PPM_HIGH_VAL_REG_TS_PPM_HIGH_VAL</p>
<p><b>Example</b> </p><pre class="fragment">       uint32_t          tsPpmVal[2];

       CSL_CPTS_getTSPpm (pCptsRegs, tsPpmVal);</pre> <hr/>
 
</div>
</div>
<a id="gaf2f8c9292a942a40e8d3ea85533bcab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2f8c9292a942a40e8d3ea85533bcab5">&#9670;&nbsp;</a></span>CSL_CPTS_setTSPpm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPTS_setTSPpm </td>
          <td>(</td>
          <td class="paramtype">CSL_cptsRegs *&#160;</td>
          <td class="paramname"><em>pCptsRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tsPpmValLo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tsPpmValHi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CSL__CPTS__DATASTRUCT.html#ga04af4285bbbf036d3c6fb60c57049189">CSL_CPTS_TS_PPM_DIR</a>&#160;</td>
          <td class="paramname"><em>tsPpmDir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPTS_setTSPpm</b> </p>
<p><b>Description</b> <br />
 This function sets the parts per million or parts per hour 64-bit timestamp adjustment value. Writing a non-zero tsPpm value enables PPM operations. The adjustment is up or down depending on the tsPpmDir value. The timestamp value is increased by the PPM value when tsPpmDir is CSL_CPTS_TS_PPM_DIR_INCREASE and decreased by the PPM value when tsPpmDir is CSL_CPTS_TS_PPM_DIR_DECREASE.</p>
<p>Note that this function is only applicable for 64-bit timestamp mode. In 32-bit timestamp mode, this function does nothing.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pCptsRegs           Pointer to CSL_cptsRegs structure
       tsPpm               Time stamp nudge value [-128, 127]
       tsPpmDir            Adjustment direction
*
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Affects</b> <br />
 CPTS_CONTROL_REG_TS_PPM_DIR <br />
 CPTS_TS_PPM_HIGH_VAL_REG_TS_PPM_HIGH_VAL <br />
 CPTS_TS_PPM_LOW_VAL_REG_TS_PPM_LOW_VAL</p>
<p><b>Example</b> </p><pre class="fragment">       uint32_t                      tsPpmValLo,
       uint32_t                      tsPpmValHi,
       CSL_CPTS_TS_PPM_DIR         tsPpmDir;

       tsPpmValLo   =   10000UL;
       tsPpmValHi   =   0;
       tsPpmDir = CSL_CPTS_TS_PPM_DIR_INCREASE;

       CSL_CPTS_setTSPpm (pCptsRegs, tsPpmValLo, tsPpmValHi, tsPpmDir);</pre> <hr/>
 
</div>
</div>
<a id="ga9a84ba0252d655f304a641b7dbdb5367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a84ba0252d655f304a641b7dbdb5367">&#9670;&nbsp;</a></span>CSL_CPTS_isRawInterruptStatusBitSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CSL_CPTS_isRawInterruptStatusBitSet </td>
          <td>(</td>
          <td class="paramtype">const CSL_cptsRegs *&#160;</td>
          <td class="paramname"><em>pCptsRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPTS_isRawInterruptStatusBitSet</b> </p>
<p><b>Description</b> <br />
 This function checks the Time Sync Raw Pending Interrupt Register to determine if there is one or more events in the event FIFO.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pCptsRegs           Pointer to CSL_cptsRegs structure
*   </pre><p><b> Return Value </b> <br />
 TRUE One or more events in FIFO. Raw interrupt status bit set. <br />
 FALSE No events in FIFO. Raw interrupt status bit cleared.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPTS_INTSTAT_RAW_REG_TS_PEND_RAW</p>
<p><b>Example</b> </p><pre class="fragment">       if (CSL_CPTS_isRawInterruptStatusBitSet (pCptsRegs) == TRUE)
       {
          // interrupt set
       }
       else
       {
           // interrupt bit not set
       }</pre> <hr/>
 
</div>
</div>
<a id="ga75e95529add3e9dd2a5774245a36e56a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75e95529add3e9dd2a5774245a36e56a">&#9670;&nbsp;</a></span>CSL_CPTS_isMaskedInterruptStatusBitSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CSL_CPTS_isMaskedInterruptStatusBitSet </td>
          <td>(</td>
          <td class="paramtype">const CSL_cptsRegs *&#160;</td>
          <td class="paramname"><em>pCptsRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPTS_isMaskedInterruptStatusBitSet</b> </p>
<p><b>Description</b> <br />
 This function checks the Time Sync Interrupt Status Masked Register to determine if there is one or more events in the event FIFO.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pCptsRegs           Pointer to CSL_cptsRegs structure
*   </pre><p><b> Return Value </b> <br />
 TRUE One or more events in FIFO. masked interrupt status bit set. <br />
 FALSE No events in FIFO. masked interrupt status bit cleared.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPTS_INTSTAT_MASKED_REG_TS_PEND</p>
<p><b>Example</b> </p><pre class="fragment">       if (CSL_CPTS_isMaskedInterruptStatusBitSet (pCptsRegs) == TRUE)
       {
          // masked interrupt set
       }
       else
       {
           // masked interrupt bit not set
       }</pre> <hr/>
 
</div>
</div>
<a id="ga59d5c2b6aed3ea2145e6479c1e7c233b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59d5c2b6aed3ea2145e6479c1e7c233b">&#9670;&nbsp;</a></span>CSL_CPTS_isInterruptEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CSL_CPTS_isInterruptEnabled </td>
          <td>(</td>
          <td class="paramtype">const CSL_cptsRegs *&#160;</td>
          <td class="paramname"><em>pCptsRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPTS_isInterruptEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if Time sync interrupts are enabled.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pCptsRegs           Pointer to CSL_cptsRegs structure
*   </pre><p><b> Return Value </b> <br />
 TRUE Time sync interrupts enabled. <br />
 FALSE Time sync interrupts disabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPTS_INT_ENABLE_REG_TS_PEND_EN</p>
<p><b>Example</b> </p><pre class="fragment">       if (CSL_CPTS_isInterruptEnabled (pCptsRegs) == TRUE)
       {
          // interrupts enabled
       }
       else
       {
           // interrupts disabled
       }</pre> <hr/>
 
</div>
</div>
<a id="ga597fb448cd877a180e2cc85f1067e9ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga597fb448cd877a180e2cc85f1067e9ce">&#9670;&nbsp;</a></span>CSL_CPTS_enableInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPTS_enableInterrupt </td>
          <td>(</td>
          <td class="paramtype">CSL_cptsRegs *&#160;</td>
          <td class="paramname"><em>pCptsRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPTS_enableInterrupt</b> </p>
<p><b>Description</b> <br />
 This function enables the interrupts in Time sync submodule.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pCptsRegs           Pointer to CSL_cptsRegs structure
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPTS_INT_ENABLE_REG_TS_PEND_EN=1</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_CPTS_enableInterrupt (pCptsRegs);</pre> <hr/>
 
</div>
</div>
<a id="ga2f2c24e868686146b73a94ed8f25b9d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f2c24e868686146b73a94ed8f25b9d2">&#9670;&nbsp;</a></span>CSL_CPTS_disableInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPTS_disableInterrupt </td>
          <td>(</td>
          <td class="paramtype">CSL_cptsRegs *&#160;</td>
          <td class="paramname"><em>pCptsRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPTS_disableInterrupt</b> </p>
<p><b>Description</b> <br />
 This function disables the interrupts in Time sync submodule.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pCptsRegs           Pointer to CSL_cptsRegs structure
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPTS_INT_ENABLE_REG_TS_PEND_EN=0</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_CPTS_disableInterrupt (pCptsRegs);</pre> <hr/>
 
</div>
</div>
<a id="ga57bd08d9d5bf2bce79c301f097e076c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57bd08d9d5bf2bce79c301f097e076c8">&#9670;&nbsp;</a></span>CSL_CPTS_popEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPTS_popEvent </td>
          <td>(</td>
          <td class="paramtype">CSL_cptsRegs *&#160;</td>
          <td class="paramname"><em>pCptsRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPTS_popEvent</b> </p>
<p><b>Description</b> <br />
 This function sets up the Event pop bit in Event pop register. This initiates an event to be popped off the event FIFO. Popping an event discards the event and causes the next event, if any, to be moved to the top of the FIFO ready to be read by software on interrupt.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pCptsRegs           Pointer to CSL_cptsRegs structure
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPTS_EVENT_POP_REG_EVENT_POP=1</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_CPTS_popEvent (pCptsRegs);</pre> <hr/>
 
</div>
</div>
<a id="ga1efc479ce4f4fe6f01eaa2fe852df929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1efc479ce4f4fe6f01eaa2fe852df929">&#9670;&nbsp;</a></span>CSL_CPTS_getEventInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPTS_getEventInfo </td>
          <td>(</td>
          <td class="paramtype">const CSL_cptsRegs *&#160;</td>
          <td class="paramname"><em>pCptsRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCSL__CPTS__EVENTINFO.html">CSL_CPTS_EVENTINFO</a> *&#160;</td>
          <td class="paramname"><em>pEventInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPTS_getEventInfo</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the Event Low, Event Middle and Event High registers.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pCptsRegs           Pointer to CSL_cptsRegs structure
       pEventInfo          CSL_CPTS_EVENTINFO structure that needs to be filled
                           with time sync event info read from hardware.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPTS_EVENT_LOW_REG_TIME_STAMP, CPTS_EVENT_MIDDLE_REG_SEQUENCE_ID, CPTS_EVENT_MIDDLE_REG_MESSAGE_TYPE, CPTS_EVENT_MIDDLE_REG_EVENT_TYPE, CPTS_EVENT_MIDDLE_REG_PORT_NUMBER, CPTS_EVENT_HIGH_REG_DOMAIN</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_CPTS_EVENTINFO          eventInfo;

       CSL_CPTS_getEventInfo (pCptsRegs, &amp;eventInfo);</pre> <hr/>
 
</div>
</div>
<a id="ga770ad74a401e5e80cc2ec81bb3a02d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga770ad74a401e5e80cc2ec81bb3a02d20">&#9670;&nbsp;</a></span>CSL_CPTS_getGENFnLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_CPTS_getGENFnLength </td>
          <td>(</td>
          <td class="paramtype">CSL_cptsRegs *&#160;</td>
          <td class="paramname"><em>pCptsRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>genfIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pGenfLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPTS_getGENFnLength</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the GENFn length register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pCptsRegs           Pointer to CSL_cptsRegs structure
       genfIndex           Index of the GENFn to configure
       pGenfLength         GENFn length value obtained from hardware
*   </pre><p><b> Return Value </b> <br />
 0 = success <br />
 -1 = genfIndex is invalid (outside of the valid range)</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPTS_TS_GENF_LENGTH_REG_LENGTH</p>
<p><b>Example</b> </p><pre class="fragment">       uint32_t          genfLength, genfIndex;

       genfIndex = 0;

       CSL_CPTS_getGENFnLength (pCptsRegs, genfIndex, &amp;genfLength);</pre> <hr/>
 
</div>
</div>
<a id="ga87f75817cd9f6c466c2209cb116ac7f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87f75817cd9f6c466c2209cb116ac7f5">&#9670;&nbsp;</a></span>CSL_CPTS_setupGENFn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_CPTS_setupGENFn </td>
          <td>(</td>
          <td class="paramtype">CSL_cptsRegs *&#160;</td>
          <td class="paramname"><em>pCptsRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>genfIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>polarityInv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ppmAdjust</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CSL__CPTS__DATASTRUCT.html#ga04af4285bbbf036d3c6fb60c57049189">CSL_CPTS_TS_PPM_DIR</a>&#160;</td>
          <td class="paramname"><em>ppmDir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPTS_setupGENFn</b> </p>
<p><b>Description</b> <br />
 This function sets the Time Stamp Compare Value of GENFn and triggers the Time Stamp Comparsion operation.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pCptsRegs   Pointer to CSL_cptsRegs structure
       genfIndex   Index of the GENFn to configure
       length      Length of the GENFn output pulse in RCLK periods
       compare     Time stamp compare value (64-bit value) to be loaded
       polarityInv 0 = TS_GENFn is asserted low
                   1 = TS_GENFn is asserted high
       ppmAdjust   PPM adjustment value
       ppmDir      CSL_CPTS_TS_PPM_DIR_INCREASE(0) = A single RCLK is added to
                   the generate function counter at the PPM rate which has the
                   effect of decreasing the generate function frequency by the
                   PPM amount.
                   CSL_CPTS_TS_PPM_DIR_DECREASE(1) = A single RCLK is subtracted
                   from the generate function counter at the PPM rate which
                   has the effect of increasing the generate function
                   frequency by the PPM amount.
*   </pre><p><b> Return Value </b> <br />
 0 = success <br />
 -1 = genfIndex is invalid (outside of the valid range)</p>
<p><b> Pre Condition </b> <br />
 None.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Affects</b> <br />
 CPTS_TS_GENF_LENGTH_REG_LENGTH <br />
 CPTS_TS_GENF_COMP_LOW_REG_COMP_LOW <br />
 CPTS_TS_GENF_COMP_HIGH_REG_COMP_HIGH <br />
 CPTS_TS_GENF_PPM_LOW_REG_PPM_LOW <br />
 CPTS_TS_GENF_PPM_HIGH_REG_PPM_HIGH <br />
 CPTS_TS_GENF_CONTROL_REG_PPM_DIR <br />
 CPTS_TS_GENF_CONTROL_REG_POLARITY_INV</p>
<p><b>Example</b> </p><pre class="fragment">       uint64_t          tsGENFnCompVal;
       uint32_t          tsGENFnLen, tsGENFnIndex;

       tsGENFnIndex   = 0;
       tsGENFnCompVal = 0x3000U;
       tsGENFnLen     = 1000;

       CSL_CPTS_setupGENFn( pCptsRegs, tsGENFnIndex, tsGENFnLen, tsGENFnCompVal, 0, 0, CSL_CPTS_TS_PPM_DIR_INCREASE );</pre> <hr/>
 
</div>
</div>
<a id="gae1de80067232613c909ceb2f87a04a3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1de80067232613c909ceb2f87a04a3f">&#9670;&nbsp;</a></span>CSL_CPTS_setGENFnNudge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_CPTS_setGENFnNudge </td>
          <td>(</td>
          <td class="paramtype">CSL_cptsRegs *&#160;</td>
          <td class="paramname"><em>pCptsRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>genfIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>tsNudge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPTS_setGENFnNudge</b> </p>
<p><b>Description</b> <br />
 This function adjusts the GENFn cycle length by the specified 2's complement value. For example, a value of -2 will subtract 2 RCLKs from the ts_genfN_length[31:0] value. A value of 1 will add 1 RCLK to the ts_genfN_comp_length[23:0] value.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pCptsRegs   Pointer to CSL_cptsRegs structure
       genfIndex   Index of the GENFn to configure
       tsNudge     Nudge value
*   </pre><p><b> Return Value </b> <br />
 0 = success <br />
 -1 = genfIndex is invalid (outside of the valid range)</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Affects</b> <br />
 CPTS_TS_GENF_NUDGE_REG_NUDGE</p>
<p><b>Example</b> </p><pre class="fragment">       int32_t tsNudge = -2;

       CSL_CPTS_setGENFnNudge( pCptsRegs, tsNudge );</pre> <hr/>
 
</div>
</div>
<a id="ga5fc2833f49cccd9eef735c8d0e1a875c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fc2833f49cccd9eef735c8d0e1a875c">&#9670;&nbsp;</a></span>CSL_CPTS_getESTFnLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_CPTS_getESTFnLength </td>
          <td>(</td>
          <td class="paramtype">CSL_cptsRegs *&#160;</td>
          <td class="paramname"><em>pCptsRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>estfIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pEstfLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPTS_getESTFnLength</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the ESTFn length register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pCptsRegs           Pointer to CSL_cptsRegs structure
       estfIndex           Index of the ESTFn to configure
       pEstfLength         ESTFn length value obtained from hardware
*   </pre><p><b> Return Value </b> <br />
 0 = success <br />
 -1 = estfIndex is invalid (outside of the valid range)</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPTS_TS_ESTF_LENGTH_REG_LENGTH</p>
<p><b>Example</b> </p><pre class="fragment">       uint32_t          estfLength, estfIndex;

    estfIndex = 0;

       CSL_CPTS_getESTFnLength (pCptsRegs, estfIndex, &amp;estfLength);</pre> <hr/>
 
</div>
</div>
<a id="ga33c1241061af9c52870ee1fa1b06b143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33c1241061af9c52870ee1fa1b06b143">&#9670;&nbsp;</a></span>CSL_CPTS_setupESTFn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_CPTS_setupESTFn </td>
          <td>(</td>
          <td class="paramtype">CSL_cptsRegs *&#160;</td>
          <td class="paramname"><em>pCptsRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>estfIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>polarityInv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ppmAdjust</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CSL__CPTS__DATASTRUCT.html#ga04af4285bbbf036d3c6fb60c57049189">CSL_CPTS_TS_PPM_DIR</a>&#160;</td>
          <td class="paramname"><em>ppmDir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPTS_setupESTFn</b> </p>
<p><b>Description</b> <br />
 This function sets the Time Stamp Compare Value of ESTFn and triggers the Time Stamp Comparsion operation.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pCptsRegs   Pointer to CSL_cptsRegs structure
       estfIndex   Index of the ESTFn to configure
       length      Length of the ESTFn output pulse in RCLK periods
       compare     Time stamp compare value (64-bit value) to be loaded
       polarityInv 0 = TS_ESTFn is asserted low
                   1 = TS_ESTFn is asserted high
       ppmAdjust   PPM adjustment value
       ppmDir      CSL_CPTS_TS_PPM_DIR_INCREASE(0) = A single RCLK is added to
                   the generate function counter at the PPM rate which has the
                   effect of decreasing the generate function frequency by the
                   PPM amount.
                   CSL_CPTS_TS_PPM_DIR_DECREASE(1) = A single RCLK is subtracted
                   from the generate function counter at the PPM rate which
                   has the effect of increasing the generate function
                   frequency by the PPM amount.
*   </pre><p><b> Return Value </b> <br />
 0 = success <br />
 -1 = estfIndex is invalid (outside of the valid range)</p>
<p><b> Pre Condition </b> <br />
 None.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Affects</b> <br />
 CPTS_TS_ESTF_LENGTH_REG_LENGTH <br />
 CPTS_TS_ESTF_COMP_LOW_REG_COMP_LOW <br />
 CPTS_TS_ESTF_COMP_HIGH_REG_COMP_HIGH <br />
 CPTS_TS_ESTF_PPM_LOW_REG_PPM_LOW <br />
 CPTS_TS_ESTF_PPM_HIGH_REG_PPM_HIGH <br />
 CPTS_TS_ESTF_CONTROL_REG_PPM_DIR <br />
 CPTS_TS_ESTF_CONTROL_REG_POLARITY_INV</p>
<p><b>Example</b> </p><pre class="fragment">       uint64_t          tsESTFnCompVal;
       uint32_t          tsESTFnLen, tsESTFnIndex;

       tsESTFnIndex   = 0;
       tsESTFnCompVal = 0x3000U;
       tsESTFnLen     = 1000;

       CSL_CPTS_setupESTFn( pCptsRegs, tsESTFnIndex, tsESTFnLen, tsESTFnCompVal, 0, 0, CSL_CPTS_TS_PPM_DIR_INCREASE );</pre> <hr/>
 
</div>
</div>
<a id="gacebcb156a3ef4333e45e20e4b95ab308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacebcb156a3ef4333e45e20e4b95ab308">&#9670;&nbsp;</a></span>CSL_CPTS_setESTFnNudge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_CPTS_setESTFnNudge </td>
          <td>(</td>
          <td class="paramtype">CSL_cptsRegs *&#160;</td>
          <td class="paramname"><em>pCptsRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>estfIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>tsNudge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPTS_setESTFnNudge</b> </p>
<p><b>Description</b> <br />
 This function adjusts the ESTFn cycle length by the specified 2's complement value. For example, a value of -2 will subtract 2 RCLKs from the ts_ESTFn_length[31:0] value. A value of 1 will add 1 RCLK to the ts_ESTFn_comp_length[23:0] value.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pCptsRegs   Pointer to CSL_cptsRegs structure
       estfIndex   Index of the ESTFn to configure
       tsNudge     Nudge value
*   </pre><p><b> Return Value </b> <br />
 0 = success <br />
 -1 = estfIndex is invalid (outside of the valid range)</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Affects</b> <br />
 CPTS_TS_ESTF_NUDGE_REG_NUDGE</p>
<p><b>Example</b> </p><pre class="fragment">       int32_t tsNudge = -2;

       CSL_CPTS_setESTFnNudge( pCptsRegs, tsNudge );</pre> <hr/>
 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
