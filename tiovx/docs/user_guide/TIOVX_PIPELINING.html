<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TIOVX User Guide: Graph Pipelining in TIOVX</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ti_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TIOVX User Guide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('TIOVX_PIPELINING.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Graph Pipelining in TIOVX </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>For general pipelining usage guidelines, please follow the Khronos OpenVX pipelining extension <a href="https://registry.khronos.org/OpenVX/extensions/vx_khr_pipelining/1.1/html/vx_khr_pipelining_1_1_0.html" target="_blank">here</a></p>
<h1><a class="anchor" id="NODE_GRAPH_PARAMETER_DEFINITION"></a>
Node and Graph Parameter Definitions</h1>
<p>Pipelining in OpenVX requires an understanding of graph parameters and node parameters. The below sections link to the explanation of these concepts in the OpenVX spec.</p>
<p><a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/tiovx_dev/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/d0/d84/page_design.html#sub_graph_parameters">Graph Parameters</a> : Graph parameters are used in the non-<a href="https://registry.khronos.org/OpenVX/extensions/vx_khr_pipelining/1.1/html/vx_khr_pipelining_1_1_0.html#sec_streaming" target="_blank">streaming</a>, <a href="https://registry.khronos.org/OpenVX/extensions/vx_khr_pipelining/1.1/html/vx_khr_pipelining_1_1_0.html#sec_pipelining" target="_blank">pipelining</a> mode to identify the parameters within a graph that are user-enqueueable. By creating a graph parameter and explicitly enqueue-ing and dequeue-ing this parameter from the graph, the application has the ability to access the object data. Otherwise, when using <a href="https://registry.khronos.org/OpenVX/extensions/vx_khr_pipelining/1.1/html/vx_khr_pipelining_1_1_0.html#sec_pipelining" target="_blank">pipelining</a>, non-graph parameters are not accessible during graph execution.</p>
<p><a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/tiovx_dev/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/d0/d84/page_design.html#sub_node_parameters">Node Parameters</a> : In the TIOVX implementation, node parameters are used to identify where multiple buffers need to be created in the case of <a href="https://registry.khronos.org/OpenVX/extensions/vx_khr_pipelining/1.1/html/vx_khr_pipelining_1_1_0.html#sec_pipelining" target="_blank">pipelining</a>. This is explained further in the <a class="el" href="TIOVX_PIPELINING.html#TIOVX_PIPELINING_PERFORMANCE_OPTIMIZATION_BUFFER_DEPTH">Buffer depth</a> section. If buffer access from the application is needed, the parameter in question should be created as a graph parameter given that multiple buffers will be created at that parameter and there is not a way of accessing a particular buffer of this buffer queue.</p>
<h1><a class="anchor" id="TIOVX_PIPELINING_PERFORMANCE_OPTIMIZATION"></a>
Performance Considerations of Pipelining</h1>
<p>The following section details how to get the best performance and how to optimize the memory footprint of an OpenVX graph. In order to do so, the concepts of graph pipeline depth and buffer depth must be understood in the context of the TIOVX framework. The following two sections provide details about these concepts.</p>
<p>As of Processor SDK 7.2, the TIOVX framework has been enhanced to enable automatic graph pipelining depth and buffer depth setting. This alleviates the burden of the application developer to set these values in order to get real time performance. While the framework will set these values automatically, they can be overwritten by the respective API's used for setting these values. Further explanation is provided in the sections below.</p>
<h2><a class="anchor" id="TIOVX_PIPELINING_PERFORMANCE_OPTIMIZATION_PIPE_DEPTH"></a>
Pipeline depth</h2>
<p>In order to for an OpenVX graph to get full utilization of TI's heterogeneous SoC's, the OpenVX graph must be pipelined. In the TIOVX framework, the characteristic which describes the utilization of the heterogeneous cores is the pipeline depth. Consider a simple 3 node graph seen in the image below. This graph uses 3 cores on the SoC: an ISP, DSP and CPU.</p>
<div class="image">
<img src="basic_graph.png" alt="basic_graph.png"/>
</div>
<p>Without pipelining, a new graph execution would not be able to begin until the initial graph execution was completed. However, since each of these cores can be running concurrently, this graph execution does not allow for the best hardware utilization. The TIOVX pipelining implementation allows for full hardware utilization by internally creating multiple instances of the graph based on the value of the pipeline depth. Therefore, each of these graphs will execute simultaneously, such that each core is actively processing. In this scenario, the optimal pipeline depth is 3. With a pipeline depth of 3, the framework treats the graph as if there were 3 instances of the same graph processing simultaneously as shown below. The image below shows the graph processing at time T=2, such that every processing unit was active.</p>
<div class="image">
<img src="basic_graph_pipelined.png" alt="basic_graph_pipelined.png"/>
</div>
<p>By parsing the structure of the graph, the TIOVX framework can automatically set the pipeline depth and achieve real time performance. The automated pipe depth feature sets the pipe depth during the <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/tiovx_dev/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/d9/d7f/group__group__graph.html#gaa815ffa0b7cc2598d3d53bffc7c8c154">vxVerifyGraph</a> call based on the structure of the graph. For instance, in the example above, the framework will set the pipeline depth to 3, thereby allowing each node in the graph to execute.</p>
<p>The value used as the pipe depth is determined by doing a depth search to find the longest sequence of consecutive nodes within a graph. This methodology is intended to return a pipeline depth that provides the best performance by considering the worst case scenario of OpenVX node target assignment. (For more information about TIOVX targets, see <a class="el" href="TIOVX_ADD_TARGET.html#TIOVX_TARGET_EXPLANATION">Explanation of Targets in TIOVX</a>.) For instance, if in the example above, the OpenVX nodes were all assigned to run on the CPU, the TIOVX framework would still set a pipeline depth of 3.</p>
<p>If the calculated pipe depth value exceeds the <a class="el" href="group__group__vx__graph__cfg.html#gae5d32d340ee632f0c72e0a757fbdf0d6">TIVX_GRAPH_MAX_PIPELINE_DEPTH</a>, the value will be set to the max allowable depth and a warning will be thrown. This value can be increased if necessary by modifying the <a class="el" href="group__group__vx__graph__cfg.html#gae5d32d340ee632f0c72e0a757fbdf0d6">TIVX_GRAPH_MAX_PIPELINE_DEPTH</a> macro in the file <a class="el" href="tivx__config_8h_source.html">tiovx/include/TI/tivx_config.h</a>.</p>
<p>In order to further fine tune and potentially optimize the OpenVX graph, the application developer has the option to set the pipeline depth directly via the <a class="el" href="group__group__tivx__ext__host.html#ga24b3d2d4a691c652efa0399803164b23">tivxSetGraphPipelineDepth</a> API. In this case, the framework will use the value provided by the application rather than the calculated value. However, if this value is less than the optimal value as calculated by the framework, a message will be printed to the console using the <a class="el" href="group__group__vx__debug.html#gga73f8b7d2888a862fd66f8f479eead7e6a572124c2d397cc86c3cd17704b36efc0">VX_ZONE_OPTIMIZATION</a> logging level indicating to the user that this value may not be optimal. By using the <a class="el" href="group__group__tivx__ext__host.html#ga24b3d2d4a691c652efa0399803164b23">tivxSetGraphPipelineDepth</a> API, the application developer can potentially reduce the memory footprint of the graph in the case that real time performance can be achieved by using a smaller pipeline depth value than detected by the framework. In order to know the value the framework is using for pipeline depth, the user can call the <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/tiovx_dev/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/d9/d7f/group__group__graph.html#gaf7d8226c9d24304b2552ffa1aacf79a6">vxQueryGraph</a> API using the <a class="el" href="group__group__tivx__ext__host.html#gga5478f3aed4e2ced0a1840931b741c620ab153b54c6bcdf6cac1ff8ed455cf75ec">TIVX_GRAPH_PIPELINE_DEPTH</a> macro after calling <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/tiovx_dev/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/d9/d7f/group__group__graph.html#gaa815ffa0b7cc2598d3d53bffc7c8c154">vxVerifyGraph</a>.</p>
<h2><a class="anchor" id="TIOVX_PIPELINING_PERFORMANCE_OPTIMIZATION_DELAY_PARAMETERS"></a>
Pipelining with Delay Objects</h2>
<p>It is not recommended to use <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/tiovx_dev/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/de/d09/group__group__delay.html#ga2c6de63476aff4a009bac8d0eb9800d1">vx_delay</a> objects when using pipelining with TIOVX. The delay objects will unintentionally create serializations in the graph and break the desired pipelining.</p>
<p>Instead of using delay objects, graph parameters can be used to emulate a delay in the graph, thus allowing the delay to be handled in the application.</p>
<h2><a class="anchor" id="TIOVX_PIPELINING_PERFORMANCE_OPTIMIZATION_BUFFER_DEPTH"></a>
Buffer depth</h2>
<p>In order for a node producing a buffer to operate concurrently with a node consuming that buffer, multiple buffers must be used at the buffer parameter in order to avoid pipelining stalls. This is illustrated in the diagram below.</p>
<div class="image">
<img src="buffer_queue.png" alt="buffer_queue.png"/>
</div>
<p>As defined in the pipelining specification of OpenVX, a buffer can be created as a graph parameter with multiple buffers created within the application. (For more information on this, see <a class="el" href="TIOVX_PIPELINING.html#NODE_GRAPH_PARAMETER_DEFINITION">Node and Graph Parameter Definitions</a>.) In the case that graph parameters are not used, there is not a native OpenVX API to set multiple buffers at a given node parameter.</p>
<p>In order to allow the OpenVX graph to run with full performance without changing the native implementation of OpenVX, the TIOVX framework will automatically allocate and set the multiple buffers during the <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/tiovx_dev/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/d9/d7f/group__group__graph.html#gaa815ffa0b7cc2598d3d53bffc7c8c154">vxVerifyGraph</a> call according to the node connections of the buffer. The value used as the buffer depth of a particular parameter is found by detecting the total number of nodes connected to a given buffer. For instance, let us consider the example from the previous section. Since each buffer is connected to a single producer node and a single consumer node, the framework will set the buffer depth of each of these parameters to 2 as shown in the below diagram.</p>
<div class="image">
<img src="basic_graph_pipelined_buffering.png" alt="basic_graph_pipelined_buffering.png"/>
</div>
<p>This feature excludes parameters that have already been enabled as graph parameters given that these parameters require the buffer to manually be enqueued and dequeued from the application, therefore requiring the buffer depth to be set in the application.</p>
<p>In order to further fine tune and potentially optimize the OpenVX graph, the application developer has the option to set the buffer depth directly via the <a class="el" href="group__group__tivx__ext__host.html#ga6916eb6d3932500e5732d02e85b8b591">tivxSetNodeParameterNumBufByIndex</a> API. (The parameter being set to use multiple buffers using this API must not already be created as a graph parameter. Otherwise, an error will be thrown during <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/tiovx_dev/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/d9/d7f/group__group__graph.html#gaa815ffa0b7cc2598d3d53bffc7c8c154">vxVerifyGraph</a>.) If the <a class="el" href="group__group__tivx__ext__host.html#ga6916eb6d3932500e5732d02e85b8b591">tivxSetNodeParameterNumBufByIndex</a> API is used, the framework will use the value provided by the application rather than the calculated value. However, if this value is less than the optimal value as calculated by the framework, a message will be printed to the console using the <a class="el" href="group__group__vx__debug.html#gga73f8b7d2888a862fd66f8f479eead7e6a572124c2d397cc86c3cd17704b36efc0">VX_ZONE_OPTIMIZATION</a> logging level indicating to the user that this value may not be optimal. By using the <a class="el" href="group__group__tivx__ext__host.html#ga6916eb6d3932500e5732d02e85b8b591">tivxSetNodeParameterNumBufByIndex</a> API, the application developer can potentially reduce the memory footprint of the graph in the case that real time performance can be achieved by using a smaller buffer depth value than detected by the framework. In order to know the value the framework is using for pipeline depth, the user can call the <a class="el" href="group__group__tivx__ext__host.html#gaa4c239f2ea1bce82ed948f137a34d4fa">tivxGetNodeParameterNumBufByIndex</a> after calling <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/tiovx_dev/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/d9/d7f/group__group__graph.html#gaa815ffa0b7cc2598d3d53bffc7c8c154">vxVerifyGraph</a>.</p>
<h1><a class="anchor" id="TIOVX_PIPELINING_USAGE_CONSIDERATIONS"></a>
Pipelining Usage Considerations</h1>
<h2><a class="anchor" id="TIOVX_PIPELINING_USAGE_CONSIDERATIONS_COMPOSITE_OBJECTS"></a>
Pipelining with Composite Objects</h2>
<p>Composite objects are a special consideration when pipelining using TIOVX. In this context, the definition of a composite object is an OpenVX object that serves as a container for other OpenVX objects. A list of composite objects are given below along with a graph construction suggestion. An explanation for these situations is given in the section below.</p><ul>
<li>Object Arrays (<a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/tiovx_dev/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/db/d9f/group__group__object__array.html">Object: ObjectArray</a>): Pipelining is supported using <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/tiovx_dev/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/d7/d61/group__group__node.html#ga873198f07077015c0f60a66399b1cdf9">vxReplicateNode()</a>.</li>
<li>Pyramids (<a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/tiovx_dev/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/db/d29/group__group__pyramid.html">Object: Pyramid</a>): Pipelining is supported using <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/tiovx_dev/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/d7/d61/group__group__node.html#ga873198f07077015c0f60a66399b1cdf9">vxReplicateNode()</a>.</li>
<li>Region of Interest (ROI) Images (<a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/tiovx_dev/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/df/d09/group__group__image.html#gaf8f9ca43fb8aed127aef27d24d39e4af">vxCreateImageFromROI()</a>): Pipelining is not supported in TIOVX(see: <a class="el" href="TIOVX_PIPELINING.html#ROI_NOTE">ROI_NOTE</a>).</li>
</ul>
<p>Object Arrays and Pyramids are treated similarly in TIOVX from a pipelining perspective. There are many common pipelining scenarios using these objects which arise when developing an application using TIOVX. The following examples illustrate how a graph with object arrays MUST be constructed using TIOVX. Even though the example uses object arrays, the same principles can be applied to the pyramid object with no difference in implementation.</p>
<p>Object arrays are used prevalently in multi-sensor TIOVX applications, such as with the <a class="el" href="group__group__vision__function__capture.html#gaaef37fe795056b535fee0893fada6e25">tivxCaptureNode()</a> which outputs an object array and has as its elements the individual sensor images. These elements will often be processed by downstream nodes, such as the <a class="el" href="group__group__vision__function__vpac__viss.html#gaaa4e6e4ce0061cb6522c2bbb474c5a8a">tivxVpacVissNode()</a> that takes as an input an individual element of the object array, rather than the full object array. This interaction can be seen in the block diagram below.</p>
<div class="image">
<img src="Object_Array_Produced.png" alt="Object_Array_Produced.png"/>
</div>
<p>Similarly, the output objects of multiple nodes may consist of elements of object arrays which then are consumed by a single node in the form of the full object array. As an example, this situation occurs when creating a Surround View application with TIOVX. The individual output images from multiple instances of the VISS node form a single object array, which is consumed by a node generating the Surround View output. This interaction can be seen in the diagram below.</p>
<div class="image">
<img src="Object_Array_Consumed.png" alt="Object_Array_Consumed.png"/>
</div>
<p>OpenVX natively supports two options for supporting the above interaction of sending separate elements of an object array to downstream nodes for processing. The first option is to use the <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/tiovx_dev/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/d7/d61/group__group__node.html#ga873198f07077015c0f60a66399b1cdf9">vxReplicateNode()</a> feature. By using this feature, the application developer avoids re-writing large portions of code by allowing the framework to instantiate as many instances of the node as there are elements in the object array while retaining the ability to customize specific parameters of the node.</p>
<p>The second option OpenVX provides for accessing elements of object arrays is to use the <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/tiovx_dev/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/db/d9f/group__group__object__array.html#ga55cdf3d80a55136be8f5067e3dc965ed">vxGetObjectArrayItem()</a> API. This option is NOT natively supported with pipelining in TIOVX. Therefore, the recommendation is to use the replicate node feature. However, if the replicate node feature cannot be used within the application, a workaround is available when the object array is the output of the producing node and the object array elements are the input of the consumer node. This workaround requires a slight modification of the kernel that is consuming the object array.</p>
<p>Within the OpenVX graph, the <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/tiovx_dev/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/db/d9f/group__group__object__array.html#ga55cdf3d80a55136be8f5067e3dc965ed">vxGetObjectArrayItem()</a> API is called to extract the 0th element of the object array output of the producer node. This element is then passed to the input of the consumer node. In order to extract the appropriate object array item within the kernel consuming the element, the <a class="el" href="group__group__tivx__obj__desc.html#gaaaa134d782ba6e29b07e3d60743911a1" title="Function to get the pointer to an element of an object array. If the object being passed is a regular...">tivxGetObjDescElement()</a> API can be called with the arguments being the object descriptor of the object array element and the appropriate element ID of the object array. This API will then return the object descriptor of the element given as the elem_idx argument. This elem_idx can be provided via a config parameter or sent via the <a class="el" href="group__group__tivx__ext__host.html#ga4cb7e62dba45e9c2fdb49bdb0dc8c3a8" title="Send node specific Control command. ">tivxNodeSendCommand()</a> API depending on the requirements of the kernel. Internally, this API has logic to determine whether or not the input object descriptor is in fact an object array element. If it is not an object array element, it will return the original object descriptor. This provides flexibility to the kernel to handle both the case of if input element is an object array element or non-object array element. An example of this workaround can be found within the display node (video_io/kernels/video_io/display/vx_display_target.c). Note: due to the limitation of the framework, the kernel itself will choose the object array element rather than the application. Therefore, the element ID passed to the <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/tiovx_dev/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/db/d9f/group__group__object__array.html#ga55cdf3d80a55136be8f5067e3dc965ed">vxGetObjectArrayItem()</a> API within the application is ultimately ignored and must be programmed within the kernel.</p>
<p>ROI Images are supported in the non-pipelined implementation of TIOVX. However, pipelining a graph containing ROI images is not supported in TIOVX.</p>
<p><a class="anchor" id="ROI_NOTE"></a>Note: If support for ROI images is required for your application, please request support from your local TI sales representative.</p>
<h2><a class="anchor" id="TIOVX_PIPELINING_USAGE_CONSIDERATIONS_REPLICATE_NODE"></a>
Pipelining with Replicate Node</h2>
<p>When using graph parameters with the <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/tiovx_dev/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/d7/d61/group__group__node.html#ga873198f07077015c0f60a66399b1cdf9">vxReplicateNode</a> feature of OpenVX, there are a few unique scenarios as described above to appropriately pipeline the graph.</p>
<p>Scenario 1: As defined in the OpenVX specification, a node that is replicated uses an element of a composite object (either an object array or a pyramid) with a depth of that object equal to the number of total replicated nodes. Consider the following scenario when using <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/tiovx_dev/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/d7/d61/group__group__node.html#ga873198f07077015c0f60a66399b1cdf9">vxReplicateNode()</a> for pipelining. The node has input and output images that are elements of an object array. In the case that the application needs to access this image data inside application, this parameter must be created as a graph parameter. In this case, the first element of the object array is required to be created as the graph parameter, rather than the entire object array itself.</p>
<div class="image">
<img src="Replicate_Graph_Parameter_Scenario_1.png" alt="Replicate_Graph_Parameter_Scenario_1.png"/>
</div>
<p>Scenario 2: Let us now consider another similar scenario. In the situation below, the object array which is used as an input to the replicated node is also being provided as an input to another node. Whereas the replicated node takes as an input parameter an element of the array, the other node takes as a parameter then entire object array itself. In this scenario it is required to create the graph parameter from the entire object array rather than just the element of the object array as in Scenario 1.</p>
<div class="image">
<img src="Replicate_Graph_Parameter_Scenario_2.png" alt="Replicate_Graph_Parameter_Scenario_2.png"/>
</div>
<h2><a class="anchor" id="TIOVX_PIPELINING_USAGE_CONSIDERATIONS_GRAPH_PARAMETER_SETUP"></a>
Graph Parameter Considerations</h2>
<p>When setting up data references to send as a parameter of the <a class="el" href="vx__khr__pipelining_8h.html#a58c22a176b4cf21657a5ca598dee119c">vxSetGraphScheduleConfig</a> API, all the data references in the list must contain the same meta data as all others in the list of data references. There is presently no validation of the full list of data references done by the framework. The <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/tiovx_dev/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/d9/d7f/group__group__graph.html#gaa815ffa0b7cc2598d3d53bffc7c8c154">vxVerifyGraph</a> performs checks based on the validate callback of each kernel, but this will only validate the first data reference of the list. In the case that subsequent data references have different meta-data than the first, the framework will not validate this. Therefore, all data references must consist of the same meta-data. A validation check has been added to the <a class="el" href="vx__khr__pipelining_8h.html#a58c22a176b4cf21657a5ca598dee119c">vxSetGraphScheduleConfig</a> API to flag this scenario.</p>
<p>Consider the graph below. In the case that Ref 1 is to be made a graph parameter, only a single graph parameter should be made of this reference and it can be made from either node parameter. Therefore, the reference will be dequeued once both the nodes that are consuming the reference are completed. Note, this is only required when the given parameter is at the edge of the graph (i.e., the parameter is not an output of a preceding node.) In the case that it is an internal buffer to a graph and needs to be made as a graph parameter, the graph parameter is created from the output node parameter.</p>
<div class="image">
<img src="graph_parameter.png" alt="graph_parameter.png"/>
</div>
 </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="REFERENCES.html">User Resources</a></li><li class="navelem"><a class="el" href="TIOVX_USAGE.html">TIOVX Usage</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
