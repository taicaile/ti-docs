<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TIOVX User Guide: Memory Management in TIOVX</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ti_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TIOVX User Guide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('TIOVX_MEMORY_MANAGEMENT.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Memory Management in TIOVX </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#TIOVX_MEMORY_MANAGEMENT_INTRODUCTION">Introductory Concepts</a></li>
<li class="level1"><a href="#TIOVX_MEMORY_MANAGEMENT_CREATE">TIOVX Create Phase</a></li>
<li class="level1"><a href="#TIOVX_MEMORY_MANAGEMENT_VERIFY">TIOVX Verify Phase</a></li>
<li class="level1"><a href="#TIOVX_MEMORY_MANAGEMENT_PROCESS">TIOVX Execute Phase</a></li>
<li class="level1"><a href="#TIOVX_MEMORY_MANAGEMENT_DELETE">TIOVX Destroy Phase</a></li>
<li class="level1"><a href="#TIOVX_MEMORY_MANAGEMENT_OPTIMIZATIONS">TIOVX Memory Optimizations</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="TIOVX_MEMORY_MANAGEMENT_INTRODUCTION"></a>
Introductory Concepts</h1>
<p>A given OpenVX graph consists of the states seen in the below diagram. These 4 states are described below:</p><ul>
<li>The "Create" phase involves the creation of all OpenVX objects. These objects may be the OpenVX graphs, nodes, or data objects, such as images, tensors, etc. OpenVX provides simple API's for creating each OpenVX object. For example, an OpenVX graph is created using the <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/tiovx_dev/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/d9/d7f/group__group__graph.html#ga6ce40cbacadd686cc46de313ea3a0fbd">vxCreateGraph()</a> API and an image data object is create using the <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/tiovx_dev/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/df/d09/group__group__image.html#gae7b0f2e7f1be975ad07055c9d7eef1a0">vxCreateImage()</a> API.</li>
<li>The "Verify" phase consists of a single API, <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/tiovx_dev/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/d9/d7f/group__group__graph.html#gaa815ffa0b7cc2598d3d53bffc7c8c154">vxVerifyGraph()</a>. The verify graph API returns a status to the application, describing whether or not this graph is valid and can be processed. Many operations occur within this single API, which are vendor specific. This section will detail the operations occurring from a memory management point of view. For more information on other operations occurring during the verify phase, please see the <a class="el" href="TIOVX_TARGET_KERNEL.html#USER_TARGET_KERNELS">User Target Kernels</a> section.</li>
<li>The "Execute" phase consists of the actual scheduling and processing of the OpenVX graph. During this phase, the process callbacks of each of the nodes are called in a sorted sequence determined in the verify graph phase. The verify graph phase performs a topological sort of the OpenVX nodes in order to determine any data dependencies among the nodes in the graph. During the execute phase, each node is processed according to that order. Once each node completes, any nodes that were dependent on the output data from that node is processed. The below sections describe how this data is transferred across the cores of the SoC.</li>
<li>Similar to the "Create" phase, the "Destroy" phase involves the freeing of all OpenVX objects. Each corresponding object in OpenVX has an associated API for freeing the object. For example, a graph can be freed by calling the <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/tiovx_dev/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/d9/d7f/group__group__graph.html#ga1334f741d1c76d27a0e26117603885f1">vxReleaseGraph()</a> API while an image can be freed by calling the <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/tiovx_dev/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/df/d09/group__group__image.html#gab9d76afb39de187cf82faf9827eab9f1">vxReleaseImage()</a> API.</li>
</ul>
<div class="image">
<img src="openvx_state_machine.png" alt="openvx_state_machine.png"/>
</div>
<h1><a class="anchor" id="TIOVX_MEMORY_MANAGEMENT_CREATE"></a>
TIOVX Create Phase</h1>
<p>At init time of an application using OpenVX, the API <a class="el" href="group__group__tivx__ext__host.html#gad7aa0fdded06205fb515f77c60e8cac7">tivxInit</a> is called upon each core that is being used within an OpenVX application. One of the purposes of the init API is to perform a static allocation of the handles used for OpenVX objects in a non-cached region of DDR. The framework enables logging of the actual amount of these statically allocated structures being used in an application in the event that these values need to be modified.</p>
<p>As mentioned previously, the "Create" phase calls the appropriate create API's for each of the OpenVX data objects within the application. With respect to memory management, the create API's do not allocate the memory needed for the data objects; the memory is allocated in the next phase, the verify phase. Instead, it simply returns an opaque handle to the OpenVX object. Therefore, the memory is not accessible directly within the application. These handles point to object descriptors referred to early that reside in a non-cached region of DDR as well as a set of cached attributes, including the OpenVX object data buffers.</p>
<p>This call sequence highlights the process from the application and framework perspectives when an object is created:</p><ul>
<li><div class="mscgraph">
<img src="msc_data_object_allocation.png" alt="msc_data_object_allocation" border="0" usemap="#msc_data_object_allocation.map"/>
<map name="msc_data_object_allocation.map" id="msc_data_object_allocation.map"></map>
<div class="caption">
Data Object Handle Acquisition Process</div>
</div>
</li>
</ul>
<p>As an example, the following illustrates this procedure when creating image and graph objects:</p><ul>
<li><div class="mscgraph">
<img src="msc_image_graph_allocation.png" alt="msc_image_graph_allocation" border="0" usemap="#msc_image_graph_allocation.map"/>
<map name="msc_image_graph_allocation.map" id="msc_image_graph_allocation.map"></map>
<div class="caption">
Example: Image and Graph Handle Acquisition</div>
</div>
</li>
</ul>
<p>In the event that the memory must be accessed within the application or initialized to a specific value, OpenVX provides certain standard API's for performing a map or copy of the data object. For example, the image object has the map and unmap API's <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/tiovx_dev/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/df/d09/group__group__image.html#ga7f680c04462fcb05a0eae1a96dd923e3">vxMapImagePatch</a> and <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/tiovx_dev/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/df/d09/group__group__image.html#ga251504d5e0c254143e0d0e1077c71181">vxUnmapImagePatch</a> as well as a copy API, <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/tiovx_dev/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/df/d09/group__group__image.html#ga1e413abc4e6bb65c776b438f85d17c80">vxCopyImagePatch</a>. In the event that the memory must be accessed prior to the verify phase, the framework will allocate the buffer(s) associated with the object within shared memory so that it can be accessed.</p>
<h1><a class="anchor" id="TIOVX_MEMORY_MANAGEMENT_VERIFY"></a>
TIOVX Verify Phase</h1>
<p>The allocation and mapping of the OpenVX data objects occurs during the verification phase. The memory for each of the data objects is allocated from a carved out region of DDR shared memory by using the <a class="el" href="group__group__tivx__mem.html#gafbd611b7cd7c93c92cb158dcfda08e5e">tivxMemBufferAlloc</a> API internally within the framework. This allocation is done on the host CPU. By performing this allocation within the vxVerifyGraph call, the framework can return an error at a single point within the application to notify the application that the graph is valid and can be scheduled.</p>
<p>In addition to allocating memory for the OpenVX data objects, the local memory needed for each kernel instance is also allocated during the call to <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/tiovx_dev/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/d9/d7f/group__group__graph.html#gaa815ffa0b7cc2598d3d53bffc7c8c154">vxVerifyGraph</a>. In this context, local memory refers to memory regions accessible by the given core the target kernel is run on. This local memory allocation occurs as the vxVerifyGraph call loops through all the nodes within the graph and calls the "create" callbacks of the given nodes. The design intention of the framework is that all memory allocation occurs during the create callbacks of each kernel, thereby avoiding memory allocation at run-time inside the process callbacks. For more information about the callbacks for each kernel see <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/tiovx_dev/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/da/d83/group__group__user__kernels.html#ga2efd561d09fae3f87e8ba394a88da397">vxAddUserKernel</a> and <a class="el" href="group__group__tivx__target__kernel.html#gaa50c7e8290b65797d1bdc3fdd92ae08e">tivxAddTargetKernel</a>. For more information about the order in which each of these callbacks are called during vxVerifyGraph, see <a class="el" href="TIOVX_TARGET_KERNEL.html#USER_TARGET_KERNELS">User Target Kernels</a>.</p>
<p>Each kernel instance has its own context that allows the kernel instance to store context variables within a data structure using the API's <a class="el" href="group__group__tivx__target__kernel.html#ga551f7060ce2a7e3007424a1da2b184a9">tivxSetTargetKernelInstanceContext</a> and <a class="el" href="group__group__tivx__target__kernel.html#ga08730671086c805df9f4e00d4a4ef383">tivxGetTargetKernelInstanceContext</a>. Therefore, local memory can be allocated and stored within the kernel structure. The simple API's are provided to allocate kernel memory are <a class="el" href="group__group__tivx__mem.html#ga99635ddb13baefecfbb1cf262437ca46">tivxMemAlloc</a> and <a class="el" href="group__group__tivx__mem.html#ga9c487e78534a06bf56eff7dbda470d3a">tivxMemFree</a>. These API's allow memory to be allocated from various memory regions given here <a class="el" href="group__group__tivx__mem.html#ga453747d90eef05b464e633ea644ac0ed">tivx_mem_heap_region_e</a>. For instance, if multiple algorithms are running consecutively within a kernel, intermediate data can be allocated within the kernel context. Also, within the <a class="el" href="group__group__tivx__mem.html#ga453747d90eef05b464e633ea644ac0ed">tivx_mem_heap_region_e</a>, there are attributes to create persistent memory within DDR or to create non-persistent, scratch memory within DDR.</p>
<h1><a class="anchor" id="TIOVX_MEMORY_MANAGEMENT_PROCESS"></a>
TIOVX Execute Phase</h1>
<p>During the scheduling and execution of the OpenVX graphs, the OpenVX data buffers reside in external shared memory and the pointers to each of these data buffers are passed along to subsequent nodes in the graph. Inside each node process callbacks, the node may access the external shared memory via the pointers that have been passed from the previous node. The <a class="el" href="group__group__tivx__mem.html#gab1cd13d212b1d94bf5b9ad24693cbda1">tivxMemBufferMap</a> and <a class="el" href="group__group__tivx__mem.html#ga92eb71d423f6dccb25c28e4b854c4a7d">tivxMemBufferUnmap</a> encapsulate the mapping and cache maintenance operations necessary for mapping the shared memory to the target core. After a node completes, the framework handles the trigerring of nodes depending on the data from the output of the current node.</p>
<h1><a class="anchor" id="TIOVX_MEMORY_MANAGEMENT_DELETE"></a>
TIOVX Destroy Phase</h1>
<p>As mentioned previously, the "Delete" phase calls the appropriate delete API's for each of the OpenVX data objects within the application. At this point, the data buffer(s) of the OpenVX data objects are freed from shared memory using the <a class="el" href="group__group__tivx__mem.html#gabe21a01434fffe5237e13436c669a3b3">tivxMemBufferFree</a> API. This freeing of memory occurs within the individual object's release API's, such as the <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/tiovx_dev/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/df/d09/group__group__image.html#gab9d76afb39de187cf82faf9827eab9f1">vxReleaseImage</a> for the image object.</p>
<h1><a class="anchor" id="TIOVX_MEMORY_MANAGEMENT_OPTIMIZATIONS"></a>
TIOVX Memory Optimizations</h1>
<p>As mentioned above, the default behavior of OpenVX data buffer transfer is to write intermediate buffers to DDR prior to these buffers being read by subsequent nodes. Below are a few recommendations and suggestions of how to optimize memory transfer:</p><ul>
<li>As mentioned during the "Create" section, the amount of statically allocated structures in non-cached memory can be queried and modified. To do so, refer to the following:<ul>
<li>The maximum values of statically allocated structures are defined in the files &lt;TIOVX_PATH&gt;/include/TI/<a class="el" href="tivx__config_8h_source.html">tivx_config.h</a> and &lt;TIOVX_PATH&gt;/include/TI/tivx_config_&lt;SOC&gt;.h</li>
<li>These values were sized according to the applications using OpenVX within the vision_apps repo. However, these values can be increased or decreased depending on the needs of a given application.</li>
<li>The following utility functions were developed to assist in optimizing these values:<ul>
<li><a class="el" href="group__group__tivx__ext__host.html#ga82113169bc0a2029439b82c327ab8b36">tivxPrintAllResourceStats</a> prints the currently used value, maximum used value, and minimum required values</li>
<li><a class="el" href="group__group__tivx__ext__host.html#ga793cd319dcdc028451acc952bbaaff80">tivxQueryResourceStats</a> provides information about the parameter values of a specific resource whose name is passed as a parameter to the function</li>
<li><a class="el" href="group__group__tivx__ext__host.html#gadcb29c60b0b6b5297ed605924716261b">tivxExportAllResourceMaxUsedValueToFile</a> generates a new configuration file called "tivx_config_generated.h" at VX_TEST_DATA_PATH. This config file initializes each parameter to the maximum used value as determined by the previous runtime.</li>
</ul>
</li>
<li>All of the parameter maximum values are documented in <a class="el" href="group__group__vx__framework__config.html">TIOVX Configuration Parameters</a></li>
<li>All of these API's are documented further in <a class="el" href="group__group__tivx__ext__host.html">c: Application Interface APIs</a></li>
</ul>
</li>
<li>In the event that multiple algorithms must be run consecutively on a single core, it is typically recommended to encapsulate this into a single OpenVX kernel. The reason for this is so that the intermediate data can be written to local memory, thereby improving memory access time. This avoids the alternative of splitting the operations into two separate kernels and writing the intermediate data to DDR. Note: this limits the flexibility of these algorithms being deployed separately, and thus must also be weighed in the decision to merge these two algorithms into a single kernel.</li>
<li>Another optimization technique that can be taken advantage of is the usage of DMA to parallelize the memory fetch with the compute of a given target kernel. By using DMA to fetch tiled portions of a given input, a kernel can operate on the input and generate an output in a block-based manner. This can greatly improve the throughput of a given kernel. </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="REFERENCES.html">User Resources</a></li><li class="navelem"><a class="el" href="TIOVX_USAGE.html">TIOVX Usage</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
