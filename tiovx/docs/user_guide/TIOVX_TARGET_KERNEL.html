<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TIOVX User Guide: User Kernels and User Target Kernels</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ti_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TIOVX User Guide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('TIOVX_TARGET_KERNEL.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">User Kernels and User Target Kernels </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#USER_KERNELS">User Kernels</a></li>
<li class="level1"><a href="#USER_TARGET_KERNELS">User Target Kernels</a><ul><li class="level2"><a href="#USER_TARGET_KERNEL_CALLBACK_GUIDELINES">Callback Implementation Guidelines</a></li>
<li class="level2"><a href="#KERNEL_MODULE_INTEGRATION">Kernel Module Integration Guidelines</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="USER_KERNELS"></a>
User Kernels</h1>
<p>The OpenVX specification describes how users can plugin their own kernels (which are only executed on the host core) into OpenVX. TIOVX supports this feature, so for more details on this topic, please refer to the following section from the spec directly: <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/tiovx_dev/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/da/d83/group__group__user__kernels.html">Framework: User Kernels</a></p>
<h1><a class="anchor" id="USER_TARGET_KERNELS"></a>
User Target Kernels</h1>
<p>Since the OpenVX specification only supports host-side user kernels, TI has created its own vendor extension which adds support for users to add kernels on other targets in the system. The API for this extension is: <a class="el" href="group__group__tivx__target__kernel.html">Target Kernel APIs</a></p>
<p>This extension tried to preserve the pattern from the OpenVX spec as much as possible. In fact, on the host cpu, the same apis are used to add a user kernel, except the kernel processing callback should be set to NULL (since the callback is not located on the host core).</p>
<p>Then, on the target side, the <a class="el" href="group__group__tivx__target__kernel.html#gab2279309411e1aa7d19fa92a75c4284b">tivxAddTargetKernelByName</a> function is called to register the target-side callbacks:</p><ul>
<li><b>process_func</b>: Main processing function which is called each time the graph is executed.</li>
<li><b>create_func</b>: Called during graph verification, to perform any local memory setup or one-time configuration.</li>
<li><b>delete_func</b>: Called during graph release, to release local memory or tear-down any local setup.</li>
<li><b>control_func</b>: Can optionally be called asyncronously via <a class="el" href="group__group__tivx__ext__host.html#ga4cb7e62dba45e9c2fdb49bdb0dc8c3a8">tivxNodeSendCommand</a> from the application.</li>
</ul>
<p>The following call sequence shows the relative interaction between the host application and the target kernel callbacks:</p><ul>
<li><div class="mscgraph">
<img src="msc_cdf_verification.png" alt="msc_cdf_verification" border="0" usemap="#msc_cdf_verification.map"/>
<map name="msc_cdf_verification.map" id="msc_cdf_verification.map"><area href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/d9/d7f/group__group__graph.html#gaa815ffa0b7cc2598d3d53bffc7c8c154" shape="rect" coords="156,138,295,153" alt=""/>
<area href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/da/d83/group__group__user__kernels.html#gab796f9f5b334cc29ec640468717cfda2" shape="rect" coords="351,231,549,246" alt=""/>
<area href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/d4/dae/group__group__basic__features.html#gaa2387ff4d3e967f124fb316300503f92" shape="rect" coords="420,267,481,282" alt=""/>
<area href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/da/d83/group__group__user__kernels.html#ga75565ea53f20fb98a9b5c46753a59f3d" shape="rect" coords="351,396,550,411" alt=""/>
<area href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/d4/dae/group__group__basic__features.html#gaa2387ff4d3e967f124fb316300503f92" shape="rect" coords="420,432,481,447" alt=""/>
<area href="group__group__tivx__target__kernel.html#gab2279309411e1aa7d19fa92a75c4284b" shape="rect" coords="446,561,678,576" alt=""/>
<area href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/d4/dae/group__group__basic__features.html#gaa2387ff4d3e967f124fb316300503f92" shape="rect" coords="532,597,593,612" alt=""/>
<area href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/d4/dae/group__group__basic__features.html#gaa2387ff4d3e967f124fb316300503f92" shape="rect" coords="195,690,256,705" alt=""/>
<area href="group__group__tivx__ext__host.html#ga4cb7e62dba45e9c2fdb49bdb0dc8c3a8" shape="rect" coords="111,825,339,840" alt=""/>
<area href="group__group__tivx__target__kernel.html#gab2279309411e1aa7d19fa92a75c4284b" shape="rect" coords="418,861,706,876" alt=""/>
<area href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/d4/dae/group__group__basic__features.html#gaa2387ff4d3e967f124fb316300503f92" shape="rect" coords="532,897,593,912" alt=""/>
<area href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/d4/dae/group__group__basic__features.html#gaa2387ff4d3e967f124fb316300503f92" shape="rect" coords="195,933,256,948" alt=""/>
<area href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/d9/d7f/group__group__graph.html#ga36b37f13ca2269258b813955f7089873" shape="rect" coords="147,1053,303,1068" alt=""/>
<area href="group__group__tivx__target__kernel.html#gab2279309411e1aa7d19fa92a75c4284b" shape="rect" coords="441,1146,684,1161" alt=""/>
<area href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/d4/dae/group__group__basic__features.html#gaa2387ff4d3e967f124fb316300503f92" shape="rect" coords="532,1182,593,1197" alt=""/>
<area href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/d4/dae/group__group__basic__features.html#gaa2387ff4d3e967f124fb316300503f92" shape="rect" coords="195,1275,256,1290" alt=""/>
<area href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/d9/d7f/group__group__graph.html#ga1334f741d1c76d27a0e26117603885f1" shape="rect" coords="142,1410,309,1425" alt=""/>
<area href="group__group__tivx__target__kernel.html#gab2279309411e1aa7d19fa92a75c4284b" shape="rect" coords="447,1482,678,1497" alt=""/>
<area href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/d4/dae/group__group__basic__features.html#gaa2387ff4d3e967f124fb316300503f92" shape="rect" coords="532,1518,593,1533" alt=""/>
<area href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/da/d83/group__group__user__kernels.html#gaad50e89203f962864b27e4f0cedd7249" shape="rect" coords="347,1575,554,1590" alt=""/>
<area href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/d4/dae/group__group__basic__features.html#gaa2387ff4d3e967f124fb316300503f92" shape="rect" coords="420,1611,481,1626" alt=""/>
<area href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/d4/dae/group__group__basic__features.html#gaa2387ff4d3e967f124fb316300503f92" shape="rect" coords="195,1683,256,1698" alt=""/>
</map>
<div class="caption">
Call sequence of a Graph Verify and Release with User Target Kernels.</div>
</div>
</li>
</ul>
<h2><a class="anchor" id="USER_TARGET_KERNEL_CALLBACK_GUIDELINES"></a>
Callback Implementation Guidelines</h2>
<p>When a framework includes user callbacks, there are usually assumptions that the framework makes about how those callbacks are implemented. TIOVX is no exception. The following list contains guidelines and assumptions that User Target Kernel callback implementers should follow for proper usage:</p>
<ul>
<li><b>create_func</b>:<ul>
<li><b>Thread/blocking Implications</b>: The <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/tiovx_dev/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/d9/d7f/group__group__graph.html#gaa815ffa0b7cc2598d3d53bffc7c8c154">vxVerifyGraph</a> function is a blocking function which runs to completion before returning. It calls the create_func callback for each node one by one (sequentially) and then doesn't return until all node create function callbacks return. Therefore, the following guidelines should be followed:<ul>
<li>Do not assume some dependency on another node's create function since it may not have executed yet in the sequence of calls to each node.</li>
<li>Do not assume some dependency on some action that the application does after returning from <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/tiovx_dev/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/d9/d7f/group__group__graph.html#gaa815ffa0b7cc2598d3d53bffc7c8c154">vxVerifyGraph</a>. For example, a blocking call called from within the create_func will result in blocking the full <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/tiovx_dev/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/d9/d7f/group__group__graph.html#gaa815ffa0b7cc2598d3d53bffc7c8c154">vxVerifyGraph</a>, potentially causing a deadlock if the create_func is waiting for further action from the same thread in the application which called <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/tiovx_dev/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/d9/d7f/group__group__graph.html#gaa815ffa0b7cc2598d3d53bffc7c8c154">vxVerifyGraph</a>, or from another node's create function.</li>
</ul>
</li>
<li><b>Memory Implications</b>: If there is some context which needs to be accessed for the other target-side callbacks, it should be created in the create_func since memory allocations are not allowed in any callback except the create_func callback.<ul>
<li>The context pointer can be allocated using <a class="el" href="group__group__tivx__mem.html#ga99635ddb13baefecfbb1cf262437ca46">tivxMemAlloc</a>. The following is an example of the allocation of the <code>tivxCannyParams</code> data structure context: <div class="fragment"><div class="line">tivxCannyParams prms = <a class="code" href="group__group__tivx__mem.html#ga99635ddb13baefecfbb1cf262437ca46">tivxMemAlloc</a>(<span class="keyword">sizeof</span>(tivxCannyParams), <a class="code" href="group__group__tivx__mem.html#gga453747d90eef05b464e633ea644ac0eda9efbb1abf57ed3bd769d6c7d8ee3a48d">TIVX_MEM_EXTERNAL</a>);</div></div><!-- fragment --></li>
<li>The allocated context needs to be added to the kernel instance using the <a class="el" href="group__group__tivx__target__kernel.html#ga551f7060ce2a7e3007424a1da2b184a9">tivxSetTargetKernelInstanceContext</a> function (so the other callbacks can retrieve it): <div class="fragment"><div class="line"><a class="code" href="group__group__tivx__target__kernel.html#ga551f7060ce2a7e3007424a1da2b184a9">tivxSetTargetKernelInstanceContext</a>(kernel, prms, <span class="keyword">sizeof</span>(tivxCannyParams));</div></div><!-- fragment --></li>
<li>If the node instance needs additional scratch or persistent memory, memory can be "allocated" in the create_func callback using the <a class="el" href="group__group__tivx__mem.html#ga99635ddb13baefecfbb1cf262437ca46">tivxMemAlloc</a> function. Then the corresponding pointers and sizes can be added to the context structure. For persistent memory allocations, allocation can be made out of <a class="el" href="group__group__tivx__mem.html#gga453747d90eef05b464e633ea644ac0eda9efbb1abf57ed3bd769d6c7d8ee3a48d">TIVX_MEM_EXTERNAL</a>, for scratch memory, it can made out of <a class="el" href="group__group__tivx__mem.html#gga453747d90eef05b464e633ea644ac0edab964eb8b3434742f82f55a789ea6b888">TIVX_MEM_EXTERNAL_SCRATCH</a>.<ul>
<li>If allocating out of scratch memory, the following function should be called for each node before any scratch allocations are made: <div class="fragment"><div class="line">status = <a class="code" href="group__group__tivx__mem.html#ga16520a2672658dccb5c45034ace99688">tivxMemResetScratchHeap</a>(<a class="code" href="group__group__tivx__mem.html#gga453747d90eef05b464e633ea644ac0edab964eb8b3434742f82f55a789ea6b888">TIVX_MEM_EXTERNAL_SCRATCH</a>);</div></div><!-- fragment --></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><b>process_func</b>:<ul>
<li><b>Thread/blocking Implications</b>: The process_func callback is called for each node in order of graph dependency, and each target is executing in its own thread. Therefore, for each target, the node process functions are queued up in order of arrival at each target, and are executed to completion before starting the next node process function queued up for that specific target. Nodes running on different targets can execute in parallel. Therefore, the following guidelines should be followed:<ul>
<li>If no target is assigned by the application, the framework statically assigns it to a target in which it is implemented for. The framework does not automatically optimize node target assignments in the graph to run in parallel on another target. This optimization is left to the application writer. For example, if a kernel is implemented on the C66 DSP, and the platform support 2 C66 DSP targets, then the framework will assign both of them to run on <a class="el" href="group__group__tivx__ext__targets.html#gab68210419fad8fb7be1a93197de2c106">TIVX_TARGET_DSP1</a> sequentially. If the graph is written is such a way that these can be run in parallel or pipelined across both DSPs, then the application can call <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/tiovx_dev/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/d7/d61/group__group__node.html#ga7409f4d86e22259caae9c0d42b18cbd9">vxSetNodeTarget</a> for each of the nodes to run on a different target.</li>
</ul>
</li>
<li><b>Memory Implications</b>: No memory allocations should happen in the process_func callback. Any memory allocations should have been created in the create_func (see above).<ul>
<li>If there is some context which needs to be accessed/updated from the create_func callback, it can be retrieved from the kernel instance using the <a class="el" href="group__group__tivx__target__kernel.html#ga08730671086c805df9f4e00d4a4ef383">tivxGetTargetKernelInstanceContext</a> function: <div class="fragment"><div class="line">status = <a class="code" href="group__group__tivx__target__kernel.html#ga08730671086c805df9f4e00d4a4ef383">tivxGetTargetKernelInstanceContext</a>(kernel, (<span class="keywordtype">void</span> **)&amp;prms, &amp;size);</div></div><!-- fragment --></li>
</ul>
</li>
</ul>
</li>
<li><b>control_func</b>:<ul>
<li><b>Thread/blocking Implications</b>: The control_func callback (if implemented) is triggered from the application by calling <a class="el" href="group__group__tivx__ext__host.html#ga4cb7e62dba45e9c2fdb49bdb0dc8c3a8">tivxNodeSendCommand</a>. The call to <a class="el" href="group__group__tivx__ext__host.html#ga4cb7e62dba45e9c2fdb49bdb0dc8c3a8">tivxNodeSendCommand</a> is blocked until the target can complete execution of the corresponding control_func callback. Note that each target has a pending command queue. If, during the processing of a graph, a target has multiple process_func and control_func commands in flight at the same time, they are serialized on a FIFO (first in first out) order to each target's command queue, and each one is executed in order. This guarantees the thread safe behavior of process_func and control_func commands within each target, but has implications on how long the corresponding call to <a class="el" href="group__group__tivx__ext__host.html#ga4cb7e62dba45e9c2fdb49bdb0dc8c3a8">tivxNodeSendCommand</a> may be blocked. Therefore, the following guidelines shall be followed:<ul>
<li>The calling thread will be blocked until the control_func can be executed on the command queue for the target, and returns, so consider this in the implementation of the callback.</li>
<li>Since the call is made asynchronous to the process_func, there is no guarantee on the order or exact time the command will get executed (i.e. it could get executed a few frames after it was called depending on the instantaneous depth of the command queue for this target).</li>
</ul>
</li>
<li><b>Memory Implications</b>: No memory allocations should happen in the control_func callback. Any memory allocations should have been created in the create_func (see above).<ul>
<li>If there is some context which needs to be accessed/updated from the create_func callback, it can be retrieved from the kernel instance using the <a class="el" href="group__group__tivx__target__kernel.html#ga08730671086c805df9f4e00d4a4ef383">tivxGetTargetKernelInstanceContext</a> function: <div class="fragment"><div class="line">status = <a class="code" href="group__group__tivx__target__kernel.html#ga08730671086c805df9f4e00d4a4ef383">tivxGetTargetKernelInstanceContext</a>(kernel, (<span class="keywordtype">void</span> **)&amp;prms, &amp;size);</div></div><!-- fragment --></li>
<li>The control_func callback (if implemented) should only be called after <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/tiovx_dev/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/d9/d7f/group__group__graph.html#gaa815ffa0b7cc2598d3d53bffc7c8c154">vxVerifyGraph</a> and before <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/tiovx_dev/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/d9/d7f/group__group__graph.html#ga1334f741d1c76d27a0e26117603885f1">vxReleaseGraph</a>, since it may need to access the kernel instance context, which only exists in the time between these two calls.</li>
</ul>
</li>
</ul>
</li>
<li><b>delete_func</b>:<ul>
<li><b>Thread/blocking Implications</b>: The <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/tiovx_dev/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/d9/d7f/group__group__graph.html#ga1334f741d1c76d27a0e26117603885f1">vxReleaseGraph</a> function is a blocking function which runs to completion before returning. It calls the delete_func callback for each node one by one (sequentially) and then doesn't return until all node delete function callbacks return. Therefore, the following guidelines shall be followed:<ul>
<li>Do not assume some dependency on another node's delete function since it may not have executed yet in the sequence of calls to each node.</li>
<li>Do not assume some dependency on some action that the application does after returning from <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/tiovx_dev/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/d9/d7f/group__group__graph.html#ga1334f741d1c76d27a0e26117603885f1">vxReleaseGraph</a>. For example, a blocking call called from within the delete_func will result in blocking the full <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/tiovx_dev/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/d9/d7f/group__group__graph.html#ga1334f741d1c76d27a0e26117603885f1">vxReleaseGraph</a>, potentially causing a deadlock if the delete_func is waiting for further action from the same thread in the application which called <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/tiovx_dev/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/d9/d7f/group__group__graph.html#ga1334f741d1c76d27a0e26117603885f1">vxReleaseGraph</a>, or from another node's create function.</li>
</ul>
</li>
<li><b>Memory Implications</b>: All memory buffers allocated during the create_func should be freed in the destroy_func<ul>
<li>If there is some context which was allocated in the create_func callback, it can be retrieved from the kernel instance using the <a class="el" href="group__group__tivx__target__kernel.html#ga08730671086c805df9f4e00d4a4ef383">tivxGetTargetKernelInstanceContext</a> function: <div class="fragment"><div class="line">status = <a class="code" href="group__group__tivx__target__kernel.html#ga08730671086c805df9f4e00d4a4ef383">tivxGetTargetKernelInstanceContext</a>(kernel, (<span class="keywordtype">void</span> **)&amp;prms, &amp;size);</div></div><!-- fragment --></li>
<li>If the node instance context included pointers/sizes to additional scratch or persistent memory allocated in the create_func callback, should be freed in the destroy_func callback using the <a class="el" href="group__group__tivx__mem.html#ga9c487e78534a06bf56eff7dbda470d3a">tivxMemFree</a> function.</li>
<li>Finally, the allocated context needs to be freed from the kernel instance using the <a class="el" href="group__group__tivx__mem.html#ga9c487e78534a06bf56eff7dbda470d3a">tivxMemFree</a> function: <div class="fragment"><div class="line"><a class="code" href="group__group__tivx__mem.html#ga9c487e78534a06bf56eff7dbda470d3a">tivxMemFree</a>(prms, <span class="keyword">sizeof</span>(tivxCannyParams), <a class="code" href="group__group__tivx__mem.html#gga453747d90eef05b464e633ea644ac0eda9efbb1abf57ed3bd769d6c7d8ee3a48d">TIVX_MEM_EXTERNAL</a>);</div></div><!-- fragment --></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="KERNEL_MODULE_INTEGRATION"></a>
Kernel Module Integration Guidelines</h2>
<p>In order to integrate a kernel as a node into an OpenVX graph, the callbacks of the kernel must be registered with the framework. The OpenVX spec defines how user kernels are to be registered, specifically using the <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/tiovx_dev/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/da/d83/group__group__user__kernels.html#gae00b6343fbb0126e3bf0f587b09393a3">vxLoadKernels()</a> API. This registration of kernels comes as a registration of an entire module of kernels that have a common function. For instance, the OpenVX standard kernels are contained within a single kernel module. OpenVX modules can be enabled or disabled depending on whether or not the kernels within that module need to be included in an application. By excluding the modules that are not used, this saves code size and memory.</p>
<p>In the case of a user target kernel, an additional registration must be performed on the target rather than simply registering the kernel module on the host. This is due to the fact that target kernels contain two sets of callbacks, one set on the host and one set on the remote target core as described in the section above. Therefore, each of these kernel registrations must occur on the core where the callbacks will be invoked.</p>
<p>As mentioned, these invocations will occur in two places. First, the host callbacks may be invoked directly from the application. For instance, when one of the Hardware Accelerator (HWA) kernels are to be used in an application, the <a class="el" href="group__group__vision__function__hwa.html#gadac6c9c72b814ea84fd2d6fed3a2b534">tivxHwaLoadKernels()</a> must be called prior to the instantiation of any HWA nodes in an application. <a class="el" href="group__group__vision__function__hwa.html#ga1d2fa88522a8e5de79caada02aa3a5c5">tivxHwaUnLoadKernels()</a> must also be called during application deinitialization. These API's are wrapper API's for the <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/tiovx_dev/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/da/d83/group__group__user__kernels.html#gae00b6343fbb0126e3bf0f587b09393a3">vxLoadKernels()</a> and <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/tiovx_dev/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/da/d83/group__group__user__kernels.html#ga3858119e0af1af43181aba4be9a35d63">vxUnloadKernels()</a> API's. Similarly, any new kernel module must have an equivalent kernel module loading and unloading done from the application.</p>
<p>Second, the target side callbacks must also be registered on the appropriate core that the kernel module in question is intended to be run on. If integrating a kernel module in vision_apps, this kernel registration can be done as a part of the appRegisterOpenVXTargetKernels() in the file vision_apps/apps/basic_demos/app_rtos/common/app_init.c. This init code is common to all cores, so it is recommended to add build macros around the kernel registration in order to only allow it to register on the intended cores. As an example, the TIDL kernel module running on the C7x is registered by adding the tivxRegisterTIDLTargetKernels() to the appRegisterOpenVXTargetKernels() with build macros around the call to guarantee that it only registers on the C7x.</p>
<p>The PyTIOVX tool can be used by a kernel developer to generate much of this boilerplate kernel registration code with a simple Python script. For more information about the PyTIOVX tool, please see: <a class="el" href="PYTIOVX.html">PyTIOVX User Guide</a>. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="REFERENCES.html">User Resources</a></li><li class="navelem"><a class="el" href="TIOVX_USAGE.html">TIOVX Usage</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
