<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Documentation for XML_TI_OFD.pm</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>
<table border="0" width="100%" cellspacing="0" cellpadding="3">
<tr><td class="_podblock_" style="background-color: #cccccc; color: #000" valign="middle">
<big><strong><span class="_podblock_">&nbsp;Documentation for XML_TI_OFD.pm</span></strong></big>
</td></tr>
</table>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#USAGE">USAGE</a></li>
  <li><a href="#LIMITATIONS">LIMITATIONS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#FUNCTIONS-EXPORTED-BY-DEFAULT">FUNCTIONS EXPORTED BY DEFAULT</a>
    <ul>
      <li><a href="#ofd_process_xml_file">ofd_process_xml_file</a></li>
      <li><a href="#ofd_find_lib_name">ofd_find_lib_name</a></li>
      <li><a href="#ofd_get_input_file_name">ofd_get_input_file_name</a></li>
      <li><a href="#ofd_each_file">ofd_each_file</a></li>
      <li><a href="#ofd_each_section">ofd_each_section</a></li>
      <li><a href="#ofd_each_symbol">ofd_each_symbol</a></li>
      <li><a href="#ofd_each_die_entry">ofd_each_die_entry</a></li>
      <li><a href="#ofd_filter_xml">ofd_filter_xml</a></li>
      <li><a href="#ofd_strip_xml">ofd_strip_xml</a></li>
      <li><a href="#ofd_filter_and_parse_xml">ofd_filter_and_parse_xml</a></li>
      <li><a href="#ofd_has_dwarf">ofd_has_dwarf</a></li>
      <li><a href="#ofd_find_debug_info">ofd_find_debug_info</a></li>
      <li><a href="#ofd_find_compile_unit_die">ofd_find_compile_unit_die</a></li>
      <li><a href="#ofd_find_all_dies">ofd_find_all_dies</a></li>
      <li><a href="#ofd_put_dies_in_array">ofd_put_dies_in_array</a></li>
      <li><a href="#ofd_put_dies_in_hash">ofd_put_dies_in_hash</a></li>
      <li><a href="#ofd_find_attrs">ofd_find_attrs</a></li>
      <li><a href="#ofd_cg_xml_version">ofd_cg_xml_version</a></li>
    </ul>
  </li>
  <li><a href="#VERSION-CHECKING">VERSION CHECKING</a>
    <ul>
      <li><a href="#Version-2.00">Version 2.00</a></li>
      <li><a href="#Version-2.10">Version 2.10</a></li>
      <li><a href="#Version-2.11">Version 2.11</a></li>
      <li><a href="#Version-2.20">Version 2.20</a></li>
      <li><a href="#Version-3.10">Version 3.10</a></li>
      <li><a href="#Version-3.11">Version 3.11</a></li>
    </ul>
  </li>
  <li><a href="#DEBUG-FEATURES">DEBUG FEATURES</a>
    <ul>
      <li><a href="#XML_TI_OFD::debug">$XML_TI_OFD::debug</a></li>
      <li><a href="#XML_TI_OFD::dump_out">XML_TI_OFD::dump_out</a></li>
    </ul>
  </li>
</ul>

<h1 id="NAME">NAME</h1>

<p>XML_TI_OFD.pm</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<p>Perl module for converting XML files generated by TI OFD utilities into Perl data structures</p>

<h1 id="USAGE">USAGE</h1>

<pre><code>   use XML_TI_OFD;                               # don&#39;t check version</code></pre>

<p>OR ...</p>

<pre><code>   use XML_TI_OFD 3.10;                          # check module version</code></pre>

<p>The second form insures you are picking up the module version 3.10 or later.</p>

<h1 id="LIMITATIONS">LIMITATIONS</h1>

<p>This is an alpha version of capability for processing ELF files. Only fully linked .out files have been tested as input. Other types of ELF files such as unlinked .obj files, library files, dynamically linked files, have NOT been tested.</p>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>OFD stands for Object File Display utility. Examples include ofd6x for C6000 and ofd55 for C5500. This utility outputs information about TI object files, or libraries of TI object files. This utility can output this information in XML format with the -x option. Use this module to turn that XML data into far more useful Perl data structures.</p>

<p>This module should be delivered with at least one example usage file &quot;dump_ofd.pl&quot;. Start by using and exploring that script. All it does is read in the XML file and dump out the resulting Perl data structures. Understanding those data structures is key to implementing any further object file post-processing routines.</p>

<h1 id="FUNCTIONS-EXPORTED-BY-DEFAULT">FUNCTIONS EXPORTED BY DEFAULT</h1>

<p>The most commonly used functions in the module.</p>

<h2 id="ofd_process_xml_file">ofd_process_xml_file</h2>

<p>Input: Name of the XML file, or a string that holds all the XML</p>

<p>Returns: Reference to data structure representing XML tree</p>

<p>Main entry point to the module.</p>

<h2 id="ofd_find_lib_name">ofd_find_lib_name</h2>

<p>Input: Reference to Perl data structure returned by ofd_process_xml_file</p>

<p>Returns: Name of the library, if it exists. undef otherwise.</p>

<p>The main way to check if input file is a library or not.</p>

<h2 id="ofd_get_input_file_name">ofd_get_input_file_name</h2>

<p>Input: Reference to Perl data structure returned by ofd_process_xml_file</p>

<p>Returns: The name of the input object file or library used to build the XML information.</p>

<h2 id="ofd_each_file">ofd_each_file</h2>

<p>Input: Reference to Perl data structure returned by ofd_process_xml_file</p>

<p>Returns: Array of references, one per file in the XML data structure</p>

<p>It doesn&#39;t matter whether the underlying data structure came from a library or a single .obj/.out file. Typical usage ...</p>

<pre><code>       $xml_data = ofd_process_xml_file($file_name);
       if ($lib_name = ofd_find_lib_name($xml_data))
       {
          print &quot;Processing library $lib_name ...&quot;;
       }
  
       foreach $file_data (ofd_each_file($xml_data))
       {
          print &quot;Processing file $file_data-&gt;{&#39;name&#39;} ...&quot;;
          process_file($file_data);
       }   
  </code></pre>

<p>Note that if the underlying file is not a library, a library name will not be printed, and the foreach loop will execute only once.</p>

<p>If you just want the first file no matter how many there may be ...</p>

<pre><code>       @file_list = ofd_each_file($xml_data);
       $file_data = $file_list[0];</code></pre>

<h2 id="ofd_each_section">ofd_each_section</h2>

<p>Input: An element from an array returned by ofd_each_file</p>

<p>Returns: Array of references, one per section in the file</p>

<p>Typical usage:</p>

<pre><code>        foreach $file_data (ofd_each_file($xml_data))
        {
           foreach $sect_data (ofd_each_section($file_data))
           {
              ...
           }
        }   </code></pre>

<h2 id="ofd_each_symbol">ofd_each_symbol</h2>

<p>Input: An element from an array returned by ofd_each_file</p>

<p>Returns: Array of references, one per symbol in the file</p>

<p>Typical usage:</p>

<pre><code>        foreach $file_data (ofd_each_file($xml_data))
        {
           foreach $symbol_data (ofd_each_symbol($file_data))
           {
              ...
           }
        }   </code></pre>

<h2 id="ofd_each_die_entry">ofd_each_die_entry</h2>

<p>Input: A compile_unit reference from the dwarf data</p>

<p>Returns: Array of references, one per DIE entry</p>

<p>Typical usage:</p>

<pre><code>        foreach my $die_tag (ofd_each_die_entry($compile_unit)) {
           ...
        }   </code></pre>

<p>DIE entries can be at 2 different levels hence the need for a function in this module to abstract such details. Object files (and .out&#39;s linked with -b to disable type merging) have an extra level {&#39;die&#39;}-&gt;[0]-&gt;{&#39;die&#39;} compared to standard TI out files {&#39;die&#39;} for their type information. XML can only be represented by 1 or the other so check for which &amp; return it.</p>

<h2 id="ofd_filter_xml">ofd_filter_xml</h2>

<pre><code> Input: - Name of the XML file, or undef if passing a string
        - Reference to a string
        - A hash of arguments described below

 Returns: Nothing directly.  String is returned via ref (2nd argument).</code></pre>

<p>The XML files created by OFD can be very large, especially if the -g option is used to include the Dwarf information. Files in the tens of megabytes are common. Use this function to filter the XML file, keeping only the parts you specify, thus making the rest of your script run much faster.</p>

<p>Using this function is not required for correctness. It only affects execution speed.</p>

<p>The 2nd argument is a reference to a string. If no filename is passed, then this string is the input to be stripped. It is assigned all the lines from the stripped down XML file. This string (not a reference to it) can be passed to ofd_process_xml_file().</p>

<p>The hash that, taken together, comprises arguments 3 through N, can have the following key/value pairs:</p>

<pre><code> SECTION : Reference to a list of section names.  All &lt;section&gt;&#39;s are 
   removed except those named here.  If this argument is not supplied,
   no sections are removed.
 DIE_TAG : Reference to a list of Dwarf tag names.  All DIE&#39;S, except
   those with the given tag names, are removed.  If this argument is not
   supplied, no DIE&#39;s are removed.</code></pre>

<p>If a proposed part of XML to remove is found to nest another similar part, it is not removed. For example, DIE&#39;s that nest other DIE&#39;s are not removed, no matter what the tag name is.</p>

<h2 id="ofd_strip_xml">ofd_strip_xml</h2>

<pre><code> Input: - Name of the XML file, or undef if passing a string
        - Reference to a string
        - A hash of arguments described below

 Returns: Nothing directly.  String is returned via ref (2nd argument).</code></pre>

<p>Similar to ofd_filter_xml, except you specify what should be stripped away. And you can pass an additional argument: GENERAL.</p>

<p>The hash that, taken together, comprises arguments 3 through N, can have the following key/value pairs:</p>

<pre><code> GENERAL : Reference to a list of XML tags.  Everything enclosed by one
   of these XML tags is removed.
 SECTION : Reference to a list of section names.  Every &lt;section&gt; with
   one of these names is removed.
 DIE_TAG : Reference to a list of Dwarf tag names.  Every DIE with one
   of these tag names is removed.</code></pre>

<p>If a proposed part of XML to remove is found to nest another similar part, it is not removed. For example, DIE&#39;s that nest other DIE&#39;s are not removed, even it matches the name of a tag you supply.</p>

<p>Calling this function is tricky. It is easy to make a mistake. You need detailed knowledge of both the OFD XML and the information the script is using from the XML. Your best bet is to find an example script that uses it and understand what it is doing.</p>

<h2 id="ofd_filter_and_parse_xml">ofd_filter_and_parse_xml</h2>

<pre><code> Input: - Name of the XML file, or &#39;-&#39; for stdin
        - A hash of arguments described below

 Returns: Reference to data structure representing the XML</code></pre>

<p>This function does (conceptually) the same thing as ...</p>

<pre><code>    ofd_filter_xml(...);
    ofd_strip_xml(...);
    $xml_data = ofd_process_xml_file(...);</code></pre>

<p>For a very large (&gt; 10 MB) XML file, using this function instead takes much less memory. By thus avoiding or reducing memory thrashing, it can run much faster.</p>

<p>The hash passed after the filename is composed of ...</p>

<pre><code> FILTER =&gt; reference to a hash of arguments passed to ofd_filter_xml
 STRIP  =&gt; reference to a hash of arguments passed to ofd_strip_xml
 XML_PEEK =&gt; reference to a function that expects a reference to the
   $all_lines scalar (from the XML file).  This function usually saves off
   bits of information about the XML.</code></pre>

<p>A typical call looks like ...</p>

<pre><code>   $xml_data = 
      ofd_filter_and_parse_xml(
         $xml_file,
         FILTER =&gt; { SECTION =&gt; [qw(.debug_info)],
                     DIE_TAG =&gt; [qw(DW_TAG_TI_branch
                                    DW_TAG_compile_unit
                                    DW_TAG_TI_reserved_3
                                    DW_TAG_subprogram)] },
         STRIP =&gt; { GENERAL =&gt; [qw(string_table
                                   raw_data
                                   line_numbers)] },
         XML_PEEK =&gt; \&amp;xml_peek);</code></pre>

<h2 id="ofd_has_dwarf">ofd_has_dwarf</h2>

<pre><code> Input: An element from an array returned by ofd_each_file

 Returns: True if XML data has Dwarf information, false otherwise</code></pre>

<h2 id="ofd_find_debug_info">ofd_find_debug_info</h2>

<pre><code> Input: An element from an array returned by ofd_each_file

 Returns: Reference to the .debug_info section from the Dwarf information.
   Returns undef if it is not found or is poorly formed.</code></pre>

<h2 id="ofd_find_compile_unit_die">ofd_find_compile_unit_die</h2>

<pre><code>  Input: A reference to a single element of the &quot;compile_unit&quot; array at
    the top level of the Dwarf data structure.

  Returns: A reference to the DIE contained within the compile unit that
    has the tag DW_TAG_compile_unit</code></pre>

<p>A &quot;compile unit&quot; is really just a fancy name for a file. A compile unit data structure almost always looks like ...</p>

<pre><code>           &#39;compile_unit&#39; =&gt; [         # list of files
           {
             &#39;die&#39; =&gt; [                # list of top level DIE&#39;s
             {
               &#39;tag&#39; =&gt; &#39;DW_TAG_compile_unit&#39;
               ...</code></pre>

<p>It is possible there are no DIE&#39;s, or when there is more than one, the DW_TAG_compile unit DIE is not the first one. This routine sorts through all that to return the DW_TAG_compile_unit DIE, or undef if not found.</p>

<h2 id="ofd_find_all_dies">ofd_find_all_dies</h2>

<pre><code> Input: - A reference to the first DIE to search
        - A reference to a hash for saving off all the DIE&#39;s, indexed by
          DIE id.  Pass undef if not desired.
        - The remaining argument are a hash described below.</code></pre>

<p>Use this function to organize DIE&#39;s into hashes separated by tag name, and indexed by DIE id.</p>

<p>The arguments 3 through N comprise a hash where keys are Dwarf tags and values are references to a hash, keyed by id, that saves off DIE&#39;s with the matching tag. There is no limit on the length of this hash. Search for as many tags as you want.</p>

<p>Arguments 2 through N can be undef (though it is pointless for all of them to be undef).</p>

<p>A typical call looks like ...</p>

<pre><code>         ofd_find_all_dies($top_level_die, \%dies_by_id,
                           DW_TAG_TI_branch     =&gt; \%branch_dies,
                           DW_TAG_TI_reserved_3 =&gt; \%branch_dies);</code></pre>

<h2 id="ofd_put_dies_in_array">ofd_put_dies_in_array</h2>

<pre><code> Input: - A reference to the first DIE to search
        - The remaining arguments are a hash described below</code></pre>

<p>Use this function to organize DIE&#39;s into arrays separated by tag name.</p>

<p>Arguments 2 through N comprise a hash where keys are Dwarf tags and values are references to an array used to save off the DIE&#39;s with the matching tag. There is no limit on the length of this hash. Search for as many tags as you want. DIE&#39;s are searched and placed into the corresponding array in the same order as they are found in the XML, which is the same order as they are placed in the object file.</p>

<h2 id="ofd_put_dies_in_hash">ofd_put_dies_in_hash</h2>

<pre><code> Input: - A reference to the first DIE to search
        - The remaining argument are a hash described below.</code></pre>

<p>Use this function to organize DIE&#39;s into hashes separated by tag name, and indexed by DIE id.</p>

<p>The arguments 2 through N comprise a hash where keys are Dwarf tags and values are references to a hash, keyed by id, that saves off DIE&#39;s with the matching tag. There is no limit on the length of this hash. Search for as many tags as you want.</p>

<h2 id="ofd_find_attrs">ofd_find_attrs</h2>

<pre><code>  Input: - Reference to a DIE whose attributes are searched
         - The remaining arguments are a hash described below</code></pre>

<p>Use this function to copy the attributes of a DIE to variables.</p>

<p>Arguments 2 through N comprise a hash where keys are Dwarf attributes and values are references to variables which are assigned the value of the attribute. There is no limit to the length of this hash. Search for as many attributes as you want.</p>

<p>A typical call looks like ...</p>

<pre><code>        ofd_find_attrs($func_die,
                       DW_AT_TI_symbol_name =&gt; \$func_name,
                       DW_AT_low_pc         =&gt; \$start_addr,
                       DW_AT_high_pc        =&gt; \$end_addr);</code></pre>

<p>Tip on recommended use: Set all the scalars to undef just before calling, then insure that subsequent code can handle any one scalar remaining undef.</p>

<h2 id="ofd_cg_xml_version">ofd_cg_xml_version</h2>

<p>If the command line option --cg_xml_version is present, print out, on stderr, the version of the cg_xml package in use. Must be called BEFORE the main script does any command line processing.</p>

<h1 id="VERSION-CHECKING">VERSION CHECKING</h1>

<p>You can have Perl automatically check you are using the correct version of XML_TI_OFD.pm by writing something similar to ...</p>

<pre><code>   use XML_TI_OFD 2.11;</code></pre>

<p>So you know what version to check for, here is a quick summary of what version introduced which functions or changes ...</p>

<h2 id="Version-2.00">Version 2.00</h2>

<p>Introduce the functions:</p>

<pre><code> - ofd_process_xml_file
 - ofd_find_lib_name
 - ofd_get_input_file_name
 - ofd_each_file
 - ofd_each_section
 - ofd_each_symbol
 - ofd_each_die_entry</code></pre>

<h2 id="Version-2.10">Version 2.10</h2>

<p>Introduces the function:</p>

<pre><code> - ofd_strip_xml</code></pre>

<h2 id="Version-2.11">Version 2.11</h2>

<p>Introduces the functions:</p>

<pre><code> - ofd_filter_xml
 - ofd_has_dwarf
 - ofd_find_debug_info
 - ofd_find_compile_unit_die
 - ofd_find_all_dies
 - ofd_find_attrs</code></pre>

<p>Also, can pass string to ofd_strip_xml by passing undef for the file arg</p>

<h2 id="Version-2.20">Version 2.20</h2>

<p>Introduces the functions:</p>

<pre><code> - ofd_filter_and_parse_xml
 - ofd_put_dies_in_array
 - ofd_put_dies_in_hash</code></pre>

<h2 id="Version-3.10">Version 3.10</h2>

<p>Introduces support for ELF files.</p>

<h2 id="Version-3.11">Version 3.11</h2>

<p>Introduces the function: ofd_cg_xml_version</p>

<h1 id="DEBUG-FEATURES">DEBUG FEATURES</h1>

<p>Access to this variable and function are strictly limited to the fully qualified XML_TI_OFD:: syntax. These names are too widely used to be handled any other way.</p>

<h2 id="XML_TI_OFD::debug">$XML_TI_OFD::debug</h2>

<p>Whether to dump the Perl data structures to stdout. Set to undef by default.</p>

<h2 id="XML_TI_OFD::dump_out">XML_TI_OFD::dump_out</h2>

<p>Input: Reference to all or part of the Perl data structure corresponding to the XML file.</p>

<p>Returns: Nothing</p>

<p>Dumps the Perl data structure to STDOUT. Helpful for understanding how to traverse the data structure, or diagnose bugs.</p>

<table border="0" width="100%" cellspacing="0" cellpadding="3">
<tr><td class="_podblock_" style="background-color: #cccccc; color: #000" valign="middle">
<big><strong><span class="_podblock_">&nbsp;Documentation for XML_TI_OFD.pm</span></strong></big>
</td></tr>
</table>

</body>

</html>


